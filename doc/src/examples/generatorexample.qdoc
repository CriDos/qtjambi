/*!
    \page qtjambi-generatorexample.qdoc
    \title The Qt Jambi Generator
    
    The Qt Jambi Generator example shows how to use the Qt Jambi Generator to map 
    an existing C++ project to Java.
    
    \image generatorexample.png Screenshot of the Qt Jambi Generator example
    
    The premise for this example is that we have an existing library written in C++. This 
    library contains an API for programming computer adventure games, and we want to make this same 
    API available to Java programmers. Since the library is already in use, the C++ code is locked and
    we cannot make changes to it. Thus, any tweaks needed to make the Java API smoother will have to
    be added to the "type system", the XML description of the library which is used by the Qt Jambi
    generator when it's creating the mapping.
    
    In this document, we will go through the design of the type system step by step. We will not focus 
    on the inner workings of the source library, but rather explain concepts as the need arises. The 
    library in question is quite complicated to map, in that it has been specifically written to 
    have several API intricacies that serve to illustrate concepts in the Qt Jambi Generator.
    
    \section1 Getting started
    A good way to start is to create an empty type system for the project, and then running the generator. 
    This will give us several warnings and helpful logs that help us identify the types we wish to 
    map to Java.
    
    A minimal type system only has a root \c typesystem tag that specifies the package name of our project. 
    Each distinct package should have a distinct type system specification. In our case, we will only generate
    a single package, and thus we will only need a single xml file. We will also expand our minimal specification
    to include references to type systems for the parts of Qt we will use in the generated API. In order to use types 
    from Qt we require these specifications, or the generator will not know how to handle them when it's producing
    the binding code. 
    
    The default type systems for Qt are special and can be referred to on the general form
    ":/trolltech/generator/typesystem_module.txt", where "module" can be replaced by "core", "gui", "xml", "svg",
    "network", "opengl" or "sql". When importing custom made type systems, any absolute or relative path can
    be used to address the specification xml file.
    
    We will only import type systems for modules QtCore and QtGui in our project, as these are the two modules 
    that are actually in use.
    
    \code
    <typesystem package="com.trolltech.examples.generator" default-superclass="com.trolltech.qt.QtJambiObject">
        <load-typesystem name=":/trolltech/generator/typesystem_core.txt" generate="no" />
        <load-typesystem name=":/trolltech/generator/typesystem_gui.txt" generate="no" />
    </typesystem>    
    \endcode
    
    In our \c load-typesystem tags, we are setting the attribute \c generate to "no" to indicate that we only
    wish to import the information, not actually generate code for the Qt library. We also need to specify 
    the default super class of the project. It is required that this class is a sub class of \c QtJambiObject.
    
    The next step before we can start, is to create a global header file for our project. The Qt Jambi Generator
    requires that the class definition for any type we wish to map into Java is available through a single 
    header file. A simple way to achieve this is to create a top level header file in which preprocessor directives
    are used to import all header files from the project. We will create the file "global.h".
    
    \code 
    #include "abstractgameobject.h"
    #include "gameaction.h"
    #include "gameanimation.h"
    #include "gamegrammar.h"
    #include "gamenamespace.h"
    #include "gameobject.h"
    #include "gamescene.h"
    #include "lookaction.h"
    #include "pickupaction.h"
    #include "point3d.h"
    #include "useaction.h"    
    \endcode
    
    The final step to get started is to run the Qt Jambi Generator. The generator takes to arguments on the
    command line: first the path to the global header file, and second the path to the type system specification.
    You will need to have the \c $QTDIR environment variable set to the location on your disk where the Qt include 
    files are available (the generator expects these to be found under "$QTDIR/include".)
    
    Provided that the generator executable is available in your \c $PATH, you can open a command line shell, 
    cd into the generator example folder and write the following command:       
    
    \code
    generator global.h typesystem_generatorexample.txt
    \endcode
    
    The generator will produce several log files that we, among other things, can use to quickly identify the types
    that need to be added to the type system.
    
    \section1 Adding types
    
    The time has come to import our classes into the type system specification. For an overview of classes that have
    been defined in the header file but not in the type system, we will look at the log file "mjb_rejected_classes.log".
    
    Under the heading "Not in type system" we find the names of our classes: \c AbstractGameObject, 
    \c GameAction, \c GameAnimation, \c GameGrammar, \c GameObject, \c GameScene, \c LookAction, \c PickUpAction,
    \c Point3D, and \c UseAction. We want to expose all these in the Java API, thus they need to be entered into
    the type system specification.
    
    For each of the classes, we will have to provide the generator with at least one significant piece of meta information:
    Whether the class should be considered a value-type or object-type. The general rule is that value types are usually
    allocated on the stack and passed by reference or value between functions. They are not polymorphic, so they
    cannot have virtual functions. A typical example of a value type is \c QString. Object types are often allocated
    on the heap, they can be polymorphic, and they are passed between functions using pointers.
    
    In our case, the only value type we have is the class \c Point3D. We can tell that \c Point3D is a value type
    e.g. by observing that functions expecting parameters of the type receive a constant reference to it.    
    
    We proceed by adding the type definitions to the type system specification.
    
    \code
    <object-type name="AbstractGameObject" />
    <object-type name="GameAction" />
    <object-type name="GameAnimation" />
    <object-type name="GameGrammar" />
    <object-type name="GameObject" />
    <object-type name="GameScene" />
    <object-type name="LookAction" />
    <object-type name="PickUpAction" />    
    <object-type name="UseAction" />
    
    <value-type name="Point3D" />
    \endcode    
    
    When we run the generator again, code will be generated, and we will see several new warnings that can help us continue. 
    
    \section1 Adding the namespace
    
    Many of the Qt Jambi Generator's warnings at this point has to do with missing types inside the \c Game namespace,
    which is a namespace containing all definitions of enums used in the library. The generator also tells us that
    "namespace 'Game' does not have a type entry". Since Java has the concept of packages, namespaces will typically
    be ignored by a type system specification. The exception is namespaces used to wrap enum types, such as the 
    \c Qt namespace in Qt, and such as the \c Game namespace in our library. 
    
    Since we wish to include this type in the type system, we will add an entry for it in the specification.
    
    \code
    <namespace-type name="Game" />
    \endcode
    
    This will eliminate the warning about the missing type entry, but the generator will still warn us that certain
    functions cannot be mapped because types defined inside the \c Game namespace have not been specified. We will 
    need to specify which of the enum types we wish to map. The log file "mjb_rejected_enums.log" is helpful 
    to identify these. In our case, we will map all the enum types in the \c Game namespace.
    
    \code
    <enum-type name="Game::ActionType" />
    <enum-type name="Game::AnimationType" />
    <enum-type name="Game::ObjectFlag" />
    <enum-type name="Game::WalkingDirection" />    
    \endcode
    
    In addition to these four types, the log file also mentions a \c GameObject::enum_1. This is a special
    name given to an anonymous enum type inside of the class \c GameObject. It is used in C++ to allow
    safe casts between \c QGraphicsItem and its subclasses. Java has a reflection API that covers all 
    classes, so this enum is of no use to us. Therefore we will not provide it with a type entry. Instead
    we will suppress the warning so it does not confuse us any further.
    
    When suppressing warnings, we either specify the warning exactly as it looks in the output from the
    generator, "WARNING(MetaJavaBuilder) :: enum 'GameObject::enum_1' does not have a type entry or is not an enum",
    or we can add wildcards to filter out several warnings with a single entry. 
    
    \code
    <suppress-warning text="*GameObject::enum_1*" />
    \endcode
    
    As we do not want any warnings pertaining to the enum type \c GameObject::enum_1, we simply suppress any warning 
    containing this particular type name.
    
    \section1 Tweaking the enum specifications
    
    We will not leave the enum types alone just yet. There is a little more work required to make their functions in
    Java match the intentions in the original API. In general, there are two things we need to consider for each
    enum type: Are there any relevant warnings for the enum type, and is the enum type extensible?
        
    Looking through our warnings, we can find a few warnings that are related to enum types.
    
    \list
    \o duplicate enum values: Game::ActionType, PickUp and Take are 3    
    \o skipping function 'GameObject::setFlags', unmatched parameter type 'Game::ObjectFlags'
    \o skipping function 'GameObject::objectFlags', unmatched return type 'Game::ObjectFlags'
    \endlist
    
    \section2 Duplicate enum values
    
    The first warning alert us that two values in the enum type \c Game::ActionType have the same value. Such
    a case cannot be mapped by the Qt Jambi Generator, as it requires a one-to-one relationship between
    the numerical values in an enum type and its enum values. 
    
    There are two possible solutions to this problem. The preferred resolution is most cases will be to reject
    one of the two conflicting values, and only expose one in the Java API. This is what we will do in this case,
    and we will reject the enum value \c Take.
    
    \code
    <enum-type name="Game::ActionType">
        <reject-enum-value name="Take" />        
    </enum-type>
    \endcode
                
    In some rare cases, it will not be efficient simply to reject one of the conflicting enum values. This is
    specifically true in cases where a single enum type contains context specific values that overlap. 
    Removing values from such a type may cause the resulting Java API to become less readable and less usable.
    For such cases it is possible to force the use of integers rather than proper Java enums as a mapping of 
    specific enum types. The consequence is that use of the enum type in the API will be substituted with \c int,
    and hence will not be type safe. 
    
    \code
    <enum-type name="Game::ActionType" force-integer="yes" />
    \endcode
    
    \section2 Unmatched type
    
    The Qt Jambi Generator complains that the type \c Game::ObjectFlags is used in the API but remains
    unspecified in the type system. In the original C++ code, this is a typedef of the type 
    \c QFlags<Game::ObjectFlag> where \c Game::ObjectFlag is an enum type. This is a pattern used in Qt to
    provide type safe flags in the API.
    
    To map such types, we will need to especially tell the generator that it should provide the same abstraction
    in the generated Java API. This is done using the attribute \c flags.
    
    \code 
    <enum-type name="Game::ObjectFlag" flags="Game::ObjectFlags" />
    \endcode
    
    By specifying that the enum type \c Game::ObjectFlag has a corresponding flags type, we ensure that the 
    Qt Jambi Generator creates a class \c ObjectFlags based on the same pattern as the original typedef in
    C++.
    
    \section2 Extensible enums
    
    When mapping enums we also need to check if they are intended to be extensible in the original API. If they 
    are, then we need to enter this information into the type system specification. A typical example of an
    extensible enum is \c Game::ActionType. This has a value \c UserAction which can be used as a base for 
    dynamic additions to the enum type (e.g. if the users of the library implement their own \c GameAction
    subclass in our case.)
    
    \code
    <enum-type name="Game::ActionType" extensible="yes">
        <reject-enum-value name="Take" />        
    </enum-type>
    \endcode    
    
    We set the \c extensible attribute to yes, and the Qt Jambi Generator will generate code in which extending the enum
    is possible.
    
    \section1 Interface types
    
    Java does not allow multiple inheritance, so in cases where the original C++ code uses this technique, 
    we need to provide a resolution in order to generate compilable code. The standard way of resolving such
    issues in Java is to use an interface pattern. 
    
    In our source library, the class \c GameObject inherits from two classes: \c QObject and \c AbstractGameObject.
    The generator gives us a warning that both these are currently considered primary base classes.
    
    In general, we need to define as interfaces all except for one base class in a multiple inheritance situation.
    The class \c QObject cannot be an interface type, as it is not a type we have any control over when mapping our
    library. Luckily, though, the class \c AbstractGameObject follows the interface pattern, and we can replace its
    type entry in the type system specification with a new one.
    
    \code
    <interface-type name="AbstractGameObject" />
    \endcode
    
    \section1 Polymorphic value but no id
    
    In order to properly generate conversion code for certain types, the Qt Jambi Generator requires their
    class hierarchy to be known. In cases where such types are being converted, but their class definitions
    are not available, the generator will complain that the types have "polymorphic value but no id". In
    the case of our example project, it will warn us about \c QEvent and several of its subclasses. These warnings
    should be taken seriously, and the resolution is simply to provide the generator with the class definitions
    it requires. We do this by including the header files for the event classes in our "global.h" file.
    
    \section1 Compiling the code
    
    We now have generated code to match the API of the source C++ library. The generated code will however usually 
    not compile directly without some small modifications to the type system. We try to compile the project and 
    read the error messages provided by the compiler to see what problems we have.
    
    \section2 Creating the .pro file
    
    In order to build the C++ code that provides the binding between C++ and Java, we first need to write 
    a .pro file that \c qmake can use to generate cross platform makefiles.
    
    An easy way to do this is to base our .pro file on generator_example.pro located in the generator example
    folder. We will need to make some modifications to it in order to map our project. First and foremost,
    we should change the name of the target library. When using the Qt Jambi Generator, this should be the
    name of our package with underscores substituted for periods.
    
    \code
    TARGET = com_trolltech_examples_generator
    \endcode
    
    Secondly, we will need to change the \c HEADERS and \c SOURCES variables, so \c qmake can know which files
    need to be compiled and linked into the library.
    
    \code
    HEADERS += gameaction.h \
           gameanimation.h \
           gamegrammar.h \
           gamenamespace.h \
           gameobject.h \
           gamescene.h \
           lookaction.h \
           pickupaction.h \
           useaction.h \
           point3d.h \
           abstractgameobject.h

    SOURCES += gameaction.cpp \
            gameanimation.cpp \
            gamegrammar.cpp \
            gameobject.cpp \
            gamescene.cpp \
            lookaction.cpp \
            pickupaction.cpp \
            useaction.cpp \
            main.cpp
    \endcode            
    
    And finally, we will have to provide \c qmake with the path to the list of generated c++ files. By default
    the generator targets a folder located at "../cpp/com_trolltech_examples_generator" where 
    the name "com_trolltech_examples_generator" is based on the package name of the type system. In this folder,
    it creates a .pri file which contains the necessary \c qmake commands to include the generated files in the
    build.
    
    \code
    include(../cpp/com_trolltech_examples_generator/com_trolltech_examples_generator.pri)
    \endcode
    
    Otherwise, the .pro file can remain unchanged.
    
    \section2 Compiling the C++ code
    
    If we start a build at this point, we will get two error messages from the compiler:
    
    \list
    \o Cannot open include file: 'Game' 
    \o 'const QStyleOptionGraphicsItem *' : unknown size 
    \endlist
    
    To see what the issue is, we can look at the actual generated source code and try to figure it out. In many
    cases, though, the errors are caused by the generator's failure to find the header file where a certain type
    is defined. In this case, the generator has selected a default header file for the namespace \c Game, which 
    is the same as the name of the namespace. This needs to be replaced by the actual name of the header file,
    "gamenamespace.h". To replace the default include directive of a type, we use the \c include tag.
    
    \code
    <namespace-type name="Game">    
        <include file-name="gamenamespace.h" location="local" />
    </namespace-type>
    \endcode
    
    The \c location attribute tells the generator that this is a local header (the resulting include directive
    will use quotes around the file name.)
    
    In addition, the class \c QStyleOptionGraphicsItem is forward declared in the headers read by the generator,
    and the definition cannot be found. We need to provide the generator with the name of the header file where
    \c QStyleOptionGraphicsItem is defined. This should not replace the default header for any type in the type
    system, but needs to be added as an extra include directive where the type is used. This is the case for
    the type \c GameScene.
    
    \code
    <object-type name="GameScene">
        <extra-includes>
            <include file-name="QStyleOptionGraphicsItem" location="global" />
        </extra-includes>
    </object-type>
    \endcode
    
    After regenerating with this modification, the C++ code compiles. The Java code compiles without modifications.    
        
    \section1 QNativePointer API
    We've eliminated the generator warnings and made our project compile. The next step is to make our Java API
    as user friendly as possible. There are a few potential issues in the generated code which the generator
    will not bring to your attention. 
    
    The first issue we will handle is API where the class \c QNativePointer is in use. This class is a generic 
    wrapper around pointers to value types, and is designed to be useful regardless of the intended use of the
    pointer (whether it's a pointer to an object or an array.) 
    
    It's error proned and inefficient to use, however, so in most cases we will want to manually modify the 
    generated API so that we do not have any functions where this type is in use.
    
    To help us with this task is the log file "mjb_nativepointer_api.log" created by the generator. This 
    contains a complete list of all public or protected functions in the API for which the generator 
    currently uses \c QNativePointer. In general, there are three different ways we can resolve such issues.
    
    \section2 Removing a function    
    
    In some cases it is not possible to provide the exact same functionality that we have in the C++ API 
    without using \c QNativePointer. For instance, the functions \c rx(), \c ry(), \c rz() in \c Point3D
    return references to \c ints in the original API. The particular data resides in the native library's
    memory, and there is no way we can provide a reference to this int without going through some abstraction.
    
    Since these functions only exist as added convenience, and the same functionality is provided through
    other functions, it is safe to reject the functions from the API. 
    
    \code
    <value-type name="Point3D">
        <modify-function signature="rx()">
            <remove />
        </modify-function>
        <modify-function signature="ry()">
            <remove />
        </modify-function>
        <modify-function signature="rz()">
            <remove />
        </modify-function>
    </value-type>
    \endcode
    
    We add a \c modify-function tag for each of the three functions. The \c signature attribute should be 
    set to the signature of the function without return type or variable names. The signature provided
    in the "mjb_nativepointer_api.log" file is correctly formatted for this purpose.
    
    For each of the function modifications we tell the generator to remove the function from the API.
    
    \section2 Injecting conversion code into the API
    
    For non-virtual functions that use \c QNativePointer, the simplest way to improve the API is usually
    to hide the function by making it private, and to provide a new implementation where we simply call the 
    original and take care of the conversion to a more user friendly type.
    
    The function \c rposition() in the class \c GameObject is a candidate for this. In the original API,
    this function returns a reference to an object of the class \c Point3D. This becomes a \c QNativePointer
    in the generated class. The first step is to make the function private, so that it cannot be accessed 
    by users of the class.
    
    \code 
    <object-type name="GameObject">
        <modify-function signature="rposition()">
            <access modifier="private" />
            <rename to="rposition_private" />
        </modify-function>
    </object-type>
    \endcode    
    
    Since we will create a new implementation of the same function, we also rename the original to \c rposition_private() 
    to avoid name collisions. The next step is to write the new implementation. We will use the \c inject-code tag
    to inject code into the generated class. Code can be placed directly inside the \c inject-code tag, or we can
    write it as a template and simply instantiate this. The latter ensures that the code is reusable without being
    duplicated, which is probably preferable for large projects.
    
    \code
    <template name="from_nativepointer_to_value_type">
            public final %RETURN_TYPE% %FUNCTION_NAME%() {
                return %RETURN_TYPE%.fromNativePointer(%ORIGINAL_FUNCTION_NAME%());
            }            
    </template>
    \endcode
    
    In the template, we have generalized the code by putting place holder tokens in place for the function
    name and the return type. Inside the specification of the \c GameObject class, we can insert the template
    and replace the tokens with actual values. We will use the \c insert-template tag, which can be placed
    anywhere source code is expected.
    
    \code
    <inject-code>
        <insert-template name="from_nativepointer_to_value_type">
            <replace from="%RETURN_TYPE%" to="Point3D" />
            <replace from="%FUNCTION_NAME%" to="rposition" />
            <replace from="%ORIGINAL_FUNCTION_NAME%" to="rposition_private" />
        </insert-template>
    </inject-code>
    \endcode    
    
    \section2 Changing the function signature: Modifying the type of an argument
    
    When the functions using the \c QNativePointer class are virtual, we need to take extra care. The reimplementation
    technique from the previous section will not work in this case, as we in this case would not be able to 
    maintain polymorphism over the boundary between Java and C++. Modifying such functions to improve the API can be 
    difficult, as it may require us to write JNI code. It is recommended that you attempt to address the issue in the
    original API if at all possible.
    
    The technique we will use in this case is to manually modify the signature of the function directly, and provide
    the generator with special conversion rules which explain how to convert the altered arguments from Java to C++
    and vice versa.
    
    The function in question is \c perform(Game::ActionType,AbstractGameObject**,int) in the class \c AbstractGameObject.
    In the original API it takes, as the second argument, an array of pointers to objects of the \c AbstractGameObject class, 
    and, as the final argument, an integer containing the length of the array. In the Java API, it takes a QNativePointer
    and an integer.
    
    We will modify the signature of this function to take a Java array instead, and since Java arrays contain their own 
    lengths embedded, we will remove the final argument from the signature.
    
    The first step is to modify the type of the second argument to be a Java array. We will use the \c replace-type tag,
    which resides inside a \c modify-argument tag.
    
    \code
    <interface-type name="AbstractGameObject">
        <modify-function signature="perform(Game::ActionType,AbstractGameObject**,int)">            
            <modify-argument index="2">
                <replace-type modified-type="com.trolltech.examples.generator.AbstractGameObject[]" />                                
            </modify-argument>            
        </modify-function>
    </interface-type>
    \endcode
    
    The modified type name is the fully qualified name of the substitute class, with square brackets to indicate that the
    type is an array. At this point, we cannot expect the function to work properly, as the generated code will try
    to convert a C++ array of \c AbstractGameObject pointers to a Java array with the same conversion routine used
    for converting to \c QNativePointer, and the other way around. We need to provide the generator with new conversion
    code for this particular argument.
    
    First we will do this for the conversion from C++ to Java. This is the case where code written in C++ calls the
    virtual function, and it has been reimplemented in Java. We will add the following code to the \c modify-argument
    tag we already have.
    
    \code
    <conversion-rule>
        jobjectArray %out = qtjambi_from_array(__jni_env, %in, %3, 
                                                "AbstractGameObject", 
                                                "com/trolltech/examples/generator/");
    </conversion-rule>
    \endcode
    
    This code uses JNI and Qt Jambi helper functions to convert the C++ array to Java. 
    
    Special things to notice in this code is:    
    \list
    \o \c __jni_env which is the current JNI environment pointer, 
    \o \c %out and %in which will be replaced by, respectively, the name of the output variable and input variable of
       the conversion.
    \o \c %3 which will be replaced by the name of the third argument (the integer length) in the function call.
    \endlist
    
    Secondly, we need to provide a similar rule for conversion from Java to C++. This is used in the case where 
    Java code calls a C++ implementation of the function. This code will be slightly more complicated.
    
    \code
    <modify-function class="native" signature="perform(Game::ActionType,AbstractGameObject**,int)">            
        <modify-argument index="2">
            <conversion-rule>
            QVector&lt;AbstractGameObject *> gameObjects;
            
            int arrayLength = __jni_env->GetArrayLength((jarray) %in);
            for (int i=0; i&lt;arrayLength; ++i) {
                jobject gameObject = __jni_env->GetObjectArrayElement((jobjectArray) %in, i);
                gameObjects.append((AbstractGameObject *) qtjambi_to_object(__jni_env, gameObject));        
            }
            
            AbstractGameObject **%out = gameObjects.data();
            </conversion-rule>
        </modify-argument>
    </modify-function>           
    \endcode        
    
    We need to add a new function modification to the \c AbstractGameObject class. In this one we set the \c class
    attribute to native, to indicate that we wish the conversion rule to have an effect on the C++ part of the bindings.
    The \c &lt; tokens are codes for the opening angle bracket to be compatible with xml.
    
    The code itself converts each object in the Java array to a C++ object using a Qt Jambi helper function, and 
    places it inside a \c QVector. The \c perform function will not take ownership of the array that is passed in,
    and therefore it's safe to pass the data pointer of the \c QVector, even though it will be deleted after the
    call is through.
    
    \section2 Changing the function signature: Removing an argument
    
    As mentioned we also want to remove the final argument from the signature of the \c perform function. Instead,
    we will rely on the \c length field in the class of the Java array.
    
    We add a \c modify-argument tag for the first of our two existing function modifications for the \c perform 
    function.
    
    \code
    <modify-argument index="3">
        <remove-argument />
    </modify-argument>
    \endcode
    
    As with modifying the type of an argument, we need to provide the generator with rules for how to convert
    the length argument between Java and C++. Since the argument has been removed in the Java API,
    the conversion rule for passing it into Java will be left empty. 
    
    \code
    <conversion-rule>
        // intentionally empty
    </conversion-rule>
    \endcode
    
    In the conversion rule for passing the length argument into C++ we will unpack the length from the
    Java array.
    
    \code
    <conversion-rule>
        int %out = __jni_env->GetArrayLength((jarray) %2);
    </conversion-rule>                
    \endcode
    
    The \c perform function can now be called and overridden from C++ with its new API.
    
    \section1 Moving ownership from Java to C++
    
    In most cases, we want objects created in Java to be garbage collected when there are no more Java references
    to them. There are, however, a few cases where a C++ function takes ownership of an object, and where 
    the garbage collector can cause objects to disappear or the application to crash.
    
    The way to handle this is to supply the generator with information that a certain function changes the ownership
    rules of an object. We will use the \c disable-gc tag for this.
    
    The functions we need to worry about in our library are \c setEgoObject and \c addGameObject in \c GameScene
    as well as \c setAnimation in \c GameObject. We enter the following code into the \c GameScene type specification.
    
    \code
    <modify-function signature="setEgoObject(AbstractGameObject *)">
        <modify-argument index="1">
            <disable-gc />
        </modify-argument>
    </modify-function>    
    \endcode
        
    This argument modifications specifies that any object passed into \c setEgoObject will be owned by C++ from
    that point on. The garbage collector will no longer touch it. We do the same for the other two functions.
    
    In addition, the function \c clone() in \c GameAction takes ownership of the returned object when it is called
    from C++ and reimplemented in Java. We write a function modification which disables garbage collection for 
    the return value in the virtual call to the \c clone().
    
    \code
    <object-type name="GameAction" polymorphic-base="yes">
        <modify-function class="shell" signature="clone() const">
            <modify-argument index="return">
                <disable-gc />
            </modify-argument>
        </modify-function>
    </object-type>
    \endcode
    
    \section1 Polymorphic types that are not \c QObjects
    
    In certain cases, objects will be created in C++ and passed in to Java. If the classes of such objects are
    polymorphic, we need to be able to identify their correct subclass in order to provide the Java code with
    an object of the correct class (so that \c instanceof and similar instructions work as expected.) 
    
    If \c QObject is a superclass of the objects, we can use its inherent introspection mechanism to find the
    subclass in question (provided that the classes are defined using the \c Q_OBJECT macro.)
    
    In cases where this is not true, however, we need to provide the generator with information about how it may
    identify the class of an arbitrary object.
    
    In our library, one such case is the hierarchy of \c GameAction. There are three subclasses to this: \c LookAction,
    \c PickUpAction and \c UseAction. The actual type of a \c GameAction object can be found using \c type()
    function in \c GameAction.
    
    The first step to handle such a hierarchy is to identify the top-most superclass in the hierarchy. In our case,
    this is \c GameAction. We will declare this to be a "polymorphic base" in the type system specification.
    
    \code
    <object-type name="GameAction" polymorphic-base="yes" />
    \endcode
    
    If we run the generator on our project now, we will see some warnings about classes that inherit \c GameAction
    but do not have a polymorphic id set. The polymorphic id is the C++ expression that identifies an
    object as being of a specific class. We will give the classes \c LookAction, \c PickUpAction and \c UseAction
    such polymorphic ids. We will be warned about \c GameAction as well, but since this is an abstract class
    and cannot be instantiated, we do not need to worry about it.
    
    \code
    <object-type name="LookAction" polymorphic-id-expression="%1->type() == Game::Look"/>
    <object-type name="PickUpAction" polymorphic-id-expression="%1->type() == Game::PickUp"/>    
    <object-type name="UseAction" polymorphic-id-expression="%1->type() == Game::Use"/>
    \endcode
            
    The %1 token will be replaced by object we are inspecting. If we run the generator again now, the warnings will be gone, 
    and the types will now be properly converted into Java.        
            
    \section1 Finished
    
    We are now done exposing our C++ API to Java. Running the Qt Jambi Demo Launcher, we should see the Generator
    Example in its list. 
*/