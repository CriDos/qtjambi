/*!
    \page qtjambi-using-qt-documentation.html

    \title Using Qt's Documentation
    \subtitle for Qt Jambi Development

    The \QJ technology integrates the C++ based Qt library with the
    Java language. The purpose of this document is to point out the
    conceptual language differences that must be considered when using
    the C++ based Qt documentation for \QJ development.

    \tableofcontents

    \section1 Type Mapping

    Java has a simpler type system compared to C++, with only
    primitives and objects. Primitives are passed by value and objects
    are passed by reference.

    Most of Qt's classes can be described either as value types or as
    object types. Value types behave like Java's built-in types: they
    can be created on the stack and passed to functions by value or by
    constant reference (\c {const &}). Object types behave like Java's
    class constructs: they must be instantiated using the \c new
    operator and are passed to functions by pointers.

    In \QJ, most of the C++ based Qt API is mapped directly onto the
    Java equivalent API using the following conventions: Object
    types are passed by pointer, value types are passed by value or
    as constant references (\c {const &}), while C++ primitives are
    simply mapped to Java primitives.

    \section2 Overlapping Types

    There is some overlap between Qt's C++ classes and fundamental
    Java classes. \QJ maps the overlapping Qt classes to the
    corresponding Java classes.

    The following Qt C++ types are mapped from Qt to Java:

    \table
    \header
    \o Qt \o Java
    \row
    \o QChar \o char and java.lang.Character
    \row
    \o QString \o java.lang.String
    \row
    \o QThread \o java.lang.Thread
    \row
    \o QList \o java.util.List
    \row
    \o QVector \o java.util.List
    \row
    \o QHash \o java.util.HashMap
    \row
    \o QMap \o java.util.SortedMap
    \endtable

    \section2 Pointers and References

    The C++ concepts of pointers and non-const references as well as
    pointers to pointers, do not have direct Java equivalents and must
    be mapped explicitly. Since there is no way of knowing the type of
    the data pointed to, \QJ introduces the \c QNativePointer class to
    resolve the mapping. For example, the \QJ equivalent of:

    \code
        QApplication::QApplication ( int & argc, char ** argv )
    \endcode

    from the C++ based Qt library is

    \code
        QApplication ( QNativePointer argc, QNativePointer argv )
    \endcode

    \c QNativePointer encapsulates the pointers, allowing all
    kinds of access to the objects pointed to.

    \c QNativePointer's API perform type checks to prohibit incorrect
    access (e.g., accessing a byte as an \c int or \c char** as a \c
    void*), but in addition \QJ provides convenience functions such as

    \code
        QApplication(String args[])
    \endcode

    allowing the programmer to use the conventional Java approach.

    Note: When you see commonly used functions that take \c
    QNativePointer arguments, feel free to \l {}{let us know} so we
    can improve the API by adding a corresponding convenience
    function.

    \section2 Enums

    Both in Java and C++, enums aim to provide type-safe constant
    values, but the implementations use different techniques: While
    enums in C++ are integers, enums in Java are objects (and Java
    enums with default values are implemented as special enum
    subclasses with limited usage).

    Since enums in Qt are used both as enums and bitmasks, the Java
    enum class construction is too limited to be used in \QJ. For this
    reason, \QJ maps Qt's enums to integers instead.

    \section2 Variants

    In addition to concrete value types like QRect and QPoint, the
    C++ based Qt API also provides an abstract value type, QVariant,
    that can hold values of many C++ and Qt types.

    The \QJ API uses the abstract \c Object value type where Qt uses
    QVariant. This works because all Java classes inherit \c Object.
    Extra features provided by QVariant are mapped to static methods
    in \c com.trolltech.qt.QVariant.

    \section2 Member Variable Access

    The C++ based Qt API is primarily based on methods, but there are
    some classes that give direct access to the member variables of an
    object; e.g., QStyleOption. Since JNI only provides access to
    native resources through methods, each of these member variables
    is implemented as a set and get method pair. For example, the C++
    member variable

    \code
        QString text;
    \endcode

    is implemented as

    \code
        String get_text();
        void set_text(String text);
    \endcode

    in \QJ.

    \section1 Memory Management

    Much of the work being invested into traditional C++ development
    is related to memory management. Java provides a garbage collector
    which automatically detects dynamically allocated objects that are
    no longer accessible and reclaims the memory. \QJ uses the Java
    Native Interface (JNI) to communicate between the C++ based Qt API
    and Java. JNI is supported by most Java virtual machines, and is a
    standard programming interface for writing Java native methods and
    embedding the Java virtual machine into native applications.

    \section2 Releasing Native Resources

    Using JNI and a traditional approach to bind C++ to Java, all
    native resources must be released manually by calling the \c
    dispose() method.

    In \QJ, value types are memory managed like normal Java objects;
    they are deleted by the garbage collector when there are no more
    references to the objects. Note that when value types are passed
    to the C++ side, a copy is made to prevent double deletion.

    Object types are handled differently depending on whether they
    inherit QObject or not. Object types that \e don't inherit QObject
    are garbage collected unless the garbage collector has been
    disabled (see \l {Ownership and Garbage Collection} for details).

    QObject subclasses, on the other hand, normally have a lifetime
    beyond what is visible to the garbage collector. To ensure that
    such a object is deleted, you must either assign the object to a
    parent (child widgets are automatically disposed of by their
    parents upon destruction) or call the \c dispose() function
    explicitly. Typically, most widgets are children of the widgets
    within which they reside, making it only necessary to manually
    dispose the top-level window.

    Note that some QObject subclasses are garbage collected because it
    fits with their typical usage. The currently memory managed object
    types are:

    \list
    \o QApplication
    \o QCoreApplication
    \o QFile
    \o QTemporaryFile
    \endlist


    \section2 Ownership and Garbage collection

    When an object is passed to a C++ based function that takes
    ownership of the object, e.g., after calling \l
    {QApplication::postEvent()}{QApplication.postEvent()}, the event
    object will only be reachable from the C++ side. In general, it is
    required to call the \c QtObject.disableGarbageCollection()
    function to prevent the garbage collector from trying to delete
    such objects.

    As the development of \QJ proceeds, the API will be improved by
    making these function calls redundant. For example, the
    QApplication::postEvent() function is a known case, i.e., calling
    this function implicitly disables the garbage collector and there
    is no need to call the \c QtObject.disableGarbageCollection()
    function explicitly. The table below lists the currently known
    functions:

    \table
    \header
    \o Function Name \o Comment

    \row
    \o \l {QAbstractFileEngine::create()}{QAbstractFileEngine.create()}
    \o If an overridden version of this function is called from the
    C++ code, the returned object will be owned by the C++ side.

    \row
    \o \l {QCoreApplication::postEvent()}{QCoreApplication.postEvent()}
    \o The C++ side takes ownership of the passed QEvent object.

    \row
    \o \l {QTreeWidget::addTopLevelItem()}{QTreeWidget.addTopLevelItem()}
    \o The C++ side takes ownership of the passed QTreeWidgetItem object.

    \row
    \o \l {QTreeWidget::addTopLevelItems()}{QTreeWidget.addTopLevelItems()}
    \o The C++ side takes ownership of the QTreeWidgetItem objects
    passed as arguments.

    \row
    \o \l {QTreeWidget::insertTopLevelItem()}{QTreeWidget.insertTopLevelItem()}
    \o The C++ side takes ownership of the passed  QTreeWidgetItem object.

    \row
    \o \l {QTreeWidget::insertTopLevelItems()}{QTreeWidget.insertTopLevelItems()}
    \o The C++ side takes ownership of the QTreeWidgetItem objects
    passed as arguments.

    \row
    \o \l {QTreeWidget::setHeaderItem()}{QTreeWidget.setHeaderItem()}
    \o The C++ side takes ownership of the passed QTreeWidgetItem object.

    \row
    \o \l {QListWidget::addItem()}{QListWidget.addItem()}
    \o The C++ side takes ownership of the passed QListWidgetItem object.

    \row
    \o \l {QListWidget::insertItem()}{QListWidget.insertItem()}
    \o The C++ side takes ownership of the passed QListWidgetItem object.

    \row
    \o \l {QTableWidget::setHorizontalHeaderItem()}{QTableWidget.setHorizontalHeaderItem()}
    \o The C++ side takes ownership of the passed QTableWidgetItem object.

    \row
    \o \l {QTableWidget::setVerticalHeaderItem()}{QTableWidget.setVerticalHeaderItem()}
    \o The C++ side takes ownership of the passed QTableWidgetItem object.

    \row
    \o \l {QTableWidget::setItemPrototype()}{QTableWidget.setItemPrototype()}
    \o The C++ side takes ownership of the passed QTableWidgetItem object.

    \row
    \o \l {QTableWidget::setItem()}{QTableWidget.setItem()}
    \o The C++ side takes ownership of the passed QTableWidgetItem object.

    \row
    \o \l {QTableWidgetItem::QTableWidgetItem()}{QTableWidgetItem.QTableWidgetItem()}
    \o When calling the constructor that accepts a parent, the parent
    gets ownership of the newly constructed object.

    \row
    \o \l {QListWidgetItem::QListWidgetItem()}{QListWidgetItem.QListWidgetItem()}
    \o When calling the constructor that accepts a parent, the parent
    gets ownership of the newly constructed object.

    \row
    \o \l {QTreeWidgetItem::QTreeWidgetItem()}{QTreeWidgetItem.QTreeWidgetItem()}
    \o When calling the constructor that accepts a parent, the parent
    gets ownership of the newly constructed object.

    \row
    \o \l {QTableWidgetItem::clone()}{QTableWidgetItem.clone()}
    \o If an overridden version of this function is called from the C++
    code, the returned object will be owned by the C++ side.

    \row
    \o \l {QListWidgetItem::clone()}{QListWidgetItem.clone()}
    \o If an overridden version of this function is called from the C++
    code, the returned object will be owned by the C++ side.

    \row
    \o \l {QTreeWidgetItem::clone()}{QTreeWidgetItem.clone()}
    \o If an overridden version of this function is called from the C++
    code, the returned object will be owned by the C++ side.

    \row
    \o \l {QTreeWidgetItem::addChild()}{QTreeWidgetItem.addChild()}
    \o The C++ side takes ownership of the passed QTreeWidgetItem object.

    \row
    \o \l {QTreeWidgetItem::addChildren()}{QTreeWidgetItem.addChildren()}
    \o The C++ side takes ownership of the QTreeWidgetItem objects
    passed as arguments.

    \endtable

    \warning The \c QtObject.disableGarbageCollection() function
    should only be used for functions that take ownership of the
    objects passed as arguments; otherwise the application will leak
    memory.

    \section2 Implicit Sharing and Detaching

    Many C++ classes in Qt use \l {Implicit Data Sharing}{implicit
    data sharing} to maximize resource usage and minimize copying of
    data. A shared class consists of a pointer to a shared data block
    that contains a reference count and the data; implicit sharing
    automatically detaches the object from a shared block if the
    object is about to change and the reference count is greater than
    one. (This is often called "copy-on-write" or "value semantics".)

    Implicit sharing takes place behind the scenes; normally the
    programmer does not need to worry about it. But when using Qt
    Jambi it might be useful to note that value types will behave
    slightly different when passed to a normal Java function as
    opposed to a C++ function (via the native interface). For example,
    in Java one might expect:

    \code
        QPen pen = new QPen(QColor.black, 10);
        painter.setPen(pen);
        pen.setWidth(1);
    \endcode

    to change the pen width from 10 to 1 for the painter's pen. In
    \QJ, this is not the case as the pen is passed to the \l
    {QPainter::setPen()}{setPen()} function by value on the C++ side
    (generating a separate copy). For this reason, calling \c
    pen.setWidth(1) will only change the pen width of the local pen on
    the Java side.

    If the pen is passed to another Java function the behavior is
    different:

    \code
        class Shape {
            QPen pen;
            void setPen(QPen pen) { this.pen = pen; }
        }
        ...
        pen = new QPen(QColor.black, 10);
        shape.setPen(pen);
        pen.setWidth(1);
    \endcode

    In this case, the pen is passed as a Java reference; i.e., the
    shape's pen is the same object as the local pen.

    \section1 Operator Overloading

    Many of the C++ based Qt classes make use of operator overloading,
    a C++ language feature that is not available in Java. For this
    reason, all operators in the C++ based Qt Library are converted to
    normal functions in \QJ. These functions are given an \c operator_
    prefix to help identify them and to avoid name clashes with
    existing functions. The operators are named according to the
    naming conventions described in "The C++ Programming Language" by
    Bjarne Stroustrup:

    \table
    \header
    \o \QC Operator \o \QJ Function Name
    \row
        \o +
        \o operator_add
    \row
        \o -
        \o operator_subtract
    \row
        \o *
        \o operator_multiply
    \row
        \o /
        \o operator_divide
    \row
        \o %
        \o operator_modulo
    \row
        \o &
        \o operator_and
    \row
        \o |
        \o operator_or
    \row
        \o ^
        \o operator_xor
    \row
        \o ~
        \o operator_negate
    \row
        \o <<
        \o operator_shift_left
    \row
        \o >>
        \o operator_shift_right
    \row
        \o =
        \o operator_assign
    \row
        \o +=
        \o operator_add_assign
    \row
        \o -=
        \o operator_subtract_assign
    \row
        \o *=
        \o operator_multiply_assign
    \row
        \o /=
        \o operator_divide_assign
    \row
        \o %=
        \o operator_modulo_assign
    \row
        \o &=
        \o operator_and_assign
    \row
        \o |=
        \o operator_or_assign
    \row
        \o ^=
        \o operator_xor_assign
    \row
        \o <<=
        \o operator_shift_left_assign
    \row
        \o >>=
        \o operator_shift_right_assign
    \row
        \o &&
        \o operator_logical_and
    \row
        \o ||
        \o operator_logical_or
    \row
        \o !
        \o operator_not
    \row
        \o ++
        \o operator_increment
    \row
        \o --
        \o operator_decrement
    \row
        \o <
        \o operator_less
    \row
        \o >
        \o operator_greater
    \row
        \o <=
        \o operator_less_or_equal
    \row
        \o >=
        \o operator_greater_or_equal
    \row
        \o !=
        \o operator_not_equal
    \row
        \o ==
        \o operator_equal
    \row
        \o []
        \o operator_subscript
    \row
        \o ->
        \o operator_pointer
    \row
        \o cast
        \o operator_cast_[ClassName]
    \endtable

    \sa {The Qt Jambi Generator}, {Object Types in Qt Jambi}, {Value
    Types in Qt Jambi}

*/

/*!
    \page qtjambi-value-types.html
    \title Value Types in Qt Jambi

    \QJ's concept of value types is similar to Java's built-in types.
    Value types can be created on the stack (without using the \c new
    operator) and passed to functions by value or by constant
    reference (\c {const &}).

    In \QJ these types are memory managed like normal Java objects;
    they are deleted by the garbage collector when there are no more
    references to the objects. Note that when value types are passed
    to the C++ side, a copy is made to prevent double deletion.

    \table 100%
    \row
    \o

    \list
    \o QAbstractTextDocumentLayout::PaintContext
    \o QBasicTimer
    \o QBitArray
    \o QBitmap
    \o QBrush
    \o QByteArray
    \o QByteArrayMatcher
    \o QColor
    \o QColormap
    \o QConicalGradient
    \o QCursor
    \o QDate
    \o QDateTime
    \o QDir
    \o QFileInfo
    \o QFont
    \o QFontDatabase
    \o QFontInfo
    \o QFontMetrics
    \o QFontMetricsF
    \o QGradient
    \o QIcon
    \o QImage
    \o QImageTextKeyLang
    \o QInputMethodEvent::Attribute
    \o QItemSelection
    \o QItemSelectionRange
    \o QKeySequence
    \o QLine
    \o QLineF
    \o QLinearGradient
    \o QLocale
    \o QMatrix
    \o QMetaEnum
    \o QModelIndex
    \endlist

    \o
    \list
    \o QPainterPath
    \o QPainterPath::Element
    \o QPalette
    \o QPen
    \o QPersistentModelIndex
    \o QPicture
    \o QPixmap
    \o QPoint
    \o QPointF
    \o QPolygon
    \o QPolygonF
    \o QRadialGradient
    \o QRect
    \o QRectF
    \o QRegExp
    \o QRegion
    \o QSize
    \o QSizeF
    \o QSizePolicy
    \o QStringMatcher
    \o QStyleOption
    \o QStyleOptionButton
    \o QStyleOptionComboBox
    \o QStyleOptionComplex
    \o QStyleOptionDockWidget
    \o QStyleOptionFocusRect
    \o QStyleOptionFrame
    \o QStyleOptionFrameV2
    \o QStyleOptionGroupBox
    \o QStyleOptionHeader
    \o QStyleOptionMenuItem
    \o QStyleOptionProgressBar
    \o QStyleOptionProgressBarV2
    \o QStyleOptionRubberBand
    \o QStyleOptionSlider
    \endlist

    \o
    \list
    \o QStyleOptionSpinBox
    \o QStyleOptionTab
    \o QStyleOptionTabBarBase
    \o QStyleOptionTabV2
    \o QStyleOptionTabWidgetFrame
    \o QStyleOptionTitleBar
    \o QStyleOptionToolBar
    \o QStyleOptionToolBox
    \o QStyleOptionToolButton
    \o QStyleOptionViewItem
    \o QTableWidgetSelectionRange
    \o QTextBlock
    \o QTextBlock::iterator
    \o QTextBlockFormat
    \o QTextCharFormat
    \o QTextCursor
    \o QTextDocumentFragment
    \o QTextFormat
    \o QTextFragment
    \o QTextFrame::iterator
    \o QTextFrameFormat
    \o QTextImageFormat
    \o QTextInlineObject
    \o QTextLayout::FormatRange
    \o QTextLength
    \o QTextLine
    \o QTextListFormat
    \o QTextOption
    \o QTextTableCell
    \o QTextTableFormat
    \o QTime
    \o QTreeWidgetItemIterator
    \o QUrl
    \o QUuid
    \endlist
    \endtable

    \sa {Object Types in Qt Jambi}, {Using Qt's Documentation}{Using
    Qt's Documentation (for \QJ Development)}
*/

/*!
    \page qtjambi-object-types.html
    \title Object Types in Qt Jambi

    \QJ's concept of object types is similar to Java's class
    constructs. Object types must be instantiated using the \c new
    operator and are passed to functions by pointers.

    In \QJ, object types that inherit QObject normally have a lifetime
    beyond what is visible to the garbage collector. To ensure that
    such a object is deleted, either assign the object to a parent or
    call the dispose() function. Object types that don't inherit
    QObject, on the other hand, are garbage collected unless the
    garbage collector has been disabled (see Ownership and Garbage
    Collection for details).


    Note that some QObject subclasses are garbage collected because it
    fits with their typical usage. The currently memory managed object
    types are QApplication, QCoreApplication, QFile and
    QTemporaryFile.


    \table 100%
    \row
    \o
    \list
    \o QAbstractButton
    \o QAbstractEventDispatcher
    \o QAbstractFileEngine
    \o QAbstractFileEngineHandler
    \o QAbstractItemDelegate
    \o QAbstractItemModel
    \o QAbstractItemView
    \o QAbstractListModel
    \o QAbstractPageSetupDialog
    \o QAbstractPrintDialog
    \o QAbstractProxyModel
    \o QAbstractScrollArea
    \o QAbstractSlider
    \o QAbstractSpinBox
    \o QAbstractTableModel
    \o QAbstractTextDocumentLayout
    \o QAbstractUndoItem
    \o QAccessible
    \o QAccessibleApplication
    \o QAccessibleBridge
    \o QAccessibleBridgeFactoryInterface
    \o QAccessibleBridgePlugin
    \o QAccessibleEvent
    \o QAccessibleFactoryInterface
    \o QAccessibleInterface
    \o QAccessibleObject
    \o QAccessiblePlugin
    \o QAccessibleWidget
    \o QAction
    \o QActionEvent
    \o QActionGroup
    \o QBoxLayout
    \o QBuffer
    \o QButtonGroup
    \o QCDEStyle
    \o QCheckBox
    \o QChildEvent
    \o QClipboard
    \o QClipboardEvent
    \o QCloseEvent
    \o QColorDialog
    \o QComboBox
    \o QCommonStyle
    \o QContextMenuEvent
    \o QCoreApplication
    \o QDateEdit
    \o QDateTimeEdit
    \o QDesktopWidget
    \o QDial
    \o QDialog
    \o QDirModel
    \o QDockWidget
    \o QDoubleSpinBox
    \o QDoubleValidator
    \o QDrag
    \o QDragEnterEvent
    \o QDragLeaveEvent
    \o QDragMoveEvent
    \o QDragResponseEvent
    \o QDropEvent
    \o QErrorMessage
    \o QEvent
    \o QEventLoop
    \o QFSFileEngine
    \o QFileDialog
    \o QFileIconProvider
    \o QFileOpenEvent
    \o QFocusEvent
    \o QFocusFrame
    \o QFontDialog
    \o QFrame
    \o QGridLayout
    \o QGroupBox
    \o QHBoxLayout
    \o QHeaderView
    \o QHelpEvent
    \o QHideEvent
    \endlist

    \o
    \list

    \o QHoverEvent
    \o QIODevice
    \o QIconDragEvent
    \o QIconEngine
    \o QIconEngineFactoryInterface
    \o QIconEnginePlugin
    \o QImageIOHandler
    \o QImageIOHandlerFactoryInterface
    \o QImageIOPlugin
    \o QImageReader
    \o QImageWriter
    \o QInputContext
    \o QInputContextFactory
    \o QInputContextFactoryInterface
    \o QInputContextPlugin
    \o QInputDialog
    \o QInputEvent
    \o QInputMethodEvent
    \o QIntValidator
    \o QItemDelegate
    \o QItemEditorCreatorBase
    \o QItemEditorFactory
    \o QItemSelectionModel
    \o QKeyEvent
    \o QLCDNumber
    \o QLabel
    \o QLayout
    \o QLibraryInfo
    \o QLineEdit
    \o QListView
    \o QListWidget
    \o QListWidgetItem
    \o QMainWindow
    \o QMenu
    \o QMenuBar
    \o QMessageBox
    \o QMetaClassInfo
    \o QMetaMethod
    \o QMetaProperty
    \o QMetaType
    \o QMimeData
    \o QMotifStyle
    \o QMouseEvent
    \o QMoveEvent
    \o QMovie
    \o QMutex
    \o QObject
    \o QPageSetupDialog
    \o QPaintEngine
    \o QPaintEngineState
    \o QPaintEvent
    \o QPainter
    \o QPainterPathPrivate
    \o QPainterPathStroker
    \o QPictureFormatInterface
    \o QPictureFormatPlugin
    \o QPictureIO
    \o QPixmapCache
    \o QPlastiqueStyle
    \o QPrintDialog
    \o QPrintEngine
    \o QProcess
    \o QProgressBar
    \o QProgressDialog
    \o QProxyModel
    \o QPushButton
    \o QRadioButton
    \o QReadWriteLock
    \o QRegExpValidator
    \o QResizeEvent
    \o QRubberBand
    \o QScrollArea
    \o QScrollBar
    \o QSemaphore
    \o QSessionManager
    \o QSettings
    \o QShortcut

    \endlist

    \o
    \list

    \o QShortcutEvent
    \o QShowEvent
    \o QSignalMapper
    \o QSizeGrip
    \o QSlider
    \o QSocketNotifier
    \o QSortFilterProxyModel
    \o QSound
    \o QSpacerItem
    \o QSpinBox
    \o QSplashScreen
    \o QSplitter
    \o QSplitterHandle
    \o QStackedLayout
    \o QStackedWidget
    \o QStandardItemModel
    \o QStatusBar
    \o QStatusTipEvent
    \o QStringListModel
    \o QStyle
    \o QStyleFactory
    \o QStyleFactoryInterface
    \o QStyleHintReturn
    \o QStyleHintReturnMask
    \o QStylePainter
    \o QStylePlugin
    \o QSyntaxHighlighter
    \o QTabBar
    \o QTabWidget
    \o QTableView
    \o QTableWidget
    \o QTableWidgetItem
    \o QTabletEvent
    \o QTextBlockGroup
    \o QTextBlockUserData
    \o QTextBrowser
    \o QTextCodec
    \o QTextCodec::ConverterState
    \o QTextCodecFactoryInterface
    \o QTextCodecPlugin
    \o QTextDecoder
    \o QTextDocument
    \o QTextEdit
    \o QTextEncoder
    \o QTextFrame
    \o QTextItem
    \o QTextLayout
    \o QTextList
    \o QTextObject
    \o QTextObjectInterface
    \o QTextStreamManipulator
    \o QTextTable
    \o QTimeEdit
    \o QTimer
    \o QTimerEvent
    \o QToolBar
    \o QToolBarChangeEvent
    \o QToolBox
    \o QToolButton
    \o QToolTip
    \o QTranslator
    \o QTreeView
    \o QTreeWidget
    \o QTreeWidgetItem
    \o QVBoxLayout
    \o QValidator
    \o QWaitCondition
    \o QWhatsThis
    \o QWhatsThisClickedEvent
    \o QWheelEvent
    \o QWidget
    \o QWidgetItem
    \o QWindowStateChangeEvent
    \o QWindowsStyle
    \o QWorkspace

    \endlist
    \endtable

    \sa {Value Types in Qt Jambi}, {Using Qt's Documentation}{Using
    Qt's Documentation (for Qt Jambi Development)}
*/

