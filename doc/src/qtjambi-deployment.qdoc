/*!
    \page qtjambi-deployment.html

    \title Deploying Qt Jambi Applications

    Java provides a number of different features which makes it easier
    to deploy applications, such as the Web Start technology, Java
    Archives (\c .jar files) and, of course, the virtual machine that
    enables you to compile your application to bytecode once and run
    on all architectures.

    The apparent challenge when deploying \QJ applications is that \QJ
    makes use of Qt's C++ libraries which means that platform
    dependent code must be distributed in addition to the platform
    independent bytecode. \QJ provides a solution - all you have to do
    is to include the native libraries in a JAR bundle.

    To include resources, the programmer must follow a particular
    syntax since \QJ provides its own resource system. But note that
    this system makes it easy to access any kind of resource (e.g.,
    pixmaps, translation files and xml data files), no matter whether
    they are located, directly on the disk or in a JAR bundle.

    We will first take a look at which building blocks make up a \QJ
    application. Then we will look at three common deployment
    scenarios, pure Qt Jambi applications, Qt Jambi applications
    making use of custom generated code and finally C++ applications
    making use of Qt Jambi. Where applicable, we'll also take a look
    at how one can bundle the application into a webstart application
    and/or a single executable .jar file.

    \tableofcontents


    \section1 Composition of a Deployment Package

    A Qt Jambi application will contain a set of application class
    files, the Qt Jambi library class files and a collection of native
    libraries. In addition to these, it may contain resources such as
    images, translation files and data. It may also include some of
    the Qt C++ plugins to add support for additional image formats or
    accessibility etc. As the application class files are handled by
    the user, we won't go into details on these here.

    The details covered in this section are primarly informational and
    a lot is handled automatically by Qt Jambi. When deploying a Java
    application making use of Qt Jambi and no other native libraries,
    all of this can be ignored. See the "Deploying a Pure Qt Jambi
    Application" section.

    \section2 Class Files

    The Qt Jambi class files are located in the library classed \c
    qtjambi.jar which is available in the root of the binary package
    and also in the root of a source package after the \c ant script
    has completed. The \c qtjambi.jar file also contains some
    resources that may be needed by some classes so it should be used
    as-is.

    \section2 Native Libraries    

    In a prebuilt Qt Jambi package there are a number of different
    native libraries, located in certain subdirectories of the root
    directory. In the library directory, which is \c bin under Windows
    and \c lib under Linux and Mac OS X, one can find Qt libraries, Qt
    Jambi libraries and runtime libraries. The Qt C++ plugins can be
    found in the subdirectories of the \c JAMBIDIR/plugins directory
    in the prebuilt package.

    \section3 Qt Jambi libraries

    Qt Jambi libraries are the libraries that implement the \c native
    part of Java functions and are usually named according to the
    package they implement, such as \c com_trolltech_qt_gui for the
    native implementation of the \c com.trolltech.qt.gui package. Qt
    Jambi libraries are explicitly loaded by Qt Jambi using called to
    \c System.load() or similar. These packages are named as
    following:

    \table
	\header \o Platform	\o Prefix	\o Suffix	\o Example
	\row    \o Windows  	\o \i none 	\o .dll   	\o qtjambi.dll
	\row	\o Linux	\o lib		\o .so		\o libqtjambi.so
	\row 	\o Mac OS X	\o lib		\o .jnilib	\o libqtjambi.jnilib
    \endtable

    \section3 Qt Libraries
          		
    While the Qt Jambi libraries implement the native part of the Java
    functions, they merly translate the Java function calls into C++
    function calls and calls into the Qt libraries. This means that
    the Qt Jambi libraries link against the Qt libraries and are
    dependent of them. For a process to be able to load a given
    library, it must be able to locate and load all its
    dependencies. Qt Jambi explicitly loads the dependent Qt libraries
    of a Qt Jambi library directly before trying to load a Qt
    library. This makes sure that the process has the library loaded
    and dependecies are resolved.

    \table
	\header \o Platform	\o Prefix	\o Suffix	\o Example
	\row    \o Windows  	\o \i none 	\o .dll   	\o QtCore4.dll
	\row	\o Linux	\o lib		\o .so.4	\o libQtCore.so.4
	\row 	\o Mac OS X	\o lib		\o .4.dylib	\o libQtCore.4.dylib
    \endtable

    \section3 Runtime Libraries

    The Qt libraries also have dependencies on runtime libraries. For
    instance, if Qt Jambi was compiled with GCC 3.3, it would depend
    on the \c libstdc++.so.5, which is not always present on newer
    linux distributions. To be able to run on newer linux
    distributions this runtime library needs to be available and
    loaded/available prior to loading the Qt libraries. Qt Jambi calls
    these libraries "system libraries" and will load them based on a
    platform specific deployment specification. The specific runtimes
    depend on the C++ compiler used to build Qt and the operating
    system.

    \table 75%
        \header \o Compiler		\o Runtime Libraries
        \row 	\o MSVC 6.0		\o msvcr60.dll, msvcp60.dll
        \row 	\o MSVC 2002		\o msvcr70.dll, msvcp70.dll
	\row  	\o MSVC 2003 		\o msvcr71.dll, msvcp71.dll
	\row 	\o MinGW		\o mingwm10.dll
	\row 	\o GCC 3.3 and older	\o libstdc++.so.5
	\row 	\o GCC 3.4 and newer	\o libstdc++.so.6
	\row 	\o GCC on Mac OS X	\o no dependencies
        \row  	\o MSVC 2005 and 2008   \o 

    Microsoft Visual Studio 2005 and 2008 introduces manifest files as
    a way of describing dependencies between dll's. This restricts the
    way binaries can be deployed. Manifest based runtime libraries
    will in this case need to be available for Qt Jambi to load. These
    files are not available by default on Windows Vista, Windows XP
    nor Windows 2000. This is solved by either:

      \list

      \o Installing manifest based runtimes on the target system using
         Microsoft's Visual Studio Redistributable Package. At the
         time of writing this is possible using the application
         "vcredist_x86.exe", which is provided on the
         \c{microsoft.com} websites.

      \o Redistribute the runtime libraries provided in the Qt Jambi
         package or in your own Visual Studio version along with their
         manifest next to every .dll. The redistributables can be
         placed either directly next to the Qt Jambi .dll's or in a
         subdirectory called Microsoft.VC80.CRT for MSVC 2005 and
         Microsoft.VC90.CRT for MSVC 2008. For projects with .dll's in
         multiple folders, such as the Qt Jambi plugins in the plugin
         sub directory, the files need to be duplicated in all
         places. Note: Since Qt treats all .dll files in a plugin
         folder as a plugin it will try to load the the runtime
         libraries as plugins. To prevent this, it is recommended that
         the redistributable runtime libraries are placed in a sub
         directory under each plugin. 
       
       \endlist

    \endtable

    To get a full overview of the dependencies of a library there are
    some tools available.

    \table 
    	   \header	\o Platform	\o Tools
	   \row		\o Windows	\o \c depends.exe, GUI tool part of MSVC
	   \row		\o Windows	\o \c {dumpbin /dependents}, command line tool part of MSVC
	   \row 	\o Linux 	\o \c ldd, command line tool, part of GCC
	   \row 	\o Mac OS X	\o \c otool -L, standard tool
    \endtable

    \section3 Plugins

    Finally there are the Qt C++ plugins, which are loaded by Qt at
    runtime to support some features, such as loading / saving of jpeg
    images. By default, Qt will locate the plugin libraries where the
    C++ library was built, which is convenient for Qt C++ developers
    but less relevant for Qt Jambi developers or for deployment. It is
    possible to extend the default search location by adding
    directories to the environment variable \c QT_PLUGIN_PATH or by
    making a call to \c QApplication.addLibraryPath() in the Java
    code. Both will add searchpaths for Qt to look for plugins.


    \section1 Deployment Scenarios

    In this section we'll look more closely at the three primary
    deployment scenarios that we picture for Qt Jambi. The first and
    easiest one is to deploy a pure Qt Jambi Application, not relying
    on any other native libraries than the Qt Jambi ones. Then we look
    at the scenario where a user has used the Qt Jambi generator to
    map his own libraries and deploys an application of native
    libraries from both Qt Jambi his own generated project. Finally
    we'll look at how it is possible to deploy a C++ application that
    makes use of Qt Jambi, like our own tool Qt Designer does.

    Since 4.4, Qt Jambi provide two ways of loading libraries. The
    first and recommended one is via \c .jar file using a deployment
    specification. A deployment specification contains a list of all
    libraries to be loaded, directories they reside in and how Qt
    Jambi should treat them, be it a runtime library, Qt library, JNI
    library or a plugin. The benefit of this approach is that Qt Jambi
    handles custom plugin paths and loading of runtime libraries, etc
    and the user only has to relate to a \c .jar file as with any
    other Java application. A platform specific \c .jar file for your
    platform is available in the Qt Jambi binary package.

    The other alternative for loading native libraries is by relying
    on the traditional method for loading native libraries into Java,
    which is to make sure that libraries are available in a directory
    specified in \c {-Djava.library.path} and simply load them. In
    this case \c QT_PLUGIN_PATH and dependency on runtime libraries
    has to be handled by the user.

    \section2 Deploying a Pure Qt Jambi Application

    This method of deployment should be used when the application
    either makes only use of pure Java code in combination with the Qt
    Jambi libraries. In this scenario the user should make use of the
    binary package for the target platform. The final application
    should then consist of the following three pieces:

    \list
      \o The application classes, for instance called application.jar
      \o The Qt Jambi classes, called qtjambi-$VERSION.jar, available
         in the binary package
      \o The Qt Jambi platform bundle, called
         qtjambi-$PLATFORM-$VERSION.jar available in the binary
         package.
    \endlist

    The only thing needed to deploy this application is to make sure
    the three \c {.jar} files are available in the applications \c
    CLASSPATH and start it. To make an application that can launch on
    multiple platforms, use the binaries from the binary packages of
    Qt Jambi for the target platforms that you would like to support
    and make sure the right platform \c {.jar} file is available in the
    classpath when you launch the application.

    \section3 Creating a Webstart Application

    To create a webstart application based on Qt Jambi, specify the
    application \c {.jar} file along with the \c
    {qtjambi-$VERSION.jar} file as normal resources.

   \code
     <resources>
       <j2se version="1.5+"/>
       <jar href="application.jar"/>
       <jar href="qtjambi-4.4.0_01.jar"/>
     </resources>
   \endcode

   Then, for each target platform to support, add a compatible
   platform bundle. For instance to add support for Windows 32-bit:

   \code
     <resources os="Windows" arch="x86">
       <jar href="qtjambi-win32-msvc2005-4.4.0_01.jar"/>
     </resources>
   \endcode

    \section3 Creating an Executable Java Archive

    To create an executable \c {.jar} file for one platform is
    straightforward, simply unpack the contents of the three \c {.jar}
    files and repack them together as one .jar file with the
    appropriate manifest specifying \c {Main-Class}, etc.

    To create a \c {.jar} file that runs on multiple platforms is only
    possible by creating an executable \c {.jar} file which uses 
    jar \c {.jar} files in the current directory. For instance, deploying \c {application.jar} for windows 32 and linux32 would require the following files:

    \code
    APPDIR\application.jar
    APPDIR\qtjambi-4.4.0_01.jar
    APPDIR\qtjambi-win32-msvc2005-4.4.0_01.jar
    APPDIR\qtjambi-linux32-gcc3.3-4.4.0_01.jar
    \endcode

    Where \c {application.jar} has the \c {Class-Path} attribute in
    its Manifest set to include both the platform specific \c {.jar}
    files, 

    \code
    Class-Path: qtjambi-4.4.0_01.jar qtjambi-win32-msvc2005-4.4.0_01.jar qtjambi-linux32-gcc3.3-4.4.0_01.jar
    \endcode

    As long as the four files are distributed together, the
    application will run on both windows and linux using the command:

    \code
      > java -jar application.jar
    \endcode

    \section3 Creating an Application Bundle using Mac OS X JarBundler
    
    Mac OS X provides a powerful and simple to use tool that lets the
    user build Mac OS X Application Bundles that can be launched using
    Finder. This tool is called \c {Jar Bundler} and is by defualt
    located in \c {/Developer/Applications/Java Tools/Jar
    Bundler}. Using the tool, one can specify the three classes in the
    classpath and specify class with the main method used for launching.

    \section2 Deploying a Qt Jambi Application making use of generated code
      - Qt Jambi application using generated code
        ' build Qt from scratch
 	' build Jambi from scratch
	' build your generated libraries based on these Qt and Qt Jambi's
	' create your own platform .jar for jambi
	' create your own platform .jar for the custom library
 	' create libraries using your own deploy spec
	' Creating a webstart application
	' Creating an executable .jar file.

    \section2 Deploying a Native Application making use of Qt Jambi
      - Application using Qt Jambi, e.g. Qt Designer
        ' build Qt from scratch
	' build Qt Jambi from scratch
	' build your application based on Qt and Jambi
	' make sure libraries are available in -Djava.library.path
	' QT_PLUGIN_PATH for plugins
	' 
    \section2 Troubleshooting    
      - -Dcom.trolltech.qt.verbose-loading
      - binary compatibility...



































    \section1 Resolving Native Libraries

    The Qt Jambi native libraries are located in the \c lib directory
    in the Qt Jambi directory. If you have a prebuilt package, the Qt
    libraries will also be available there. In case you have a source
    package, you will find the necessary Qt libraries in the \c lib
    directory in the Qt directory.

    Qt Jambi searches the classpath for libraries. So to distribute
    the libraries with your application, you can simply include them
    in a JAR bundle, which is then placed in the classpath.

    The Qt and Qt Jambi native libraries may depend on other
    libraries, which must be distributed as well. It is possible to
    specify dependent libraries by listing them in a file called \c
    qt_system_libs, which should be located somewhere in the classpath
    root. One can also specify the libraries on the command line with
    the \c {com.trolltech.qt.systemlibraries} variable, which should
    contain paths to the libraries. The libraries are loaded in the
    order listed in the file or on the command line.

    We present a table with the necessary libraries below:

    \table 75%
        \header \o Platform \o Native Libraries
        \row
            \o MSVC 6.0
            \o msvcp60.dll and msvcr60.dll
        \row
            \o MSVC 2002
            \o msvcr70.dll and msvcp70.dll
        \row
            \o MSVC 2003
            \o msvcr71.dll and msvcp71.dll
        \row
            \o MSVC 2005
            \o
              
    Microsoft Visual Studio 2005 introduces manifest files as a way of
    describing dependencies between dll's. This restricts the way
    binaries can be deployed. Manifest based runtime libraries will in
    this case need to be available for Qt Jambi to load. These files
    are not available by default on Windows Vista, Windows XP nor
    Windows 2000. This is solved by either:

    \list
    \o Installing manifest based runtimes on the target system using
      Microsoft's Visual Studio Redistributable Package. At the time of
      writing this is possible using the application
      "vcredist_x86.exe", which is provided on the \c{microsoft.com}
      websites.

    \o Redistribute the runtime libraries provided in the Qt Jambi
      package or in your own Visual Studio version along with their
      manifest next to every .dll. The redistributables can be placed
      either directly next to the Qt Jambi .dll's or in a subdirectory
      called Microsoft.VC80.CRT. For projects with .dll's in multiple
      folders, such as the Qt Jambi plugins in the plugin sub
      directory, the files need to be duplicated in all places. Note:
      Since Qt treats all .dll files in a plugin folder as a plugin it
      will try to load the the runtime libraries as plugins. To
      prevent this, it is recommended that the redistributable runtime
      libraries are placed in a Micrsoft.VC.CRT sub directory under
      each plugin. \endlist

        See the \l{Creating a .jar file for MSVC 2005} section for an example.
        \row
            \o Open Source Windows Version
            \o mingwm10.dll
        \row
            \o Linux
            \o libstdc++.so. Since there are different versions of
               this library, you need to ship the library that the
               application is linked against. You can check this
               with the \c ldd utility.
        \row
            \o Mac OS X
            \o No libraries are required on Mac OS X.
    \endtable

    There are also tools on each platform for checking library
    dependencies. UNIX systems has the \c ldd utility, Mac OS X
    provides \c oTool. Windows has no standard tool, but a good
    freely available application is the \l
    {http://www.dependencywalker.com/}{Dependency Walker}. MSVC
    includes its own application: \c depends.

    If you still have problems, you can set the
    \c{com.trolltech.qt.verbose-loading} system property, in which
    case Qt Jambi will report which libraries are missing.

    \bold {The Qt Jambi Generator and Custom Libraries}

    \QJ also supports distribution of custom native libraries using
    the same approach as for regular libraries. This makes it possible
    to ship applications based on Java \e and C++, both as executable
    \c .jar files and using the Web Start technology.

    To generate code that maps a C++ library onto an equivalent Java
    API, \QJ provides its own generator. For more information, please
    see the \l {The Qt Jambi Generator}{Qt Jambi generator} documentation.

    \section1 Including Resources

    \QJ provides a complete file system abstraction that allows a
    uniform syntax (based on the Java classpath) for accessing
    resources, whether they are located directly on the disk or in a
    JAR bundle. While the standard Java API only supports accessing
    resources in an undocumented subset of its file I/O operations
    (which does not include the \c java.io.File class), Qt Jambi
    allows resources to be used wherever a file name is expected.
    Resources are identified by a \c classpath: prefix.

    \image accessing-resources.png

    Note that it is also possible to load resources as raw data:

    \code
        QFile file = new QFile("classpath:images/fileopen.png");
        file.open(QIODevice.OpenModeFlag.ReadOnly);
        QByteArray rawData = file.readAll();
    \endcode

    To include resources in your distribution, all you have to do is
    to ensure that the application follows the \QJ syntax for
    accessing resources and make the resources available by adding
    them to your JAR bundle.

    \section1 Including Plugins

    In addition to the Qt native libraries, you need to deploy Qt
    plugins, such as JPEG support and SQL drivers. See the \l{How to
    Create Qt Plugins}{plugins document} for more information about Qt
    plugins.

    The Qt plugins are located in the \c plugins directory in the
    directory where \QJ is installed. They are placed in
    subdirectories according to type, e.g., SQL drivers and image
    formats.

    Plugins are deployed in a \c .jar file following the same
    directory structure as in the Jambi installation directory. When
    running the application, the \c {com.trolltech.qt.pluginjars}
    system property must be set to contain the path to the \c .jar
    file containing the plugins. The plugins do not need to have
    their own file, so it is, for instance, possible to deploy them in
    the same file as your application.

    \section1 Creating an Executable .jar File

    \omit (ant is not officially supported yet)
    There are two approaches for creating a \c .jar file for your
    application. You can create it manually from the command line
    using the \c jar utility including your own manifest and \c
    qt_system_libs files. Qt Jambi also comes with an \c ant
    target for \c jar.

    We recommend the use of \c ant. Still, we do include a separate
    section that explains how to use the \c jar tool directly if you
    prefer that. If you are in doubt of which files you need to
    include in the JAR bundle, please refer to \l {Resolving Native
    Libraries}.
    \endomit

    \omit (This is not publicly available yet)
    \section2 Creating a File With Ant

    (Which I should probably do before I start writing about it,
     eh). Go through xml file.

    \quotefromfile snippets/application.xml
    \skipto /target name/
    \printuntil /\/jar/

    \section2 Creating a File from the Command Line
    \endomit

    To deploy \QJ applications using the executable \c .jar file
    approach is straight forward:

    \code
        jar mcf <manifest file> myApplication.jar <my class files>
                         <my resources> <native libraries> <plugins>
    \endcode

    Simply put all resources, native libraries, plugins ,and
    application \c .class files into one single \c .jar file. Remember
    to add a manifest file to make the file executable and a
    qt_system_libs for the system libraries. Note that all native
    libraries must be placed in the root directory in the file.

    For instance, if you were to create a file for the \l{Application
    Example}, the manifest file will look like this:

    \code
        Main-Class: com.trolltech.examples.Application

    \endcode

    The qt_system_libs file on Linux will read:

    \code
       libstdc++.so.5
    \endcode

    The necessary system libraries on other platforms are given in
    \l{Resolving Native Libraries}.

    Assuming your current directory is the Jambi directory, you can
    create a \c .jar file on a Linux system with:

    \code
    jar mcf Manifest.text application.jar com/trolltech/images/*png
    com/trolltech/examples/Application.class -C lib
    libcom_trolltech_qt_core.so -C lib libcom_trolltech_qt_gui.so
    com/trolltech/qt/*class com/trolltech/qt/gui/*class
    com/trolltech/qt/core/*class -C $QTDIR/lib libQtGui.so.4 -C
    $QTDIR/lib libQtCore.so.4 qt_system_libs -C /usr/lib
    libstdc++.so.5 -C lib libqtjambi.so
    \endcode

    This example uses a source package. If you have a prebuilt
    package, the Qt libraries are located in the same directory as Qt
    Jambi's libraries (i.e., the QTDIR variable would be set to the Qt
    Jambi directory in the example above).

    The Application Example only uses the \c{com.trolltech.core} and
    \c{com.trolltech.gui} packages, so we only need to include
    libraries for these. If you import other packages, you also
    need to include the native libraries for these. Note that we
    also do not need to include any plugins.

    With the created JAR bundle, it is possible to run the Application
    example on systems that do not have Qt or \QJ installed (a
    Java installation must be present, of course):

    \code
        java -jar application.jar
    \endcode

    \section2 Creating a .jar file for MSVC 2005

    Since the deployment of MSVC 2005 applications is somewhat
    involved, we here show the contents of a \c{.jar} file. This is
    not the complete contents of the file, but shows the MSVC
    relevant contents.

    \code
      QtCore4.dll
      QtGui4.dll
      qtjambi.dll
      com_trolltech_qt_core.dll
      com_trolltech_qt_gui.dll
      msvcr80.dll
      msvcp80.dll
      msvcm80.dll
      Microsoft.VC80.CRT.manifest
      plugins/imageformats/qjpeg4.dll
      plugins/imageformats/Microsoft.VC80.CRT/msvcr80.dll
      plugins/imageformats/Microsoft.VC80.CRT/msvcp80.dll
      plugins/imageformats/Microsoft.VC80.CRT/msvcm80.dll
      plugins/imageformats/Microsoft.VC80.CRT/Microsoft.VC80.CRT.manifest
      qt_system_libs
      
      ...
    \endcode

    The \c{qt_system_libs} file must include the \c{msvc*80.dll} files and
    the manifest. If an application uses other plugins, they are
    added in the same manner. See also the \l{Including Plugins}
    section. Other files can be added as described in the previous
    section.

    \section1 Creating a Web Start Application

    Java Web Start is a helper application that gets associated with a
    Web browser. When a user clicks on a link that points to a special
    launch file, the browser launches Java Web Start, which then
    automatically downloads, caches, and runs the given Java
    Technology-based application.

    The easiest way to create the launch file is to modify an existing
    JNLP (Java Network Launching Protocol and API) file to fit your
    requirements. The application \c .jar file can be created using
    the approach described in the previous section; bundle all the
    class files, resources and native libraries into one single \c
    .jar file.

    Note that for cross platform binaries, it might be useful to
    specify which libraries that should be loaded on a given
    platform. This can be done using the JNLP file.

    The JNLP file is an XML document, and has a \c resources element
    that is used to specify all the resources, such as Java class
    files, native libraries, and system properties, that are part of
    the application. A resource definition can be restricted to a
    specific operating system, architecture, or locale using the \c
    os, \c arch, and \c locale attributes. For example:

    \code
        <resources os="Windows" arch="x86">
            <j2se version="1.5+"/>
            <jar href="qtjambi-win32.jar" />
        </resources>
     \endcode

    For more information about deploying Web Start applications, please
    see the \l
    {http://java.sun.com/j2se/1.5.0/docs/guide/javaws/developersguide/contents.html}{Java
    Web Start Developer's Guide}
*/
