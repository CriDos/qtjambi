/*!
    \page qtjambi-generator.html

    \title The Qt Jambi Generator

    The generator is a Qt application which can be used to map C++
    based APIs onto equivalent Java APIs, enabling C++ programmers to
    easily integrate their own Qt code with Java.

    The generator supports a selected subset of C++, covering the most
    common constructs in Qt. It creates the Java Api by parsing the
    C++ header files and generating Java source files. It also
    generates code to tie the Java classes to the C++ classes. Based
    on the Java Native Interface (JNI), this code ensures that method
    calls made in Java are redirected to the corresponding functions
    in the C++ library.

    \image generator.png

    The \QJ generator is a command line tool accepting a header
    file and a type system specification as arguments:

    \code
        ./generator [options] header-file typesystem-file
    \endcode

    The header file should include the relevant modules of the C++
    based library. The type system specification is a handwritten XML
    document listing the types that will be made available in the
    generated Java API (see the \l {The Qt Jambi Type System}{type
    system} documentation for details).

    \table 100 %
    \header \o {2,1} Command Line Options
    \row
    \o --debug-level=sparse | medium | full

    \o Specifies the debug level of the generator which, for example,
    is useful to understand how the type system is loaded.

    \row
    \o --dump-object-tree
    \o Dumps the parsed object tree as plain text which can be helpful
    when debugging the type system.

    \row
    \o --juic-file
    \o Specifies the location of the information file that is used
    together with \QJ's implementation of UIC (\c juic) to generate
    code for custom libraries.

    \row
    \o --no-cpp-h
    \o The generator will not generate any C++ header files.

    \row
    \o --no-cpp-impl
    \o The generator will not generate any C++ source files.

    \row
    \o --no-java
    \o The generator will not generate any Java source files.

    \row
    \o --no-metainfo
    \o The generator will not generate any meta-info files.

    \row
    \o --no-suppress-warnings
    \o All warnings are shown even if they are suppressed by the type
    system specification (see the \l {The Qt Jambi Type
    System#suppress-warning}{type system} documentation for details).

    \row
    \o --output-directory
    \o Specifies the output directory for the generated code.

    \omit (unstable option)
    \row
    \o --rebuild-only
    \o Specifies a comma separated list of the classes to
    generate (all other classes are ignored).
    \endomit

    \endtable

    When running the generator, the header files are preprocessed
    (i.e., all macros and type definitions are expanded). Then enums,
    namespaces and classes are mapped according to the \l {The Qt
    Jambi Type System}{type system} specification. For each C++ class
    that is encountered, the generator creates a Java source file and
    a set of C++ implementation files.

    \warning The \QJ generator is written to handle Qt- based source
    code, and is not intended for mapping C++ libraries in general.


    \tableofcontents

    \section1 The Java Source File

    The Java source file contains one public class with the same name
    as the original C++ class.

    All public and protected members of the C++ class are included in
    the Java class. For each C++ function, the generator creates a
    native Java method, and each original member variable generates a
    set and get method pair since JNI only provides access to native
    resources through methods. For example, the C++ member variable:

    \code
        QString text;
    \endcode

    generates

    \code
        String text();
        void setText(String text);
    \endcode

    in the Java API.

    Using the \l {The Qt Jambi Type System}{type system} specification,
    it is also possible to rename or remove functions when generating
    the Java API, as well as changing the access privileges. It is
    even possible to use the type system to inject arbitrary code into
    the Java source file, such as an extra member method.

    \section1 The C++ Implementation Files

    The C++ source file contain two different parts: a shell class and
    the implementation of the functions declared in the Java source
    file.

    The shell class inherits the original class in the C++ based Qt
    library, and makes it possible to reimplement virtual functions in
    Java and to call protected functions in the C++ based library from
    Java. Whenever an instance of a class is constructed in Java, a
    corresponding object of the shell class is constructed. If a class
    has been extended by a user's custom Java class, and one or more
    of the virtual functions in the class have been reimplemented, the
    shell class ensures that it is the reimplemented Java implementations
    that are called.

    As with the generated Java source file, it is possible to inject
    code in the reimplemented virtual functions in the shell classes
    using the type system specification.

    The C++ header file is primarily an implementation detail and can
    in most cases be ignored.

    \omit
    \section1 Type Mapping

    The \QJ generator's type mapping is based on the \l {The
    Qt Jambi Type System}{type system} specification passed as
    argument. Types that are not declared in this specification will
    be ignored along with everything that depends on them.

    The \l {The Qt Jambi Type System}{type system} supports the
    following types:

    \list
        \o Object types
        \o Value types
        \o Interface types
        \o Primitive types
        \o C++ based Qt enums
    \endlist

    Most of Qt's classes can be described either as value types or as
    object types. Value types behave like Java's built-in types: they
    can be created on the stack and passed to functions by value or by
    constant reference (const &). Object types behave like Java's
    class constructs: they must be instantiated using the new operator
    and are passed to functions by pointers.

    In the case of object types (e.g., QObject, QEvent, and QPainter),
    the generator will assume that such objects are never passed by
    value in any of the original C++ code. Java objects of these types
    will at all times maintain connections to the equivalent C++
    objects. When mapping object types from Java to C++, the generator
    will look up the Java object's connection to fetch a pointer to
    the corresponding C++ object. When mapping from C++ to Java, the
    objects will be handled differently depending on whether they were
    originally constructed in Java or inside the C++ library: Objects
    created on the Java side will always contain a pointer linking to
    its Java object, and the mapping is a simple pointer lookup. When
    mapping objects allocated within the C++ based library, on the
    other hand, the generator must use a separate list which is
    specifying the Java equivalent for each class.

    In the case of value types, the generator will assume that any
    method modifying an object of a value type class never alters
    the original object. Likewise, a value type object returned from a
    function in the original library can be altered, but it will never
    affect the corresponding object within the original library.

    In the Java part of the technology the value types are identical
    to any other class, and their objects are passed by reference like
    any other Java object. But before they are passed to functions in
    the C++ based library, such objects will be copied by the C++
    implementation using the QMetaType class (QMetaType manages named
    types in Qt's \l {Meta-Object System}{meta-object
    system}). Likewise, return values will be copied before they are
    passed back into Java.

    Finally, interface types are handled equivalently to object type
    classes, primitive types are always passed by value, and enum
    types are handled like primitive integers.

    \endomit
*/

/*!
    \page qtjambi-typesystem.html

    \title The Qt Jambi Type System

    The type system is used when mapping a C++ based library onto a
    corresponding Java library using the \l {The Qt Jambi
    Generator}{Qt Jambi generator}.

    The developer can define the scope of the Java API by writing a
    type system specification. The specification is a handwritten XML
    document listing the types that will be available in the generated
    Java API; types that are not declared in the specification will be
    ignored along with everything that depends on them. In addition,
    it is possible to manipulate and modify the types and functions. It
    is even possible to use the type system specification to inject
    arbitrary code into the source files, such as an extra member
    function.

    The type system specification is passed as an argument to the \l
    {The Qt Jambi Generator}{generator}.

    Below is a complete reference guide to the various nodes of the
    type system. For examples of use, take a look at the type system
    files used to generate the \QJ API. These files can be found in
    the \c generator directory of the \QJ package.

    \tableofcontents

    \section1 Alphabetical List

    \l {access}, \l {argument-map}, \l {conversion-rule}, \l
    {custom-constructor}, \l {custom-destructor}, \l {disable-gc}, \l
    {enum-type}, \l {extra-includes}, \l {include}, \l {inject-code},
    \l {insert-template}, \l {interface-type}, \l
    {load-typesystem}{load-typesystem (multiple type system)}, \l
    {modify-argument}, \l {modify-field}, \l {modify-function}, \l
    {namespace-type}, \l {object-type}, \l {primitive-type}, \l
    {reject-enum-value}, \l {rejection}, \l {remove}, \l
    {remove-argument}, \l remove-default-expression, \l {rename}, \l
    {replace}, \l {replace-default-expression}, \l {replace-type}, \l
    {suppress-warning}, \l {template}, \l {typesystem}, \l
    {value-type}

    \section1 Specifying Types

    \image typesystem-root.png

    \table 100%
    \header
    \o Node \o Description

    \row
    \o \bold typesystem  \target typesystem
    \o

    The \c typesystem node is the root node containing all the type
    system information.

    \code
        <typesystem package="..."
            default-superclass="..." (optional)>
        </typesystem>
    \endcode

    The \c package attribute is a string describing the package to be
    used, e.g.,\c "com.trolltech.qt.core". The optional \c
    default-superclass attribute is the complete class name of the
    default baseclass of all objects in Java, e.g., \c
    "com.trolltech.qt.QtJambiObject".

    \row
    \o \bold load-typesystem \target load-typesystem
    \o

    The \c load-typesystem node specifies which type systems to load
    when mapping multiple libraries to Java or basing one library on
    another, and is a child of the \l typesystem node.

    \code
        <typesystem ...>
            <load-typesystem name="..."
                generate="yes | no">
        </typesystem>
    \endcode

    The \c name attribute is the filename of the type system to load,
    the \c generate attribute specifies whether code should be
    generated or not. The latter must be specified when basing one
    library on another, making the generator able to understand
    inheritance hierarchies, primitive mapping, parameter types in
    functions etc.

    Most libraries will be based on both the QtCore and QtGui modules,
    in which case code generation for these libraries will be
    disabled.

    \row
    \o \bold rejection \target rejection
    \o

    The \c rejection node rejects the given class, or the specified
    function or field, and is a child of the \l typesystem node.

    \code
        <typesystem ...>
            <rejection class="..."
                function-name="..." (optional)
                field-name="..." (optional) />
        </typesystem>
    \endcode

    The \c class attribute is the C++ class name of the class to
    reject. Use the optional \c function-name or \c field-name
    attributes to reject a particular function or field. Note that the
    \c field-name and \c function-name cannot be specified at the same
    time. To remove all occurrences of a given field or function, set
    the \c class attribute to \c *.

    \row
    \o \bold primitive-type \target primitive-type
    \o

    The \c primitive-type node describes how a primitive type is
    mapped from C++ to Java and the Java Native Interface (JNI), and
    is a child of the \l typesystem node. Note that most primitives
    are already specified in the QtCore type system.

    \code
        <typesystem ...>
            <primitive-type name="..."
                java-name="..." (optional)
                jni-name="..." (optional)
                preferred-conversion="yes | no" (optional)>
        </typesystem>
    \endcode

    The \c name attribute is the name of the primitive in C++, the \c
    java-name attribute is the name of the primitive in Java, and the
    \c jni-name attribute is the name of the primitive in JNI. If the
    latter two attributes are not specified, their default value will
    be the same as the \c name attribute.

    If the optional \c preferred-conversion attribute is set to "no",
    it indicates that this version of the primitive is not the
    preferred C++ equivalent of the Java type. For example, both
    "qint64" and "long long" become "long" in Java but we should
    prefer the "qint64" version. For this reason we mark "long long"
    with \c preferred-conversion="no".

    \row
    \o \bold namespace-type \target namespace-type
    \o

    The \c namespace-type node maps the given C++ namespace to Java (
    note that the namespace becomes an interface in Java), and is a
    child of the \l typesystem node. Note that within namespaces, the
    generator only supports enums (i.e., no functions or classes).

    \code
        <typesystem ...>
            <namespace-type name="..."
                package="..." (optional)
                expense-cost="..." (opt)
                expense-limit="..." (opt)/>
        </typesystem>
    \endcode

    The \c name attribute is the name of the namespace, e.g.,
    "Qt". The \c package attribute can be used to override the package
    of the type system.

    \target expense

    The \c expense-cost attribute specifies the memory cost of using
    an instance of the given type, allowing the garbage collector to
    optimize the memory management. The cost is specified using Java
    code. The \c expense-limit attribute specifies how much an
    instance's memory consumption must be before the garbage collector
    is activated (the memory consumption is calculated using the value
    of the \c expense-cost attribute).

    \row
    \o \bold enum-type \target enum-type
    \o

    The \c enum-type node maps the given enum from C++ to Java, and is
    a child of the \l typesystem node. Use the \l reject-enum-value to
    reject values.

    \code
        <typesystem ...>
            <enum-type name="..."
                flags="yes | no" (optional)
                lower-bound="..." (optional)
                upper-bound="..." (optional)
                force-integer="yes | no" (optional)
                extensible="yes | no" (optional)/>
        </typesystem>
    \endcode

    The \c name attribute is the fully qualified C++ name of the enum
    (e.g.,"Qt::FillRule"). If the optional \c flags attribute is set
    to \c yes (the default is \c no), the generator will expect an
    existing QFlags<T> for the given enum type. The \c lower-bound and
    \c upper-bound attributes are used to specify runtime
    boundschecking for the enum value. The value must be a compilable
    java statement, such as "QGradient.Spread.PadSpread". If the \c
    force-integer attribute is set to \c yes (the default is \c no),
    the generated Java code will use integers instead of Java
    enums. And finally, the \c extensible attribute specifies whether
    the given enum can be extended with user values (the default is \c
    no).

    \row
    \o \bold value-type \target value-type
    \o

    The \c value-type node indicates that the given C++ type is mapped
    onto Java as a value type, and is a child of the \l typesystem
    node.

    \code
        <typesystem ...>
            <value-type  name="..."
                package ="..." (optional)
                default-superclass ="..." (optional)
                polymorphic-base="yes | no" (opt)
                polymorphic-id-expression="..." (opt)
                expense-cost="..." (opt)
                expense-limit="..." (opt)/>
        </typesystem>
    \endcode

    The \c name attribute is the fully qualified C++ class name, such
    as "QMatrix" or "QPainterPath::Element". The \c package attribute
    can be used to override the package of the type system. If there is
    no C++ base class, the \c default-superclass attribute can be used
    to specify a superclass for the given type, in the generated Java
    API.

    The \c polymorphic-base and \c polymorphic-id-expression
    attributes have the same meaning as the \l
    {polymorphic}{object-type} node, and the \c expense-cost and \c
    expense-limit attributes have the same meaning as for the \l
    {expense}{namespace-type} node.

    \row
    \o \bold object-type \target object-type
    \o

    The \c object-type node indicates that the given C++ type is
    mapped onto Java as an object type, and is a child of the \l
    typesystem node.

    \code
        <typesystem ...>
            <object-type name="..."
                package ="..." (optional)
                default-superclass ="..." (optional)
                polymorphic-base="yes | no" (opt)
                polymorphic-id-expression="..." (opt)
                expense-cost="..." (opt)
                expense-limit="..." (opt)/>
        </typesystem>
    \endcode

    The \c name attribute is the fully qualified C++ class name. The
    \c package attribute can be used to override the package of the
    type system. If there is no C++ base class, the \c
    default-superclass attribute can be used to specify a superclass
    for the given type, in the generated Java API.

    \target polymorphic

    The \c polymorphic-base attribute is used to specify the base
    class for polymorphic types that do not inherit QObject (like
    QEvent), i.e. types that do not support introspection. By
    specifying the base class, introspection is enabled, provided that
    the subclasses sets the \c polymorphic-id-expression attribute. For
    example:

    \code
        <object-type name="QEvent" polymorphic-base="yes" />
        <object-type name="QTimerEvent"
                     polymorphic-id-expression="%1->type() == QEvent::Timer)" />
    \endcode

    The \c polymorphic-id-expression attribute specifies code that
    determines which subclass, in a polymorphic hierarchy, an object
    belongs to. Instances of \c %1 in the code will be replaced by the
    name of the object in question.

    The \c expense-cost and \c expense-limit attributes have the same
    meaning as for the \l {expense}{namespace-type} node.

    \row
    \o \bold interface-type \target interface-type
    \o

    The \c interface-type node indicates that the given class is
    replaced by an interface pattern when mapping from C++ to Java. It
    is used to resolve multiple base classes which is not supported by
    Java. Using the \c interface-type node implicitly makes the given
    type an \l {object type}.

    \code
        <typesystem ...>
            <interface-type name="..."
                package ="..." (optional)
                default-superclass ="..." (optional)
                polymorphic-base="yes | no" (opt)
                polymorphic-id-expression="..." (opt)
                expense-cost="..." (opt)
                expense-limit="..." (opt)/>
        </typesystem>
     \endcode

    The \c name attribute is the fully qualified C++ class name. The
    \c package attribute can be used to override the package of the
    type system. If there is no C++ base class, the \c
    default-superclass attribute can be used to specify a superclass
    in the generated Java API, for the given class.

    The \c polymorphic-base and \c polymorphic-id-expression
    attributes have the same meaning as the \l
    {polymorphic}{object-value} node, and the \c expense-cost and \c
    expense-limit attributes have the same meaning as for the \l
    {expense}{namespace-type} node.

    \row
    \o \bold suppress-warning \target suppress-warning
    \o

    The generator will generate several warnings which may be
    irrelevant to the user. The \c suppress-warning node suppresses the
    specified warning, and is a child of the \l typesystem node.

    \code
        <typesystem...>
            <suppress-warning text="..." />
        </typesystem>
    \endcode

    The \c text attribute is the warning text to suppress, and may
    contain the \c * wildcard (use "\" to escape regular expression
    matching if the warning contain a regular "*").

    \row
    \o \bold template \target template
    \o

    The \c template node registers a template that can be used to
    avoid duplicate code when extending the generated code, and is a
    child of the \l typesystem node.

    \code
        <typesystem>
            <template name="my_template">
                // the code
            </template>
        </typesystem>
    \endcode

    Use the \l insert-template node to insert the template code
    (identified by the template's \c name attribute) into the
    generated code base.

    \endtable

    \section2 Value Type Requirements

    \image typesystem-valuetype.png

    \table 100%
    \header
    \o Node \o Description

    \row
    \o \bold custom-constructor \target custom-constructor
    \o

    In Java, value types are required to have a copy constructor. If a
    C++ class without a copy constructor is mapped onto Java as a
    value type, it is possible to provide a custom constructor using
    the \c custom-constructor node which is a child of the \c
    value-type node.

    \code
       <value-type ...>
           <custom-constructor
                name="..." (optional)
                param-name="..." (optional)>
                   // code for custom constructor
           </custom-constructor>
       </value-type>
    \endcode

    The custom constructor's signature becomes:

    \code
        T *name(T *param-name);
    \endcode

    If not specified the name of the constructor becomes \c
    {<lowercase type name>_create()} and the parameter name becomes \c
    copy.

    \row
    \o \bold custom-destructor \target custom-destructor
    \o

    When a custom constructor is provided using the \l
    custom-constructor node, it is most likely required to clean up
    the allocated memory. For that reason, it is also possible to
    provide a custom destructor using the \c custom-destructor node
    which is a child of the \c value-type node.

    \code
       <value-type ...>
           <custom-destructor
                name="..." (optional)
                param-name="..." (optional)>
                   // code for custom destructor
           </custom-destructor>
       </value-type>
    \endcode

    The custom destructor must have the following signature:

    \code
        T *name(T *param-name);
    \endcode

    If not specified the name of the destructor becomes \c
    {<lowercase type name>_delete()} and the parameter name becomes \c
    copy.

    \row
    \o \bold  insert-template
    \o Documented in the \l {insert-template}{Using Code Templates} section


    \endtable

    \section2 Manipulating Object and Value Types

    \image typesystem-manipulatingtypes.png

    \table 100%
    \header
    \o Node \o Description

    \row
    \o \bold inject-code \target inject-code
    \o

    The \c inject-code node inserts the given code into the generated
    code for the given type or function, and is a child of the \l
    object-type, \l value-type and \l modify-function nodes.

    \code
        <value-type ...>
            <inject-code class="java | native | shell | shell-declaration"
                position="beginning | end">
                // the code
            </inject-code>
        </value-type>
    \endcode

    The \c class attribute specifies which module of the generated
    code that will be affected by the code injection. The \c class
    attribute accepts the following values:

    \list
        \o \c java: The generated java code
        \o \c native: The generated JNI-based methods
        \o \c shell: The generated shell class
        \o \c shell-declaration: The code will be injected into the
        generated header file containing the shell class definition.
    \endlist

    If the position attribute is set to \c beginning (the default), the
    code is inserted at the beginning of the function. If it is set to
    \c end, the code is inserted at the end of the function.

    \row
    \o \bold  modify-field \target modify-field
    \o

    The \c modify-field node allows you to alter the access privileges
    for a given C++ field when mapping it onto Java, and is a child of
    an \l object-type or a \l value-type node.

    \code
        <object-type ...>
            <modify-field name="..."
                write="true | false" (optional)
                read="true | false" (optional)/>
        </object-type>
    \endcode

    The \c name attribute is the name of the field, the optional \c
    write and \c read attributes specify the field's access privileges
    in the Java API (both are set to \c true by default).

    \row
    \o \bold  modify-function \target modify-function
    \o

    The \c modify-function node allows you to modify a given C++
    function when mapping it onto Java, and is a child of an \l
    object-type or a \l value-type node. Use the \l modify-argument
    node to specify which argument the modification affects.

    \code
        <object-type ...>
            <modify-function class="shell | native | java
                | shell-declaration" (optional)
                signature="...">
        </object-type>
    \endcode

    The \c class attribute specifies which module of the generated
    code that will be affected by the modification. This is only a
    hint to the generator, as certain modifications are irrelevant for
    certain modules while others usually span across all modules in
    order to be effective (e.g. the \l remove modifier will affect all
    modules unless its \c exclusive attribute is set to true).

    The \c class attribute accepts the following values:

    \list
        \o \c java: The generated java code
        \o \c native: The generated JNI-based methods
        \o \c shell: The generated shell class
        \o \c shell-declaration: Only used for injecting code. The
        code will be injected into the generated header file
        containing the shell class definition.
    \endlist

    The \c signature attribute is a normalized C++ signature,
    excluding return values but including potential \c const
    declarations.

    \row
    \o \bold  include
    \o Documented in the \l {include}{Manipulating Namespace and
    Interface Types} section

    \row
    \o \bold  extra-includes
    \o Documented in the \l {include}{Manipulating Namespace and
    Interface Types} section

    \row
    \o \bold  insert-template
    \o Documented in the \l {insert-template}{Using Code Templates} section

    \endtable

    \section2 Manipulating Namespace and Interface Types

    \image typesystem-manipulating-namespaces-and-interfaces.png

    \table 100%
    \header
    \o Node \o Description

    \row
    \o \bold extra-includes \target extra-includes
    \o

    The \c extra-includes node contains declarations of additional
    include files, and can be a child of the \l interface-type, \l
    namespace-type, \l value-type and \l object-type nodes.

    The generator automatically tries to read the global header for
    each type. But sometimes it is required to include extra files in
    the generated C++ code to make sure that the code compiles. These
    files must be listed using \l include nodes witin the \c
    extra-include node:

    \code
        <value-type ...>
            <extra-includes>
                <include file-name="..." location="global | local | java"/>
            </extra-includes>
        </value-type>
    \endcode

    The \c file-name attribute is the file to include, such as
    "QStringList". The \c location attribute is where the file is
    located: \c global means that the file is located in \c
    $INCLUDEPATH and will be included using \c {#include <...>}, \c
    local means that the file is in a local directory and will be
    included using \c {#include "..."}. If the \c location is set to
    \c java then the \c file-name attribute is expected to contain
    the fully qualified name for a java class and the specified class
    will be imported in the generated java code.

    \row
    \o \bold include \target include
    \o

    The \c include node specifies the name and location of a file that
    must be included, and is a child of the \l interface-type, \l namespace-type, \l
    value-type, \l object-type or \l extra-includes nodes

    The generator automatically tries to read the global header for
    each type. Use the \c include node to override this behavior,
    providing an alternative file. The \c include node can also be
    used to specify \l {extra-includes}{extra include files}.

    \code
        <value-type ...>
            <include file-name="..."
                location="global | local | java"/>
        </value-type>
    \endcode

    The \c file-name attribute is the file to include, such as
    "QStringList". The \c location attribute is where the file is
    located: \c global means that the file is located in \c
    $INCLUDEPATH and will be included using \c {#include <...>}, \c
    local means that the file is in a local directory and will be
    included using \c {#include "..."}. If the \c location attribute
    is set to \c java in this particular case, it will be ignored.

    \endtable

    \section2 Manipulating Enum Types

    \image typesystem-manipulatingenums.png

    \table 100%
    \header
    \o Node \o Description

    \row
    \o \bold reject-enum-value \target reject-enum-value
    \o

    The \c reject-enum-value node rejects the enum value specified by
    the \c name attribute, and is a child of the \l enum-type node.

    \code
        <enum-type ...>
            <reject-enum-value name="..."/>
        </enum-type>
    \endcode

    This node is used when a C++ enum implementation has several
    identical numeric values, some of which are typically obsolete.

    \endtable

    \section1 Modifying Functions

    \image typesystem-modifyfunction.png

    \table 100%
    \header
    \o Node \o Description

    \row
    \o \bold  modify-argument \target modify-argument
    \o

    The \c modify-argument node specifies which of the given
    function's arguments the modification affects, and is a child of
    the \l modify-function node. Use the \l remove-argument, \l
    replace-default-expression, \l remove-default-expression, \l
    replace-type, and \l disable-gc nodes to specify the details of
    the modification.

    \code
        <modify-function ...>
            <modify-argument index="return | this | 1 ...>
                modifications
            </modify-argument>
        </modify-function>
    \endcode

    Set the \c index attribute to "1" for the first argument, "2" for
    the second one and so on. Alternatively, set it to "return" or
    "this" if you want to modify the function's return value or the
    object the function is called upon, respectively.

    \row
    \o \bold  remove \target remove
    \o

    The \c remove node removes the given method from the generated
    Java code, and is a child of the \l modify-function node.

    \code
        <modify-function ...>
            <remove exclusive=" Yes | No"(optional)/>
        </modify-function>
    \endcode

    If the \c exclusive attribute is set to "Yes", the function is
    only removed for the part of the generated code specified by the
    \l modify-function's \c class attribute; the default value is
    "No".

    \row
    \o \bold  access \target access
    \o

    The \c access node changes the access privileges of the given
    function in the generated Java code, and is a child of the \l
    modify-function node.

    \code
        <modify-function ...>
            <access modifier="public | protected | private"/>
        </modify-function>
    \endcode

    \row
    \o \bold  rename \target rename
    \o

    The \c rename node changes the name of the given function in the
    generated Java code, and is a child of the \l modify-function
    node.

    \code
        <modify-function...>
            <rename to="..." />
        </modify-function>
    \endcode

    The \c to attribute is the new name of the function.

    \row
    \o \bold  inject-code
    \o Documented in the \l {inject-code}{Manipulating Types} section

    \row
    \o \bold argument-map \target argument-map
    \o

    The \c argument-map node maps a C++ argument name to the argument
    name used in the generated Java code, and is a child of the \l
    inject-code node when the latter is a child of a \l
    modify-function node.

    \code
        <modify-function...>
            <inject-code ...>
                <argument-map position="numeric value"
                    meta-name="string value">
            </inject-code>
        </modify-function>
    \endcode

    The \c position attribute is an index, starting at 1, indicating
    the argument position to which this argument mapping applies. The
    \c meta-name attribute is the name used within the code injection
    to adress the argument at the given position.

    \endtable

    \section2 Modifying Arguments

    \image typesystem-modifyargument.png

    \table 100%
    \header
    \o Node \o Description

    \row
    \o \bold  remove-argument \target remove-argument
    \o

    The \c remove-argument node removes the given argument from the
    function's signature, and is a child of the \l modify-argument
    node.

    \code
        <modify-argument ...>
            <remove-argument />
        </modify-argument>
    \endcode

    Typically, when removing an argument, some conversion rules must
    be specified, e.g., when converting from Java to C++. This can be
    done using the \l conversion-rule node.

    \row
    \o \bold remove-default-expression \target remove-default-expression
    \o

    The \c remove-default-expression node disables the use of the
    default expression for the given argument, and is a child of the
    \l modify-argument node.

    \code
        <modify-argument...>
            <remove-default-expression />
        </modify-argument>
    \endcode

    \row
    \o \bold replace-default-expression \target replace-default-expression
    \o

    The \c replace-default-expression node replaces the specified
    argument with the expression specified by the \c with attribute,
    and is a child of the \l modify-argument node.

    \code
        <modify-argument...>
            <replace-default-expression with="..." />
        </modify-argument>
    \endcode

    \row
    \o \bold replace-type \target replace-type
    \o

    The \c replace-type node replaces the type of the given argument
    to the one specified by the \c modified-type attribute, and is a
    child of the \l modify-argument node.

    \code
        <modify-argument...>
            <replace-type modified-type="..." />
        </modify-argument>
    \endcode

    If the new type is a class, the \c modified-type attribute must be
    set to the fully qualified name (including name of the package as
    well as the class name).

    Typically, when changing the type of an argument, some conversion
    rules must be specified. This can be done using the \l
    conversion-rule node.

    \row
    \o \bold disable-gc \target disable-gc
    \o

    The \c disable-gc node indicates that the argument object will not
    be garbage collected once it has been passed to the function, and is a
    child of the \l modify-argument node.

    \code
        <modify-argument ...>
             <disable-gc />
        </modify-argument>
    \endcode

    Note that this node will only have an effect when the associated
    \c modify-function node's \c class attribute is either "java" or
    "shell".

    \row
    \o \bold conversion-rule \target conversion-rule
    \o

    The \c conversion-rule node allows you to write customized code to
    convert the given argument between Java and C++, and is a child of
    the \l modify-argument node.

    \code
        <modify-argument ...>
             <conversion-rule>
                // the code
             </conversion-rule>
        </modify-argument>
    \endcode

    This node is typically used in combination with the \l
    replace-type and \l remove-argument nodes. The given code is used
    instead of the generator's conversion code in the following
    situations (defined by the \l modify-argument node's \c index
    attribute and the \l modify-function node's \c class attribute as
    well the function implementation and where the
    function is called from):

    \raw HTML
    <table align="center" cellpadding="2" cellspacing="1" border="0">
        <tr valign="top" bgcolor="#a2c511">
            <th>Argument Index</th>
            <th>Function Class</th>
            <th>Function Implementation</th>
            <th>Caller Location</th>
         </tr>
         <tr valign="top" bgcolor="#f0f0f0">
             <td>1 | 2 ...</td>
             <td>shell</td>
             <td>Java (overriding C++)</td>
             <td>C++ </td>
         </tr>
         <tr valign="top" bgcolor="#e0e0e0">
             <td>1 | 2 ...</td>
             <td>native</td>
             <td>C++</td>
             <td>Java</td>
         </tr>
         <tr valign="top" bgcolor="#f0f0f0">
             <td>return</td>
             <td>java</td>
             <td>C++</td>
             <td>Java</td>
         </tr>
         <tr valign="top" bgcolor="#e0e0e0">
             <td>return </td>
             <td>native</td>
             <td>Java (overriding C++)</td>
             <td>C++</td>
         </tr>

    </table>
    \endraw

    Writing \c %N in the code (where \c N is a number), will insert
    the name of the \e{n}th argument. Alternatively, \c %in and \c
    %out which will be replaced with the name of the conversion's
    input and output variable, respectively. Note the output variable
    must be declared explicitly, for example:

    \code
        <conversion-rule>
            bool %out = (bool) %in;
        </conversion-rule>
    \endcode

    \row
    \o \bold  insert-template
    \o Documented in the \l {insert-template}{Using Code Templates} section


    \endtable

    \section1 Using Code Templates

    \image typesystem-templates.png

    \table 100%
    \header
    \o Node \o Description

    \row
    \o \bold insert-template \target insert-template
    \o

    The \c insert-template node includes the code template identified
    by the \c name attribute, and can be a child of the \l
    inject-code, \l conversion-rule, \l template, \l
    custom-constructor and \l custom-destructor nodes. For example;

    \code
        <inject-code class=java position="beginning">
            <insert-template name="my_template" />
        </inject-code>
    \endcode

    Use the \l replace node to modify the template code.

    \row
    \o \bold replace \target replace
    \o

    The \c replace node allows you to modify template code before
    inserting it into the generated code, and can be a child of the \l
    insert-template node.

    \code
        <insert-template name="my_template">
            <replace from="..." to="..." />
        </insert-template>
    \endcode

    Using this node the code specified by the \c from attribute is
    altered into the code specified by the \c to attribute.

    \endtable

*/
