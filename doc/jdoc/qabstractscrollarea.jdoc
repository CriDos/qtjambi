<class name="QAbstractScrollArea" doc="/**
<p>The QAbstractScrollArea widget provides a scrolling area with on-demand scroll bars.</p>
<p>QAbstractScrollArea is a low-level abstraction of a scrolling area. It gives you full control of the scroll bars, at the cost of simplicity. In most cases, using a QScrollArea is preferable.</p>
<p>QAbstractScrollArea's central child widget is the scrolling area itself, called viewport(). The viewport widget uses all available space. Next to the viewport is a vertical scroll bar (accessible with verticalScrollBar()), and below a horizontal scroll bar (accessible with horizontalScrollBar()). Each scroll bar can be either visible or hidden, depending on the scroll bar's policy (see verticalScrollBarPolicy and horizontalScrollBarPolicy). When a scroll bar is hidden, the viewport expands in order to cover all available space. When a scroll bar becomes visible again, the viewport shrinks in order to make room for the scroll bar.</p>
<p>With a scroll bar policy of Qt::ScrollBarAsNeeded (the default), QAbstractScrollArea shows scroll bars when those provide a non-zero scrolling range, and hides them otherwise. You control the range of each scroll bar with QAbstractSlider::setRange().</p>
<p>In order to track scroll bar movements, reimplement the virtual function scrollContentsBy(). In order to fine-tune scrolling behavior, connect to a scroll bar's QAbstractSlider::actionTriggered() signal and adjust the QAbstractSlider::sliderPosition as you wish.</p>
<p>It is possible to reserve a margin area around the viewport, see setViewportMargins(). The feature is mostly used to place a QHeaderView widget above or beside the scrolling area.</p>
<p>For convenience, QAbstractScrollArea makes all viewport events available in the virtual viewportEvent() handler. QWidget's specialised handlers are remapped to viewport events in the cases where this makes sense. The remapped specialised handlers are: paintEvent(), mousePressEvent(), mouseReleaseEvent(), mouseDoubleClickEvent(), mouseMoveEvent(), wheelEvent(), dragEnterEvent(), dragMoveEvent(), dragLeaveEvent(), dropEvent(), contextMenuEvent(). and resizeEvent().</p>

*/">
    <method name="public QAbstractScrollArea(com.trolltech.qt.gui.QWidget parent__0)" doc="/**
<p>Constructs a viewport.</p>
<p>The <i>parent</i> arguments is sent to the QWidget constructor.</p>

*/"/>
    <method name="public final void addScrollBarWidget(com.trolltech.qt.gui.QWidget widget__0, com.trolltech.qt.core.Qt.Alignment alignment__1)" doc="/**
<p>Adds <i>widget</i> as a scroll bar widget in the location specified by <i>alignment</i>.</p>
<p>Scroll bar widgets are shown next to the horizontal or vertical scroll bar, and can be placed on either side of it. If you want the scroll bar widgets to be always visible, set the scrollBarPolicy for the corresponding scroll bar to <tt>AlwaysOn</tt>.</p>
<p><i>alignment</i> must be one of Qt::Alignleft and Qt::AlignRight, which maps to the horizontal scroll bar, or Qt::AlignTop and Qt::AlignBottom, which maps to the vertical scroll bar.</p>
<p>A scroll bar widget can be removed by either re-parenting the widget or deleting it. It's also possible to hide a widget with QWidget::hide()</p>
<p>The scroll bar widget will be resized to fit the scroll bar geometry for the current style. The following describes the case for scroll bar widgets on the horizontal scroll bar:</p>
<p>The height of the widget will be set to match the height of the scroll bar. To control the width of the widget, use QWidget::setMinimumWidth and QWidget::setMaximumWidth, or implement QWidget::sizeHint() and set a horizontal size policy. If you want a square widget, call QStyle::pixelMetric(QStyle::PM_ScrollBarExtent) and set the width to this value.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QWidget cornerWidget()" doc="/**
<p>Returns the widget in the corner between the two scroll bars.</p>
<p>By default, no corner widget is present.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QScrollBar horizontalScrollBar()" doc="/**
<p>Returns the horizontal scroll bar.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.Qt.ScrollBarPolicy horizontalScrollBarPolicy()"/>
    <method name="public final com.trolltech.qt.core.QSize maximumViewportSize()" doc="/**
<p>Returns the size of the viewport as if the scroll bars had no valid scrolling range.</p>

*/"/>
    <method name="public final java.util.List&lt;com.trolltech.qt.gui.QWidget&gt; scrollBarWidgets(com.trolltech.qt.core.Qt.Alignment alignment__0)" doc="/**
<p>Returns a list of the currently set scroll bar widgets. <i>alignment</i> can be any combination of the four location flags.</p>

*/"/>
    <method name="public final void setCornerWidget(com.trolltech.qt.gui.QWidget widget__0)" doc="/**
<p>Sets the widget in the corner between the two scroll bars to be <i>widget</i>.</p>
<p>You will probably also want to set at least one of the scroll bar modes to <tt>AlwaysOn</tt>.</p>
<p>Passing 0 shows no widget in the corner.</p>
<p>Any previous corner widget is hidden.</p>
<p>You may call setCornerWidget() with the same widget at different times.</p>
<p>All widgets set here will be deleted by the scroll area when it is destroyed unless you separately reparent the widget after setting some other corner widget (or 0).</p>
<p>Any <i>newly</i> set widget should have no current parent.</p>
<p>By default, no corner widget is present.</p>

*/"/>
    <method name="public final void setHorizontalScrollBar(com.trolltech.qt.gui.QScrollBar scrollbar__0)" doc="/**
<p>Replaces the existing horizontal scroll bar with <i>scrollBar</i>, and sets all the former scroll bar's slider properties on the new scroll bar. The former scroll bar is then deleted.</p>
<p>QAbstractScrollArea already provides horizontal and vertical scroll bars by default. You can call this function to replace the default horizontal scroll bar with your own custom scroll bar.</p>

*/"/>
    <method name="public final void setHorizontalScrollBarPolicy(com.trolltech.qt.core.Qt.ScrollBarPolicy arg__0)"/>
    <method name="public final void setVerticalScrollBar(com.trolltech.qt.gui.QScrollBar scrollbar__0)" doc="/**
<p>Replaces the existing vertical scroll bar with <i>scrollBar</i>, and sets all the former scroll bar's slider properties on the new scroll bar. The former scroll bar is then deleted.</p>
<p>QAbstractScrollArea already provides vertical and horizontal scroll bars by default. You can call this function to replace the default vertical scroll bar with your own custom scroll bar.</p>

*/"/>
    <method name="public final void setVerticalScrollBarPolicy(com.trolltech.qt.core.Qt.ScrollBarPolicy arg__0)"/>
    <method name="public final void setViewport(com.trolltech.qt.gui.QWidget widget__0)" doc="/**
<p>Sets the viewport to be the given <i>widget</i>. The QAbstractScrollArea will take ownership of the given <i>widget</i>.</p>
<p>If <i>widget</i> is 0, QAbstractScrollArea will assign a new QWidget instance for the viewport.</p>

*/"/>
    <method name="protected final void setViewportMargins(int left__0, int top__1, int right__2, int bottom__3)" doc="/**
<p>Sets the margins around the scrolling area to <i>left</i>, <i>top</i>, <i>right</i> and <i>bottom</i>. This is useful for applications such as spreadsheets with &quot;locked&quot; rows and columns. The marginal space is is left blank; put widgets in the unused area.</p>
<p>By default all margins are zero.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QScrollBar verticalScrollBar()" doc="/**
<p>Returns the vertical scroll bar.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.Qt.ScrollBarPolicy verticalScrollBarPolicy()"/>
    <method name="public final com.trolltech.qt.gui.QWidget viewport()" doc="/**
<p>Returns the viewport widget.</p>
<p>Use the QScrollArea::widget() function to retrieve the contents of the viewport widget.</p>

*/"/>
    <method name="protected void contextMenuEvent(com.trolltech.qt.gui.QContextMenuEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive context menu events for the viewport() widget. The event is passed in <i>e</i>.</p>

*/"/>
    <method name="protected void dragEnterEvent(com.trolltech.qt.gui.QDragEnterEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive drag enter events (passed in <i>event</i>), for the viewport() widget.</p>

*/"/>
    <method name="protected void dragLeaveEvent(com.trolltech.qt.gui.QDragLeaveEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive drag leave events (passed in <i>event</i>), for the viewport() widget.</p>

*/"/>
    <method name="protected void dragMoveEvent(com.trolltech.qt.gui.QDragMoveEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive drag move events (passed in <i>event</i>), for the viewport() widget.</p>

*/"/>
    <method name="protected void dropEvent(com.trolltech.qt.gui.QDropEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive drop events (passed in <i>event</i>), for the viewport() widget.</p>

*/"/>
    <method name="public boolean event(com.trolltech.qt.core.QEvent arg__0)" doc="/**
<p>This is the main event handler for the QAbstractScrollArea widget (<i>not</i> the scrolling area viewport()). The event is passed in <i>e</i>.</p>

*/"/>
    <method name="protected void keyPressEvent(com.trolltech.qt.gui.QKeyEvent arg__0)" doc="/**
<p>This function is called with key event <i>e</i> when key presses occur. It handles PageUp, PageDown, Up, Down, Left, and Right, and ignores all other key presses.</p>

*/"/>
    <method name="public com.trolltech.qt.core.QSize minimumSizeHint()"/>
    <method name="protected void mouseDoubleClickEvent(com.trolltech.qt.gui.QMouseEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive mouse double click events for the viewport() widget. The event is passed in <i>e</i>.</p>

*/"/>
    <method name="protected void mouseMoveEvent(com.trolltech.qt.gui.QMouseEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive mouse move events for the viewport() widget. The event is passed in <i>e</i>.</p>

*/"/>
    <method name="protected void mousePressEvent(com.trolltech.qt.gui.QMouseEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive mouse press events for the viewport() widget. The event is passed in <i>e</i>.</p>

*/"/>
    <method name="protected void mouseReleaseEvent(com.trolltech.qt.gui.QMouseEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive mouse release events for the viewport() widget. The event is passed in <i>e</i>.</p>

*/"/>
    <method name="protected void paintEvent(com.trolltech.qt.gui.QPaintEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive paint events (passed in <i>event</i>), for the viewport() widget.</p>
<p>Note: If you open a painter, make sure to open it on the viewport().</p>

*/"/>
    <method name="protected void resizeEvent(com.trolltech.qt.gui.QResizeEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive resize events (passed in <i>event</i>), for the viewport() widget.</p>
<p>When resizeEvent() is called, the viewport already has its new geometry: Its new size is accessible through the QResizeEvent::size() function, and the old size through QResizeEvent::oldSize().</p>

*/"/>
    <method name="protected void scrollContentsBy(int dx__0, int dy__1)" doc="/**
<p>This virtual handler is called when the scroll bars are moved by <i>dx</i>, <i>dy</i>, and consequently the viewport's contents should be scrolled accordingly.</p>
<p>The default implementation simply calls update() on the entire viewport(), subclasses can reimplement this handler for optimization purposes, or - like QScrollArea - to move a contents widget. The paramters <i>dx</i> and <i>dy</i> are there for convenience, so that the class knows how much should be scrolled (useful e.g. when doing pixel-shifts). You may just as well ignore these values and scroll directly to the position the scroll bars indicate.</p>
<p>Calling this function in order to scroll programmatically is an error, use the scroll bars instead (e.g. by calling QScrollBar::setValue() directly).</p>

*/"/>
    <method name="protected void setupViewport(com.trolltech.qt.gui.QWidget viewport__0)" doc="/**
<p>This slot is called by QAbstractScrollArea after setViewport(<i>viewport</i>) has been called. Reimplement this function in a subclass of QAbstractScrollArea to initialize the new <i>viewport</i> before it is used.</p>

*/"/>
    <method name="public com.trolltech.qt.core.QSize sizeHint()"/>
    <method name="protected boolean viewportEvent(com.trolltech.qt.core.QEvent arg__0)" doc="/**
<p>The main event handler for the scrolling area (the viewport() widget). It handles event <i>e</i>.</p>
<p>You can reimplement this function in a subclass, but we recommend using one of the specialized event handlers instead.</p>
<p>Specialised handlers for viewport events are: paintEvent(), mousePressEvent(), mouseReleaseEvent(), mouseDoubleClickEvent(), mouseMoveEvent(), wheelEvent(), dragEnterEvent(), dragMoveEvent(), dragLeaveEvent(), dropEvent(), contextMenuEvent(), and resizeEvent().</p>

*/"/>
    <method name="protected void wheelEvent(com.trolltech.qt.gui.QWheelEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive wheel events for the viewport() widget. The event is passed in <i>e</i>.</p>

*/"/>
</class>
