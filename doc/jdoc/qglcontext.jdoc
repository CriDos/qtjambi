<class name="QGLContext" doc="/**
<p>The QGLContext class encapsulates an OpenGL rendering context.</p>
<p>An OpenGL </p>
<!-- <p>OpenGL is a trademark of Silicon Graphics, Inc. in the United States and other countries.</p>
--> rendering context is a complete set of OpenGL state variables.<p>The context's format is set in the constructor or later with setFormat(). The format options that are actually set are returned by format(); the options you asked for are returned by requestedFormat(). Note that after a QGLContext object has been constructed, the actual OpenGL context must be created by explicitly calling the create() function. The makeCurrent() function makes this context the current rendering context. You can make <i>no</i> context current using doneCurrent(). The reset() function will reset the context and make it invalid.</p>
<p>You can examine properties of the context with, e.g. isValid(), isSharing(), initialized(), windowCreated() and overlayTransparentColor().</p>
<p>If you're using double buffering you can swap the screen contents with the off-screen buffer using swapBuffers().</p>
<p>Please note that QGLContext is not thread safe.</p>

*/">
    <method name="public QGLContext(com.trolltech.qt.opengl.QGLFormat format__0, com.trolltech.qt.gui.QPaintDeviceInterface device__1)" doc="/**
<p>Constructs an OpenGL context for the paint device <i>device</i>, which can be a widget or a pixmap. The <i>format</i> specifies several display options for the context.</p>
<p>If the underlying OpenGL/Window system cannot satisfy all the features requested in <i>format</i>, the nearest subset of features will be used. After creation, the format() method will return the actual format obtained.</p>
<p>Note that after a QGLContext object has been constructed, create() must be called explicitly to create the actual OpenGL context. The context will be invalid if it was not possible to obtain a GL context at all.</p>

*/"/>
    <method name="public QGLContext(com.trolltech.qt.opengl.QGLFormat format__0)"/>
    <method name="public final int bindTexture(com.trolltech.qt.gui.QImage image__0, int target__1, int format__2)" doc="/**
<p>Generates and binds a 2D GL texture to the current context, based on <i>image</i>. The generated texture id is returned and can be used in later <tt>glBindTexture()</tt> calls.</p>
<p>The <i>target</i> parameter specifies the texture target. The default target is <tt>GL_TEXTURE_2D</tt>.</p>
<p>The <i>format</i> parameter sets the internal format for the texture. The default format is <tt>GL_RGBA8</tt>.</p>
<p>If the GL implementation supports the <tt>GL_SGIS_generate_mipmap</tt> extension, mipmaps will be automatically generated for the texture. Mipmap generation is only supported for the <tt>GL_TEXTURE_2D</tt> target.</p>
<p>The texture that is generated is cached, so multiple calls to bindTexture() with the same QImage will return the same texture id.</p>

*/"/>
    <method name="public final int bindTexture(java.lang.String fileName__0)" doc="/**
<p>Reads the DirectDrawSurface (DDS) compressed file <i>fileName</i> and generates a 2D GL texture from it.</p>
<p>Only the DXT1, DXT3 and DXT5 DDS formats are supported.</p>
<p>Note that this will only work if the implementation supports the <tt>GL_ARB_texture_compression</tt> and <tt>GL_EXT_texture_compression_s3tc</tt> extensions.</p>

*/"/>
    <method name="public final int bindTexture(com.trolltech.qt.gui.QPixmap pixmap__0, int target__1, int format__2)" doc="/**
<p>Generates and binds a 2D GL texture based on <i>pixmap</i>.</p>

*/"/>
    <method name="protected final int colorIndex(com.trolltech.qt.gui.QColor c__0)" doc="/**
<p>Returns a colormap index for the color c, in ColorIndex mode. Used by qglColor() and qglClearColor().</p>

*/"/>
    <method name="public final void deleteTexture(int tx_id__0)" doc="/**
<p>Removes the texture identified by <i>id</i> from the texture cache. If the context is not shared by any other QGLContext, glDeleteTextures() will be called to delete the texture from the context.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QPaintDeviceInterface device()" doc="/**
<p>Returns the paint device set for this context.</p>

*/"/>
    <method name="protected final boolean deviceIsPixmap()" doc="/**
<p>Returns true if the paint device of this context is a pixmap; otherwise returns false.</p>

*/"/>
    <method name="public final com.trolltech.qt.opengl.QGLFormat format()" doc="/**
<p>Returns the frame buffer format that was obtained (this may be a subset of what was requested).</p>

*/"/>
    <method name="protected final void generateFontDisplayLists(com.trolltech.qt.gui.QFont fnt__0, int listBase__1)" doc="/**
<p>Generates a set of 256 display lists for the 256 first characters in the font <i>font</i>. The first list will start at index <i>listBase</i>.</p>

*/"/>
    <method name="public final com.trolltech.qt.QNativePointer getProcAddress(java.lang.String proc__0)" doc="/**
<p>Returns a function pointer to the GL extension function passed in <i>proc</i>. 0 is returned if a pointer to the function could not be obtained.</p>

*/"/>
    <method name="protected final boolean initialized()" doc="/**
<p>Returns true if this context has been initialized, i.e. if QGLWidget::initializeGL() has been performed on it; otherwise returns false.</p>

*/"/>
    <method name="public final boolean isSharing()" doc="/**
<p>Returns true if this context is sharing its GL context with another QGLContext, otherwise false is returned. Note that context sharing might not be supported between contexts with different formats.</p>

*/"/>
    <method name="public final boolean isValid()" doc="/**
<p>Returns true if a GL rendering context has been successfully created; otherwise returns false.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QColor overlayTransparentColor()" doc="/**
<p>If this context is a valid context in an overlay plane, returns the plane's transparent color. Otherwise returns an invalid color.</p>
<p>The returned color's pixel value is the index of the transparent color in the colormap of the overlay plane. (Naturally, the color's RGB values are meaningless.)</p>
<p>The returned QColor object will generally work as expected only when passed as the argument to QGLWidget::qglColor() or QGLWidget::qglClearColor(). Under certain circumstances it can also be used to draw transparent graphics with a QPainter. See the examples/opengl/overlay_x11 example for details.</p>

*/"/>
    <method name="public final com.trolltech.qt.opengl.QGLFormat requestedFormat()" doc="/**
<p>Returns the frame buffer format that was originally requested in the constructor or setFormat().</p>

*/"/>
    <method name="public final void reset()" doc="/**
<p>Resets the context and makes it invalid.</p>

*/"/>
    <method name="protected final void setDevice(com.trolltech.qt.gui.QPaintDeviceInterface pDev__0)"/>
    <method name="public final void setFormat(com.trolltech.qt.opengl.QGLFormat format__0)" doc="/**
<p>Sets a <i>format</i> for this context. The context is reset.</p>
<p>Call create() to create a new GL context that tries to match the new format.</p>
<pre>    QGLContext *cx;
<span class=&quote;comment&quote;>    //  ...</span>
    QGLFormat f;
    f.setStereo(true);
    cx-&gt;setFormat(f);
    if (!cx-&gt;create())
        exit(); <span class=&quote;comment&quote;>// no OpenGL support, or cannot render on the specified paintdevice</span>
    if (!cx-&gt;format().stereo())
        exit(); <span class=&quote;comment&quote;>// could not create stereo context</span></pre>

*/"/>
    <method name="protected final void setInitialized(boolean on__0)" doc="/**
<p>If <i>on</i> is true the context has been initialized, i.e. QGLContext::setInitialized() has been called on it. If <i>on</i> is false the context has not been initialized.</p>

*/"/>
    <method name="protected final void setValid(boolean valid__0)" doc="/**
<p>Forces the GL rendering context to be valid.</p>

*/"/>
    <method name="protected final void setWindowCreated(boolean on__0)" doc="/**
<p>If <i>on</i> is true the context has had a window created for it. If <i>on</i> is false no window has been created for the context.</p>

*/"/>
    <method name="protected final boolean windowCreated()" doc="/**
<p>Returns true if a window has been created for this context; otherwise returns false.</p>

*/"/>
    <method name="protected boolean chooseContext(com.trolltech.qt.opengl.QGLContext shareContext__0)" doc="/**
<p>This semi-internal function is called by create(). It creates a system-dependent OpenGL handle that matches the format() of <i>shareContext</i> as closely as possible.</p>
<p>On Windows, it calls the virtual function choosePixelFormat(), which finds a matching pixel format identifier. On X11, it calls the virtual function chooseVisual() which finds an appropriate X visual. On other platforms it may work differently.</p>

*/"/>
    <method name="public boolean create(com.trolltech.qt.opengl.QGLContext shareContext__0)" doc="/**
<p>Creates the GL context. Returns true if it was successful in creating a valid GL rendering context on the paint device specified in the constructor; otherwise returns false (i.e. the context is invalid).</p>
<p>After successful creation, format() returns the set of features of the created GL rendering context.</p>
<p>If <i>shareContext</i> points to a valid QGLContext, this method will try to establish OpenGL display list sharing between this context and the <i>shareContext</i>. Note that this may fail if the two contexts have different formats. Use isSharing() to see if sharing succeeded.</p>
<p><b>Warning:</b> Implementation note: initialization of C++ class members usually takes place in the class constructor. QGLContext is an exception because it must be simple to customize. The virtual functions chooseContext() (and chooseVisual() for X11) can be reimplemented in a subclass to select a particular context. The problem is that virtual functions are not properly called during construction (even though this is correct C++) because C++ constructs class hierarchies from the bottom up. For this reason we need a create() function.</p>

*/"/>
    <method name="public void doneCurrent()" doc="/**
<p>Makes no GL context the current context. Normally, you do not need to call this function; QGLContext calls it as necessary.</p>

*/"/>
    <method name="public void makeCurrent()" doc="/**
<p>Makes this context the current OpenGL rendering context. All GL functions you call operate on this context until another context is made current.</p>
<p>In some very rare cases the underlying call may fail. If this occurs an error message is output to stderr.</p>

*/"/>
    <method name="public void swapBuffers()" doc="/**
<p>Swaps the screen contents with an off-screen buffer. Only works if the context is in double buffer mode.</p>

*/"/>
    <method name="public native static com.trolltech.qt.opengl.QGLContext currentContext()" doc="/**
<p>Returns the current context, i.e. the context to which any OpenGL commands will currently be directed. Returns 0 if no context is current.</p>

*/"/>
    <method name="public native static void setTextureCacheLimit(int size__0)" doc="/**
<p>This function sets the limit for the texture cache to <i>size</i>, expressed in kilobytes.</p>
<p>By default, the cache limit is approximately 64 MB.</p>

*/"/>
    <method name="public native static int textureCacheLimit()" doc="/**
<p>Returns the current texture cache limit in kilobytes.</p>

*/"/>
    <method name="protected native static com.trolltech.qt.opengl.QGLContext currentCtx()"/>
    <method name="protected final static void setCurrentCtx(com.trolltech.qt.opengl.QGLContext currentCtx)"/>
</class>
