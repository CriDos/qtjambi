<class name="QWidget" doc="/**
<p>The QWidget class is the base class of all user interface objects.</p>
<p>The widget is the atom of the user interface: it receives mouse, keyboard and other events from the window system, and paints a representation of itself on the screen. Every widget is rectangular, and they are sorted in a Z-order. A widget is clipped by its parent and by the widgets in front of it.</p>
<p>A widget that isn't embedded in a parent widget is called a window. Usually, windows have a frame and a title bar, although it is also possible to create windows without such decoration using suitable window flags). In Qt, QMainWindow and the various subclasses of QDialog are the most common window types.</p>
<p>Every widget's constructor accepts one or two standard arguments:</p>
<ol type=&quote;1&quote;>
<li><tt>QWidget *parent = 0</tt> is the parent of the new widget. If it is 0 (the default), the new widget will be a window. If not, it will be a child of <i>parent</i>, and be constrained by <i>parent</i>'s geometry (unless you specify Qt::Window as window flag).</li>
<li><tt>Qt::WindowFlags f = 0</tt> (where available) sets the window flags; the default is suitable for almost all widgets, but to get, for example, a window without a window system frame, you must use special flags.</li>
</ol>
<p>QWidget has many member functions, but some of them have little direct functionality; for example, QWidget has a font property, but never uses this itself. There are many subclasses which provide real functionality, such as QLabel, QPushButton, QListWidget, and QTabWidget.</p>
<a name=&quote;top-level-and-child-widgets&quote;></a>
<h3>Top-Level and Child Widgets</h3>
<p>A widget without a parent widget is always an independent window (top-level widget). For these widgets, setWindowTitle() and setWindowIcon() set the title bar and icon respectively.</p>
<p>Non-window widgets are child widgets, and are displayed within their parent widgets. Most widgets in Qt are mainly useful as child widgets. For example, it is possible to display a button as a top-level window, but most people prefer to put their buttons inside other widgets, such as QDialog.</p>
<p align=&quote;center&quote;><font color=&quote;red&quote;>[Missing image parent-child-widgets.png]</font></p><p>The above diagram shows a QGroupBox widget being used to hold various child widgets in a layout provided by QGridLayout. The QLabel child widgets have been outlined to indicate their full sizes.</p>
<p>If you want to use a QWidget to hold child widgets you will usually want to add a layout to the parent QWidget. See Layout Classes for more information about these.</p>
<a name=&quote;composite-widgets&quote;></a>
<h3>Composite Widgets</h3>
<p>When a widgets is used as a container to group a number of child widgets, it is known as a composite widget. These can be created by constructing a widget with the required visual properties - a QFrame, for example - and adding child widgets to it, usually managed by a layout. The above diagram shows such a composite widget that was created using Qt Designer.</p>
<p>Composite widgets can also be created by subclassing a standard widget, such as QWidget or QFrame, and adding the necessary layout and child widgets in the constructor of the subclass. Many of the examples provided with Qt use this approach, and it is also covered in the Qt Tutorial.</p>
<a name=&quote;custom-widgets-and-painting&quote;></a>
<h3>Custom Widgets and Painting</h3>
<p>Since QWidget is a subclass of QPaintDevice, subclasses can be used to display custom content that is composed using a series of painting operations with an instance of the QPainter class. This approach contrasts with the canvas-style approach used by the Graphics View Framework where items are added to a scene by the application and are rendered by the framework itself.</p>
<p>Each widget performs all painting operations from within its paintEvent() function. This is called whenever the widget needs to be redrawn, either as a result of some external change or when requested by the application.</p>
<p>The Analog Clock example shows how a simple widget can handle paint events.</p>
<a name=&quote;size-hints-and-size-policies&quote;></a>
<h3>Size Hints and Size Policies</h3>
<p>When implementing a new widget, it is almost always useful to reimplement sizeHint() to provide a reasonable default size for the widget and to set the correct size policy with setSizePolicy().</p>
<p>By default, composite widgets which do not provide a size hint will be sized according to the space requirements of their child widgets.</p>
<p>The size policy lets you supply good default behavior for the layout management system, so that other widgets can contain and manage yours easily. The default size policy indicates that the size hint represents the preferred size of the widget, and this is often good enough for many widgets.</p>
<a name=&quote;events&quote;></a>
<h3>Events</h3>
<p>Widgets respond to events that are typically caused by user actions. Qt delivers events to widgets by calling specific event handler functions with instances of QEvent subclasses containing information about each event.</p>
<p>If your widget only contains child widgets, you probably do not need to implement any event handlers. If you want to detect a mouse click in a child widget call the child's underMouse() function inside the widget's mousePressEvent().</p>
<p>The Scribble example implements a wider set of events to handle mouse movement, button presses, and window resizing.</p>
<p>You will need to supply the behavior and content for your own widgets, but here is a brief overview of the events that are relevant to QWidget, starting with the most common ones:</p>
<ul>
<li>paintEvent() is called whenever the widget needs to be repainted. Every widget which displays custom content must implement it. Painting using a QPainter can only take place in a paintEvent() or a function called by a paintEvent().</li>
<li>resizeEvent() is called when the widget has been resized.</li>
<li>mousePressEvent() is called when a mouse button is pressed when the mouse is inside it, or when it has grabbed the mouse using grabMouse().</li>
<li>mouseReleaseEvent() is called when a mouse button is released. A widget receives mouse release events when it has received the corresponding mouse press event. This means that if the user presses the mouse inside <i>your</i> widget, then drags the mouse to somewhere else before releasing the mouse button, <i>your</i> widget receives the release event. There is one exception: if a popup menu appears while the mouse button is held down, this popup immediately steals the mouse events.</li>
<li>mouseDoubleClickEvent() is called when the user double clicks in the widget. If the user double-clicks, the widget receives a mouse press event, a mouse release event and finally this event instead of a second mouse press event. (Some mouse move events may also be received if the user doesn't hold the mouse steady during this operation.) It is <i>not possible</i> to distinguish a click from a double click until the second click arrives. (This is one reason why most GUI books recommend that double clicks be an extension of single clicks, rather than trigger a different action.)</li>
</ul>
<p>Widgets that accept keyboard input need to reimplement a few more event handlers:</p>
<ul>
<li>keyPressEvent() is called whenever a key is pressed, and again when a key has been held down long enough for it to auto-repeat. Note that the <b>Tab</b> and <b>Shift+Tab</b> keys are only passed to the widget if they are not used by the focus-change mechanisms. To force those keys to be processed by your widget, you must reimplement QWidget::event().</li>
<li>focusInEvent() is called when the widget gains keyboard focus (assuming you have called setFocusPolicy()). Well written widgets indicate that they own the keyboard focus in a clear but discreet way.</li>
<li>focusOutEvent() is called when the widget loses keyboard focus.</li>
</ul>
<p>Some widgets will also need to reimplement some of the less common event handlers:</p>
<ul>
<li>mouseMoveEvent() is called whenever the mouse moves while a button is held down. This can be useful during drag and drop operations. If you call setMouseTracking(true), you get mouse move events even when no buttons are held down. (See also the guide to Drag and Drop.)</li>
<li>keyReleaseEvent() is called whenever a key is released, and also while it is held down if the key is auto-repeating. In that case the widget receives a pair of key release and key press events for every repeat. Note that the <b>Tab</b> and <b>Shift+Tab</b> keys are only passed to the widget if they are not used by the focus-change mechanisms. To force those keys to be processed by your widget, you must reimplement QWidget::event().</li>
<li>wheelEvent() is called whenever the user turns the mouse wheel while the widget has the focus.</li>
<li>enterEvent() is called when the mouse enters the widget's screen space. (This excludes screen space owned by any children of the widget.)</li>
<li>leaveEvent() is called when the mouse leaves the widget's screen space. Note that if the mouse enters a child widget it will not cause a leaveEvent.</li>
<li>moveEvent() is called when the widget has been moved relative to its parent.</li>
<li>closeEvent() is called when the user closes the widget (or when close() is called).</li>
</ul>
<p>There are also some rather obscure events described in the QEvent::Type documentation. You need to reimplement event() directly to handle these. The default implementation of event() handles <b>Tab</b> and <b>Shift+Tab</b> (to move the keyboard focus), and passes on most other events to one of the more specialized handlers above.</p>
<p>Events and the mechanism used to deliver them are covered in the Events and Event Filters document.</p>
<a name=&quote;groups-of-functions-and-properties&quote;></a>
<h3>Groups of Functions and Properties</h3>
<p><table align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<thead><tr valign=&quote;top&quote; class=&quote;qt-style&quote;><th>Context</th><th>Functions and Properties</th></tr></thead>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>Window functions</td><td>show(), hide(), raise(), lower(), close().</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>Top-level windows</td><td>windowModified, windowTitle, windowIcon, windowIconText, isActiveWindow, activateWindow(), minimized, showMinimized(), maximized, showMaximized(), fullScreen, showFullScreen(), showNormal().</td></tr>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>Window contents</td><td>update(), repaint(), scroll().</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>Geometry</td><td>pos, x(), y(), rect, size, width(), height(), move(), resize(), sizePolicy, sizeHint(), minimumSizeHint(), updateGeometry(), layout(), frameGeometry, geometry, childrenRect, childrenRegion, adjustSize(), mapFromGlobal(), mapToGlobal(), mapFromParent(), mapToParent(), maximumSize, minimumSize, sizeIncrement, baseSize, setFixedSize()</td></tr>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>Mode</td><td>visible, isVisibleTo(), enabled, isEnabledTo(), modal, isWindow(), mouseTracking, updatesEnabled, visibleRegion().</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>Look and feel</td><td>style(), setStyle(), styleSheet, cursor, font, palette, backgroundRole(), setBackgroundRole(), fontInfo(), fontMetrics().</td></tr>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>Keyboard focus functions</td><td>focus, focusPolicy, setFocus(), clearFocus(), setTabOrder(), setFocusProxy(), focusNextChild(), focusPreviousChild().</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>Mouse and keyboard grabbing</td><td>grabMouse(), releaseMouse(), grabKeyboard(), releaseKeyboard(), mouseGrabber(), keyboardGrabber().</td></tr>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>Event handlers</td><td>event(), mousePressEvent(), mouseReleaseEvent(), mouseDoubleClickEvent(), mouseMoveEvent(), keyPressEvent(), keyReleaseEvent(), focusInEvent(), focusOutEvent(), wheelEvent(), enterEvent(), leaveEvent(), paintEvent(), moveEvent(), resizeEvent(), closeEvent(), dragEnterEvent(), dragMoveEvent(), dragLeaveEvent(), dropEvent(), childEvent(), showEvent(), hideEvent(), customEvent(). changeEvent(),</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>System functions</td><td>parentWidget(), window(), setParent(), winId(), find(), metric().</td></tr>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>Interactive help</td><td>setToolTip(), setWhatsThis()</td></tr>
</table></p>
<a name=&quote;widget-style-sheets&quote;></a>
<h3>Widget Style Sheets</h3>
<p>In addition to the standard widget styles for each platform, widgets can also be styled according to rules specified in a style sheet. This feature enables you to customize the appearance of specific widgets to provide visual cues to users about their purpose; for example, a button could be styled in a particular way to indicate that it performs a destructive action.</p>
<p>The use of widgets style sheets is described in more detail in Customizing Widgets using Style Sheets.</p>
<a name=&quote;transparency-and-double-buffering&quote;></a>
<h3>Transparency and Double Buffering</h3>
<p>From Qt 4.0, QWidget automatically double-buffers its painting, so there's no need to write double-buffering code in paintEvent() to avoid flicker. Additionally, it became possible for widgets to propagate their contents to children, in order to enable transparency effects, by setting the Qt::WA_ContentsPropagated widget attribute - this is now deprecated in Qt 4.1.</p>
<p>In Qt 4.1, the contents of parent widgets are propagated by default to each of their children. Custom widgets can be written to take advantage of this feature by only updating irregular regions (to create non-rectangular child widgets), or by using painting with colors that have less than the full alpha component. The following diagram shows how attributes and properties of a custom widget can be fine-tuned to achieve different effects.</p>
<p align=&quote;center&quote;><font color=&quote;red&quote;>[Missing image propagation-custom.png]</font></p><p>In the above diagram, a semi-transparent rectangular child widget with an area removed is constructed and added to a parent widget (a QLabel showing a pixmap) then different properties and widget attributes are set to achieve different effects:</p>
<ul>
<li>The left widget has no additional properties or widget attributes set. This default state suits most custom widgets that use transparency or are irregularly-shaped, and that do not paint over their entire area with an opaque brush.</li>
<li>The center widget has the autoFillBackground property set. This property is used with custom widgets that rely on the widget to supply a default background, and do not paint over their entire area with an opaque brush.</li>
<li>The right widget has the Qt::WA_OpaquePaintEvent widget attribute set. This indicates that the widget will paint over its entire area with opaque colors. The widget's area will initially be <i>uninitialized</i> (represented in the diagram by a red diagonal grid pattern that shines through the overpainted area). This is useful for widgets that need to paint their own specialized contents quickly and that do not need a default filled background.</li>
</ul>
<p>For rapidly updating custom widgets with simple background colors, such as real-time plotting or graphing widgets, it is better to define a suitable background color (using setBackgroundRole() with the QPalette::Window role), set the autoFillBackground property, and only implement the necessary drawing functionality in the widget's paintEvent().</p>
<p>For rapidly updating custom widgets that constantly paint over their entire areas with opaque content, such as video streaming widgets, it is better to set the widget's Qt::WA_OpaquePaintEvent, avoiding any unnecessary overhead associated with repainting the widget's background.</p>
<p>If a widget has both the Qt::WA_OpaquePaintEvent widget attribute <i>and</i> the autoFillBackground property set, the Qt::WA_OpaquePaintEvent attribute takes precedence. You should choose just one of these depending on your requirements.</p>
<p>In Qt 4.1, the contents of parent widgets are also propagated to standard Qt widgets. This can lead to some unexpected results if the parent widget is decorated in a non-standard way, as shown in the diagram below.</p>
<p align=&quote;center&quote;><font color=&quote;red&quote;>[Missing image propagation-standard.png]</font></p><p>The scope for customizing the painting behavior of standard Qt widgets, without resorting to subclassing, is slightly less than that possible for custom widgets. Usually, the desired appearance of a standard widget can be achieved by setting its autoFillBackground property.</p>

*/">
    <method name="public QWidget(com.trolltech.qt.gui.QWidget parent__0, com.trolltech.qt.core.Qt.WindowFlags f__1)" doc="/**
<p>Constructs a widget which is a child of <i>parent</i>, with widget flags set to <i>f</i>.</p>
<p>If <i>parent</i> is 0, the new widget becomes a window. If <i>parent</i> is another widget, this widget becomes a child window inside <i>parent</i>. The new widget is deleted when its <i>parent</i> is deleted.</p>
<p>The widget flags argument, <i>f</i>, is normally 0, but it can be set to customize the frame of a window (i.e. <i>parent</i> must be 0). To customize the frame, use a value composed from the bitwise OR of any of the window flags.</p>
<p>If you add a child widget to an already visible widget you must explicitly show the child to make it visible.</p>
<p>Note that the X11 version of Qt may not be able to deliver all combinations of style flags on all systems. This is because on X11, Qt can only ask the window manager, and the window manager can override the application's settings. On Windows, Qt can set whatever flags you want.</p>

*/"/>
    <method name="public final boolean acceptDrops()"/>
    <method name="public final java.lang.String accessibleDescription()"/>
    <method name="public final java.lang.String accessibleName()"/>
    <method name="public final java.util.List&lt;com.trolltech.qt.gui.QAction&gt; actions()" doc="/**
<p>Returns the (possibly empty) list of this widget's actions.</p>

*/"/>
    <method name="public final void activateWindow()" doc="/**
<p>Sets the top-level widget containing this widget to be the active window.</p>
<p>An active window is a visible top-level window that has the keyboard input focus.</p>
<p>This function performs the same operation as clicking the mouse on the title bar of a top-level window. On X11, the result depends on the Window Manager. If you want to ensure that the window is stacked on top as well you should also call raise(). Note that the window must be visible, otherwise activateWindow() has no effect.</p>
<p>On Windows, if you are calling this when the application is not currently the active one then it will not make it the active window. It will change the color of the taskbar entry to indicate that the window has changed in some way. This is because Microsoft do not allow an application to interrupt what the user is currently doing in another application.</p>

*/"/>
    <method name="public final void addActions(java.util.List&lt;com.trolltech.qt.gui.QAction&gt; actions__0)" doc="/**
<p>Appends the actions <i>actions</i> to this widget's list of actions.</p>

*/"/>
    <method name="public final void adjustSize()" doc="/**
<p>Adjusts the size of the widget to fit the contents.</p>
<p>Uses sizeHint() if valid (i.e if the size hint's width and height are &gt;= 0); otherwise sets the size to the children rectangle that covers all child widgets (the union of all child widget rectangles). For top-level widgets, the screen size is also taken into account.</p>

*/"/>
    <method name="public final boolean autoFillBackground()"/>
    <method name="public final com.trolltech.qt.gui.QPalette.ColorRole backgroundRole()" doc="/**
<p>Returns the background role of the widget.</p>
<p>The background role defines the brush from the widget's palette that is used to render the background.</p>
<p>If no explicit background role is set, the widget inherts its parent widget's background role.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QSize baseSize()"/>
    <method name="public final com.trolltech.qt.gui.QWidget childAt(com.trolltech.qt.core.QPoint p__0)" doc="/**
<p>Returns the visible child widget at point <i>p</i> in the widget's own coordinate system.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QWidget childAt(int x__0, int y__1)" doc="/**
<p>Returns the visible child widget at the position (<i>x</i>, <i>y</i>) in the widget's coordinate system. If there is no visible child widget at the specified position, the function returns 0.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QRect childrenRect()"/>
    <method name="public final com.trolltech.qt.gui.QRegion childrenRegion()"/>
    <method name="public final void clearFocus()" doc="/**
<p>Takes keyboard input focus from the widget.</p>
<p>If the widget has active focus, a focus out event is sent to this widget to tell it that it is about to lose the focus.</p>
<p>This widget must enable focus setting in order to get the keyboard input focus, i.e. it must call setFocusPolicy().</p>

*/"/>
    <method name="public final void clearMask()" doc="/**
<p>Removes any mask set by setMask().</p>

*/"/>
    <method name="public final boolean close()" doc="/**
<p>Closes this widget. Returns true if the widget was closed; otherwise returns false.</p>
<p>First it sends the widget a QCloseEvent. The widget is hidden if it accepts the close event. If it ignores the event, nothing happens. The default implementation of QWidget::closeEvent() accepts the close event.</p>
<p>If the widget has the Qt::WA_DeleteOnClose flag, the widget is also deleted. A close events is delivered to the widget no matter if the widget is visible or not.</p>
<p>The QApplication::lastWindowClosed() signal is emitted when the last visible primary window (i.e. window with no parent) with the Qt::WA_QuitOnClose attribute set is closed. By default this attribute is set for all widgets except transient windows such as splash screens, tool windows, and popup menus.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QRect contentsRect()" doc="/**
<p>Returns the area inside the widget's margins.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.Qt.ContextMenuPolicy contextMenuPolicy()"/>
    <method name="public final void createWinId()" doc="/**
<p>Ensures that the widget has a window system identifier, i.e. that it is known to the windowing system.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QCursor cursor()"/>
    <method name="protected final void destroy(boolean destroyWindow__0, boolean destroySubWindows__1)" doc="/**
<p>Frees up window system resources. Destroys the widget window if <i>destroyWindow</i> is true.</p>
<p>destroy() calls itself recursively for all the child widgets, passing <i>destroySubWindows</i> for the <i>destroyWindow</i> parameter. To have more control over destruction of subwidgets, destroy subwidgets selectively first.</p>
<p>This function is usually called from the QWidget destructor.</p>

*/"/>
    <method name="public final void ensurePolished()" doc="/**
<p>Ensures that the widget has been polished by QStyle (i.e., has a proper font and palette).</p>
<p>QWidget calls this function after it has been fully constructed but before it is shown the very first time. You can call this function if you want to ensure that the widget is polished before doing an operation, e.g., the correct font size might be needed in the widget's sizeHint() reimplementation. Note that this function <i>is</i> called from the default implementation of sizeHint().</p>
<p>Polishing is useful for final initialization that must happen after all constructors (from base classes as well as from subclasses) have been called.</p>
<p>If you need to change some settings when a widget is polished, reimplement event() and handle the QEvent::Polish event type.</p>
<p><b>Note:</b> The function is declared const so that it can be called from other const functions (e.g., sizeHint()).</p>

*/"/>
    <method name="protected final boolean focusNextChild()" doc="/**
<p>Finds a new widget to give the keyboard focus to, as appropriate for <b>Tab</b>, and returns true if it can find a new widget, or false if it can't.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.Qt.FocusPolicy focusPolicy()"/>
    <method name="protected final boolean focusPreviousChild()" doc="/**
<p>Finds a new widget to give the keyboard focus to, as appropriate for <b>Shift+Tab</b>, and returns true if it can find a new widget, or false if it can't.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QWidget focusProxy()" doc="/**
<p>Returns the focus proxy, or 0 if there is no focus proxy.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QWidget focusWidget()" doc="/**
<p>Returns the last child of this widget that setFocus had been called on. For top level widgets this is the widget that will get focus in case this window gets activated</p>
<p>This is not the same as QApplication::focusWidget(), which returns the focus widget in the currently active window.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QFontInfo fontInfo()" doc="/**
<p>Returns the font info for the widget's current font. Equivalent to QFontInto(widget-&gt;font()).</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QFontMetrics fontMetrics()" doc="/**
<p>Returns the font metrics for the widget's current font. Equivalent to QFontMetrics(widget-&gt;font()).</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QPalette.ColorRole foregroundRole()" doc="/**
<p>Returns the foreground role.</p>
<p>The foreground role defines the color from the widget's palette that is used to draw the foreground.</p>
<p>If no explicit foreground role is set, the function returns a role that contrasts with the background role.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QRect frameGeometry()"/>
    <method name="public final com.trolltech.qt.core.QSize frameSize()"/>
    <method name="public final com.trolltech.qt.core.QRect geometry()"/>
    <method name="public final void getContentsMargins(com.trolltech.qt.QNativePointer left__0, com.trolltech.qt.QNativePointer top__1, com.trolltech.qt.QNativePointer right__2, com.trolltech.qt.QNativePointer bottom__3)" doc="/**
<p>Returns the widget's contents margins for <i>left</i>, <i>top</i>, <i>right</i>, and <i>bottom</i>.</p>

*/"/>
    <method name="public final void grabKeyboard()" doc="/**
<p>Grabs the keyboard input.</p>
<p>This widget receives all keyboard events until releaseKeyboard() is called; other widgets get no keyboard events at all. Mouse events are not affected. Use grabMouse() if you want to grab that.</p>
<p>The focus widget is not affected, except that it doesn't receive any keyboard events. setFocus() moves the focus as usual, but the new focus widget receives keyboard events only after releaseKeyboard() is called.</p>
<p>If a different widget is currently grabbing keyboard input, that widget's grab is released first.</p>

*/"/>
    <method name="public final void grabMouse(com.trolltech.qt.gui.QCursor arg__0)" doc="/**
<p>Grabs the mouse input and changes the cursor shape.</p>
<p>The cursor will assume shape <i>cursor</i> (for as long as the mouse focus is grabbed) and this widget will be the only one to receive mouse events until releaseMouse() is called().</p>
<p><b>Warning:</b> Grabbing the mouse might lock the terminal.</p>

*/"/>
    <method name="public final void grabMouse()" doc="/**
<p>Grabs the mouse input.</p>
<p>This widget receives all mouse events until releaseMouse() is called; other widgets get no mouse events at all. Keyboard events are not affected. Use grabKeyboard() if you want to grab that.</p>
<p><b>Warning:</b> Bugs in mouse-grabbing applications very often lock the terminal. Use this function with extreme caution, and consider using the <tt>-nograb</tt> command line option while debugging.</p>
<p>It is almost never necessary to grab the mouse when using Qt, as Qt grabs and releases it sensibly. In particular, Qt grabs the mouse when a mouse button is pressed and keeps it until the last button is released.</p>
<p>Note that only visible widgets can grab mouse input. If isVisible() returns false for a widget, that widget cannot call grabMouse().</p>
<p>focusWidget()</p>

*/"/>
    <method name="public final int grabShortcut(com.trolltech.qt.gui.QKeySequence key__0, com.trolltech.qt.core.Qt.ShortcutContext context__1)" doc="/**
<p>Adds a shortcut to Qt's shortcut system that watches for the given <i>key</i> sequence in the given <i>context</i>. If the <i>context</i> is not <tt>OnApplication</tt>, the shortcut is local to this widget; otherwise it applies to the application as a whole.</p>
<p>If the same <i>key</i> sequence has been grabbed by several widgets, when the <i>key</i> sequence occurs a QEvent::Shortcut event is sent to all the widgets to which it applies in a non-deterministic order, but with the ``ambiguous'' flag set to true.</p>
<p><b>Warning:</b> You should not normally need to use this function; instead create QActions with the shortcut key sequences you require (if you also want equivalent menu options and toolbar buttons), or create QShortcuts if you just need key sequences. Both QAction and QShortcut handle all the event filtering for you, and provide signals which are triggered when the user triggers the key sequence, so are much easier to use than this low-level function.</p>

*/"/>
    <method name="public final boolean hasFocus()"/>
    <method name="public final boolean hasMouseTracking()"/>
    <method name="public final void hide()" doc="/**
<p>Hides the widget. This function is equivalent to setVisible(false).</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QInputContext inputContext()" doc="/**
<p>This function returns the QInputContext for this widget. By default the input context is inherited from the widgets parent. For toplevels it is inherited from QApplication.</p>
<p>You can override this and set a special input context for this widget by using the setInputContext() method.</p>

*/"/>
    <method name="public final void insertAction(com.trolltech.qt.gui.QAction before__0, com.trolltech.qt.gui.QAction action__1)" doc="/**
<p>Inserts the action <i>action</i> to this widget's list of actions, before the action <i>before</i>. It appends the action if <i>before</i> is 0 or <i>before</i> is not a valid action for this widget.</p>
<p>A QWidget should only have one of each action.</p>

*/"/>
    <method name="public final void insertActions(com.trolltech.qt.gui.QAction before__0, java.util.List&lt;com.trolltech.qt.gui.QAction&gt; actions__1)" doc="/**
<p>Inserts the actions <i>actions</i> to this widget's list of actions, before the action <i>before</i>. It appends the action if <i>before</i> is 0 or <i>before</i> is not a valid action for this widget.</p>
<p>A QWidget can have at most one of each action.</p>

*/"/>
    <method name="public final long internalWinId()" doc="/**
<p>Returns the window system identifier of the widget, or 0 if the widget is not created yet.</p>

*/"/>
    <method name="public final boolean isActiveWindow()"/>
    <method name="public final boolean isAncestorOf(com.trolltech.qt.gui.QWidget child__0)" doc="/**
<p>Returns true if this widget is a parent, (or grandparent and so on to any level), of the given <i>child</i>, and both widgets are within the same window; otherwise returns false.</p>

*/"/>
    <method name="public final boolean isEnabled()"/>
    <method name="public final boolean isEnabledTo(com.trolltech.qt.gui.QWidget arg__0)" doc="/**
<p>Returns true if this widget would become enabled if <i>ancestor</i> is enabled; otherwise returns false.</p>
<p>This is the case if neither the widget itself nor every parent up to but excluding <i>ancestor</i> has been explicitly disabled.</p>
<p>isEnabledTo(0) is equivalent to isEnabled().</p>

*/"/>
    <method name="public final boolean isEnabledToTLW()" doc="/**
<p>This function is deprecated. It is equivalent to isEnabled()</p>

*/"/>
    <method name="public final boolean isFullScreen()"/>
    <method name="public final boolean isHidden()" doc="/**
<p>Returns true if the widget is hidden, otherwise returns false.</p>
<p>A hidden widget will only become visible when show() is called on it. It will not be automatically shown when the parent is shown.</p>
<p>To check visiblity, use !isVisible() instead (notice the exclamation mark).</p>
<p>isHidden() implies !isVisible(), but a widget can be not visible and not hidden at the same time. This is the case for widgets that are children of widgets that are not visible.</p>
<p>Widgets are hidden if they were created as independent windows or as children of visible widgets, or if hide() or setVisible(false) was called.</p>

*/"/>
    <method name="public final boolean isLeftToRight()"/>
    <method name="public final boolean isMaximized()"/>
    <method name="public final boolean isMinimized()"/>
    <method name="public final boolean isModal()"/>
    <method name="public final boolean isRightToLeft()"/>
    <method name="public final boolean isTopLevel()" doc="/**
<p>Use isWindow() instead.</p>

*/"/>
    <method name="public final boolean isVisible()"/>
    <method name="public final boolean isVisibleTo(com.trolltech.qt.gui.QWidget arg__0)" doc="/**
<p>Returns true if this widget would become visible if <i>ancestor</i> is shown; otherwise returns false.</p>
<p>The true case occurs if neither the widget itself nor any parent up to but excluding <i>ancestor</i> has been explicitly hidden.</p>
<p>This function will still return true if the widget is obscured by other windows on the screen, but could be physically visible if it or they were to be moved.</p>
<p>isVisibleTo(0) is identical to isVisible().</p>

*/"/>
    <method name="public final boolean isWindow()" doc="/**
<p>Returns true if the widget is an independent window, otherwise returns false.</p>
<p>A window is a widget that isn't visually the child of any other widget and that usually has a frame and a window title.</p>
<p>A window can have a parent widget. It will then be grouped with its parent and deleted when the parent is deleted, minimized when the parent is minimized etc. If supported by the window manager, it will also have a common taskbar entry with its parent.</p>
<p>QDialog and QMainWindow widgets are by default windows, even if a parent widget is specified in the constructor. This behavior is specified by the Qt::Window flag.</p>

*/"/>
    <method name="public final boolean isWindowModified()"/>
    <method name="public final com.trolltech.qt.gui.QLayout layout()" doc="/**
<p>Returns the layout manager that is installed on this widget, or 0 if no layout manager is installed.</p>
<p>The layout manager sets the geometry of the widget's children that have been added to the layout.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.Qt.LayoutDirection layoutDirection()"/>
    <method name="public final void lower()" doc="/**
<p>Lowers the widget to the bottom of the parent widget's stack.</p>
<p>After this call the widget will be visually behind (and therefore obscured by) any overlapping sibling widgets.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QPoint mapFrom(com.trolltech.qt.gui.QWidget arg__0, com.trolltech.qt.core.QPoint arg__1)" doc="/**
<p>Translates the widget coordinate <i>pos</i> from the coordinate system of <i>parent</i> to this widget's coordinate system. The <i>parent</i> must not be 0 and must be a parent of the calling widget.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QPoint mapFromGlobal(com.trolltech.qt.core.QPoint arg__0)" doc="/**
<p>Translates the global screen coordinate <i>pos</i> to widget coordinates.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QPoint mapFromParent(com.trolltech.qt.core.QPoint arg__0)" doc="/**
<p>Translates the parent widget coordinate <i>pos</i> to widget coordinates.</p>
<p>Same as mapFromGlobal() if the widget has no parent.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QPoint mapTo(com.trolltech.qt.gui.QWidget arg__0, com.trolltech.qt.core.QPoint arg__1)" doc="/**
<p>Translates the widget coordinate <i>pos</i> to the coordinate system of <i>parent</i>. The <i>parent</i> must not be 0 and must be a parent of the calling widget.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QPoint mapToGlobal(com.trolltech.qt.core.QPoint arg__0)" doc="/**
<p>Translates the widget coordinate <i>pos</i> to global screen coordinates. For example, <tt>mapToGlobal(QPoint(0,0))</tt> would give the global coordinates of the top-left pixel of the widget.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QPoint mapToParent(com.trolltech.qt.core.QPoint arg__0)" doc="/**
<p>Translates the widget coordinate <i>pos</i> to a coordinate in the parent widget.</p>
<p>Same as mapToGlobal() if the widget has no parent.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QRegion mask()" doc="/**
<p>Returns the mask currently set on a widget. If no mask is set the return value will be an empty region.</p>

*/"/>
    <method name="public final int maximumHeight()"/>
    <method name="public final com.trolltech.qt.core.QSize maximumSize()"/>
    <method name="public final int maximumWidth()"/>
    <method name="public final int minimumHeight()"/>
    <method name="public final com.trolltech.qt.core.QSize minimumSize()"/>
    <method name="public final int minimumWidth()"/>
    <method name="public final com.trolltech.qt.gui.QWidget nextInFocusChain()" doc="/**
<p>Returns the next widget in this widget's focus chain.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QRect normalGeometry()"/>
    <method name="public final void overrideWindowFlags(com.trolltech.qt.core.Qt.WindowFlags type__0)" doc="/**
<p>Sets the window flags for the widget to <i>flags</i>, <i>without</i> telling the window system.</p>
<p><b>Warning:</b> Do not call this function unless you really know what you're doing.</p>

*/"/>
    <method name="public final void overrideWindowState(com.trolltech.qt.core.Qt.WindowStates state__0)" doc="/**
<p>The function sets the window state on child widgets similar to setWindowState(). The difference is that the window state changed event has the isOverride() flag set. It exists mainly to keep Q3Workspace working.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QPalette palette()"/>
    <method name="public final com.trolltech.qt.gui.QWidget parentWidget()" doc="/**
<p>Returns the parent of this widget, or 0 if it does not have any parent widget.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QPoint pos()"/>
    <method name="public final void raise()" doc="/**
<p>Raises this widget to the top of the parent widget's stack.</p>
<p>After this call the widget will be visually in front of any overlapping sibling widgets.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QRect rect()"/>
    <method name="public final void releaseKeyboard()" doc="/**
<p>Releases the keyboard grab.</p>

*/"/>
    <method name="public final void releaseMouse()" doc="/**
<p>Releases the mouse grab.</p>

*/"/>
    <method name="public final void releaseShortcut(int id__0)" doc="/**
<p>Removes the shortcut with the given <i>id</i> from Qt's shortcut system. The widget will no longer receive QEvent::Shortcut events for the shortcut's key sequence (unless it has other shortcuts with the same key sequence).</p>
<p><b>Warning:</b> You should not normally need to use this function since Qt's shortcut system removes shortcuts automatically when their parent widget is destroyed. It is best to use QAction or QShortcut to handle shortcuts, since they are easier to use than this low-level function. Note also that this is an expensive operation.</p>

*/"/>
    <method name="public final void removeAction(com.trolltech.qt.gui.QAction action__0)" doc="/**
<p>Removes the action <i>action</i> from this widget's list of actions.</p>

*/"/>
    <method name="protected final void resetInputContext()" doc="/**
<p>This function can be called on the widget that currently has focus to reset the input method operating on it.</p>

*/"/>
    <method name="public final boolean restoreGeometry(com.trolltech.qt.core.QByteArray geometry__0)" doc="/**
<p>Restores the geometry and state top-level widgets stored in the byte array <i>geometry</i>. Returns true on success; otherwise returns false.</p>
<p>If the restored geometry is off-screen, it will be modified to be inside the the available screen geometry.</p>
<p>To restore geometry saved using QSettings, you can use code like this:</p>
<pre>    QSettings settings(&quot;MyCompany&quot;, &quot;MyApp&quot;);
    myWidget-&gt;restoreGeometry(settings.value(&quot;myWidget/geometry&quot;).toByteArray());</pre>
<p>See the Window Geometry documentation for an overview of geometry issues with windows.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QByteArray saveGeometry()" doc="/**
<p>Saves the current geometry and state for top-level widgets.</p>
<p>To save the geometry when the window closes, you can implement a close event like this:</p>
<pre>    void MyWidget::closeEvent(QCloseEvent *event)
    {
        QSettings settings(&quot;MyCompany&quot;, &quot;MyApp&quot;);
        settings.setValue(&quot;geometry&quot;, saveGeometry());
        QWidget::closeEvent(event);
    }</pre>
<p>See the Window Geometry documentation for an overview of geometry issues with windows.</p>

*/"/>
    <method name="public final void scroll(int dx__0, int dy__1, com.trolltech.qt.core.QRect arg__2)" doc="/**
<p>This version only scrolls <i>r</i> and does not move the children of the widget.</p>
<p>If <i>r</i> is empty or invalid, the result is undefined.</p>

*/"/>
    <method name="public final void scroll(int dx__0, int dy__1)" doc="/**
<p>Scrolls the widget including its children <i>dx</i> pixels to the right and <i>dy</i> downward. Both <i>dx</i> and <i>dy</i> may be negative.</p>
<p>After scrolling, the widgets will receive paint events for the areas that need to be repainted. For widgets that Qt knows to be opaque, this is only the newly exposed parts. For example, if an opaque widget is scrolled 8 pixels to the left, only an 8-pixel wide stripe at the right edge needs updating.</p>
<p>Since widgets propagate the contents of their parents by default, you need to set the autoFillBackground property, or use setAttribute() to set the Qt::WA_OpaquePaintEvent attribute, to make a widget opaque.</p>
<p>For widgets that use contents propagation, a scroll will cause an update of the entire scroll area.</p>

*/"/>
    <method name="public final void setAcceptDrops(boolean on__0)"/>
    <method name="public final void setAccessibleDescription(java.lang.String description__0)"/>
    <method name="public final void setAccessibleName(java.lang.String name__0)"/>
    <method name="public final void setAttribute(com.trolltech.qt.core.Qt.WidgetAttribute arg__0, boolean on__1)" doc="/**
<p>Sets the attribute <i>attribute</i> on this widget if <i>on</i> is true; otherwise clears the attribute.</p>

*/"/>
    <method name="public final void setAutoFillBackground(boolean enabled__0)"/>
    <method name="public final void setBackgroundRole(com.trolltech.qt.gui.QPalette.ColorRole arg__0)" doc="/**
<p>Sets the background role of the widget to <i>role</i>.</p>
<p>The background role defines the brush from the widget's palette that is used to render the background.</p>
<p>If <i>role</i> is QPalette::NoRole, then the widget inherits its parent's background role.</p>

*/"/>
    <method name="public final void setBaseSize(int basew__0, int baseh__1)" doc="/**
<p>This corresponds to setBaseSize(QSize(<i>basew</i>, <i>baseh</i>)). Sets the widgets base size to width <i>basew</i> and height <i>baseh</i>.</p>

*/"/>
    <method name="public final void setBaseSize(com.trolltech.qt.core.QSize arg__0)"/>
    <method name="public final void setContentsMargins(int left__0, int top__1, int right__2, int bottom__3)" doc="/**
<p>Sets the margins around the contents of the widget to have the sizes <i>left</i>, <i>top</i>, <i>right</i>, and <i>bottom</i>. The margins are used by the layout system, and may be used by subclasses to specify the area to draw in (e.g. excluding the frame).</p>
<p>Changing the margins will trigger a resizeEvent().</p>

*/"/>
    <method name="public final void setContextMenuPolicy(com.trolltech.qt.core.Qt.ContextMenuPolicy policy__0)"/>
    <method name="public final void setCursor(com.trolltech.qt.gui.QCursor arg__0)"/>
    <method name="public final void setDisabled(boolean arg__0)" doc="/**
<p>Disables widget input events if <i>disable</i> is true; otherwise enables input events.</p>
<p>See the enabled documentation for more information.</p>

*/"/>
    <method name="public final void setEnabled(boolean arg__0)"/>
    <method name="public final void setFixedHeight(int h__0)" doc="/**
<p>Sets both the minimum and maximum heights of the widget to <i>h</i> without changing the widths. Provided for convenience.</p>

*/"/>
    <method name="public final void setFixedSize(com.trolltech.qt.core.QSize arg__0)" doc="/**
<p>Sets both the minimum and maximum sizes of the widget to <i>s</i>, thereby preventing it from ever growing or shrinking.</p>
<p>This will override the default size constraints set by QLayout.</p>
<p>Alternatively, if you want the widget to have a fixed size based on its contents, you can call QLayout::setSizeConstraint(QLayout::SetFixedSize);</p>

*/"/>
    <method name="public final void setFixedSize(int w__0, int h__1)" doc="/**
<p>Sets the width of the widget to <i>w</i> and the height to <i>h</i>.</p>

*/"/>
    <method name="public final void setFixedWidth(int w__0)" doc="/**
<p>Sets both the minimum and maximum width of the widget to <i>w</i> without changing the heights. Provided for convenience.</p>

*/"/>
    <method name="public final void setFocus()" doc="/**
<p>Gives the keyboard input focus to this widget (or its focus proxy) if this widget or one of its parents is the active window.</p>

*/"/>
    <method name="public final void setFocus(com.trolltech.qt.core.Qt.FocusReason reason__0)" doc="/**
<p>Gives the keyboard input focus to this widget (or its focus proxy) if this widget or one of its parents is the active window. The <i>reason</i> argument will be passed into any focus event sent from this function, it is used to give an explanation of what caused the widget to get focus.</p>
<p>First, a focus out event is sent to the focus widget (if any) to tell it that it is about to lose the focus. Then a focus in event is sent to this widget to tell it that it just received the focus. (Nothing happens if the focus in and focus out widgets are the same.)</p>
<p>setFocus() gives focus to a widget regardless of its focus policy, but does not clear any keyboard grab (see grabKeyboard()).</p>
<p>Be aware that if the widget is hidden, it will not accept focus.</p>
<p><b>Warning:</b> If you call setFocus() in a function which may itself be called from focusOutEvent() or focusInEvent(), you may get an infinite recursion.</p>
<p>setFocusPolicy() QApplication::focusWidget() grabKeyboard() grabMouse(), {Keyboard Focus}</p>

*/"/>
    <method name="public final void setFocusPolicy(com.trolltech.qt.core.Qt.FocusPolicy policy__0)"/>
    <method name="public final void setFocusProxy(com.trolltech.qt.gui.QWidget arg__0)" doc="/**
<p>Sets the widget's focus proxy to widget <i>w</i>. If <i>w</i> is 0, the function resets this widget to have no focus proxy.</p>
<p>Some widgets can &quot;have focus&quot;, but create a child widget, such as QLineEdit, to actually handle the focus. In this case, the widget can set the line edit to be its focus proxy.</p>
<p>setFocusProxy() sets the widget which will actually get focus when &quot;this widget&quot; gets it. If there is a focus proxy, setFocus() and hasFocus() operate on the focus proxy.</p>

*/"/>
    <method name="public final void setForegroundRole(com.trolltech.qt.gui.QPalette.ColorRole arg__0)" doc="/**
<p>Sets the foreground role of the widget to <i>role</i>.</p>
<p>The foreground role defines the color from the widget's palette that is used to draw the foreground.</p>
<p>If <i>role</i> is QPalette::NoRole, the widget uses a foreground role that contrasts with the background role.</p>

*/"/>
    <method name="public final void setHidden(boolean hidden__0)" doc="/**
<p>Convenience function, equivalent to setVisible(!<i>hidden</i>).</p>

*/"/>
    <method name="public final void setInputContext(com.trolltech.qt.gui.QInputContext arg__0)" doc="/**
<p>This function sets the input context <i>context</i> on this widget.</p>

*/"/>
    <method name="public final void setLayout(com.trolltech.qt.gui.QLayout arg__0)" doc="/**
<p>Sets the layout manager for this widget to <i>layout</i>.</p>
<p>If there already is a layout manager installed on this widget, QWidget won't let you install another. You must first delete the existing layout manager (returned by layout()) before you can call setLayout() with the new layout.</p>
<p>Example:</p>
<pre>        QVBoxLayout *layout = new QVBoxLayout;
        layout-&gt;addWidget(lcd);
        layout-&gt;addWidget(slider);
        setLayout(layout);</pre>
<p>An alternative to calling this function is to pass this widget to the layout's constructor.</p>
<p>The QWidget will take ownership of <i>layout</i>.</p>

*/"/>
    <method name="public final void setLayoutDirection(com.trolltech.qt.core.Qt.LayoutDirection direction__0)"/>
    <method name="public final void setMask(com.trolltech.qt.gui.QBitmap arg__0)" doc="/**
<p>Causes only the pixels of the widget for which <i>bitmap</i> has a corresponding 1 bit to be visible. If the region includes pixels outside the rect() of the widget, window system controls in that area may or may not be visible, depending on the platform.</p>
<p>Note that this effect can be slow if the region is particularly complex.</p>
<p>The following code shows how an image with an alpha channel can be used to generate a mask for a widget:</p>
<pre>        QLabel topLevelLabel;
        QPixmap pixmap(&quot;:/images/tux.png&quot;);
        topLevelLabel.setPixmap(pixmap);
        topLevelLabel.setMask(pixmap.mask());</pre>
<p>The label shown by this code is masked using the image it contains, giving the appearance that an irregularly-shaped image is being drawn directly onto the screen.</p>
<p>Masked widgets receive mouse events only on their visible portions.</p>

*/"/>
    <method name="public final void setMask(com.trolltech.qt.gui.QRegion arg__0)" doc="/**
<p>Causes only the parts of the widget which overlap <i>region</i> to be visible. If the region includes pixels outside the rect() of the widget, window system controls in that area may or may not be visible, depending on the platform.</p>
<p>Note that this effect can be slow if the region is particularly complex.</p>

*/"/>
    <method name="public final void setMaximumHeight(int maxh__0)"/>
    <method name="public final void setMaximumSize(com.trolltech.qt.core.QSize arg__0)"/>
    <method name="public final void setMaximumSize(int maxw__0, int maxh__1)" doc="/**
<p>This function corresponds to setMaximumSize(QSize(<i>maxw</i>, <i>maxh</i>)). Sets the maximum width to <i>maxw</i> and the maximum height to <i>maxh</i>.</p>

*/"/>
    <method name="public final void setMaximumWidth(int maxw__0)"/>
    <method name="public final void setMinimumHeight(int minh__0)"/>
    <method name="public final void setMinimumSize(int minw__0, int minh__1)" doc="/**
<p>This function corresponds to setMinimumSize(QSize(minw, minh)). Sets the minimum width to <i>minw</i> and the minimum height to <i>minh</i>.</p>

*/"/>
    <method name="public final void setMinimumSize(com.trolltech.qt.core.QSize arg__0)"/>
    <method name="public final void setMinimumWidth(int minw__0)"/>
    <method name="public final void setMouseTracking(boolean enable__0)"/>
    <method name="public final void setPalette(com.trolltech.qt.gui.QPalette arg__0)"/>
    <method name="public final void setParent(com.trolltech.qt.gui.QWidget parent__0)" doc="/**
<p>Sets the parent of the widget to <i>parent</i>, and resets the window flags. The widget is moved to position (0, 0) in its new parent.</p>
<p>If the new parent widget is in a different window, the reparented widget and its children are appended to the end of the tab chain of the new parent widget, in the same internal order as before. If one of the moved widgets had keyboard focus, setParent() calls clearFocus() for that widget.</p>
<p>If the new parent widget is in the same window as the old parent, setting the parent doesn't change the tab order or keyboard focus.</p>
<p>If the &quot;new&quot; parent widget is the old parent widget, this function does nothing.</p>
<p><b>Warning:</b> It is very unlikely that you will ever need this function. If you have a widget that changes its content dynamically, it is far easier to use QStackedWidget.</p>

*/"/>
    <method name="public final void setParent(com.trolltech.qt.gui.QWidget parent__0, com.trolltech.qt.core.Qt.WindowFlags f__1)" doc="/**
<p>This function also takes widget flags, <i>f</i> as an argument.</p>

*/"/>
    <method name="public final void setShortcutAutoRepeat(int id__0, boolean enable__1)" doc="/**
<p>If <i>enable</i> is true, auto repeat of the shortcut with the given <i>id</i> is enabled; otherwise it is disabled.</p>

*/"/>
    <method name="public final void setShortcutEnabled(int id__0, boolean enable__1)" doc="/**
<p>If <i>enable</i> is true, the shortcut with the given <i>id</i> is enabled; otherwise the shortcut is disabled.</p>
<p><b>Warning:</b> You should not normally need to use this function since Qt's shortcut system enables/disables shortcuts automatically as widgets become hidden/visible and gain or lose focus. It is best to use QAction or QShortcut to handle shortcuts, since they are easier to use than this low-level function.</p>

*/"/>
    <method name="public final void setShown(boolean shown__0)" doc="/**
<p>Use setVisible(<i>shown</i>) instead.</p>

*/"/>
    <method name="public final void setSizeIncrement(com.trolltech.qt.core.QSize arg__0)"/>
    <method name="public final void setSizeIncrement(int w__0, int h__1)" doc="/**
<p>Sets the x (width) size increment to <i>w</i> and the y (height) size increment to <i>h</i>.</p>

*/"/>
    <method name="public final void setSizePolicy(com.trolltech.qt.gui.QSizePolicy arg__0)"/>
    <method name="public final void setSizePolicy(com.trolltech.qt.gui.QSizePolicy.Policy horizontal__0, com.trolltech.qt.gui.QSizePolicy.Policy vertical__1)" doc="/**
<p>Sets the size policy of the widget to <i>horizontal</i> and <i>vertical</i>, with standard stretch and no height-for-width.</p>

*/"/>
    <method name="public final void setStatusTip(java.lang.String arg__0)"/>
    <method name="public final void setStyle(com.trolltech.qt.gui.QStyle arg__0)" doc="/**
<p>Sets the widget's GUI style to <i>style</i>. The ownership of the style object is not transferred.</p>
<p>If no style is set, the widget uses the application's style, QApplication::style() instead.</p>
<p><b>Warning:</b> This function is particularly useful for demonstration purposes, where you want to show Qt's styling capabilities. Real applications should avoid it and use one consistent GUI style instead.</p>

*/"/>
    <method name="public final void setStyleSheet(java.lang.String styleSheet__0)"/>
    <method name="public final void setToolTip(java.lang.String arg__0)"/>
    <method name="public final void setUpdatesEnabled(boolean enable__0)"/>
    <method name="public final void setWhatsThis(java.lang.String arg__0)"/>
    <method name="public final void setWindowFlags(com.trolltech.qt.core.Qt.WindowFlags type__0)"/>
    <method name="public final void setWindowIcon(com.trolltech.qt.gui.QIcon icon__0)"/>
    <method name="public final void setWindowIconText(java.lang.String arg__0)"/>
    <method name="public final void setWindowModified(boolean arg__0)"/>
    <method name="public final void setWindowOpacity(double level__0)"/>
    <method name="public final void setWindowRole(java.lang.String arg__0)" doc="/**
<p>Sets the window's role to <i>role</i>. This only makes sense for windows on X11.</p>

*/"/>
    <method name="public final void setWindowState(com.trolltech.qt.core.Qt.WindowStates state__0)" doc="/**
<p>Sets the window state to <i>windowState</i>. The window state is a OR'ed combination of Qt::WindowState: Qt::WindowMinimized, Qt::WindowMaximized, Qt::WindowFullScreen, and Qt::WindowActive.</p>
<p>If the window is not visible (i.e. isVisible() returns false), the window state will take effect when show() is called. For visible windows, the change is immediate. For example, to toggle between full-screen and mormal mode, use the following code:</p>
<pre>    w-&gt;setWindowState(w-&gt;windowState() ^ Qt::WindowFullScreen);</pre>
<p>In order to restore and activate a minimized window (while preserving its maximized and/or full-screen state), use the following:</p>
<pre>    w-&gt;setWindowState(w-&gt;windowState() &amp; ~Qt::WindowMinimized | Qt::WindowActive);</pre>
<p>Note: On some window systems Qt::WindowActive is not immediate, and may be ignored in certain cases.</p>
<p>When the window state changes, the widget receives a changeEvent() of type QEvent::WindowStateChange.</p>

*/"/>
    <method name="public final void show()" doc="/**
<p>Shows the widget and its child widgets. This function is equivalent to setVisible(true).</p>

*/"/>
    <method name="public final void showFullScreen()" doc="/**
<p>Shows the widget in full-screen mode.</p>
<p>Calling this function only affects windows.</p>
<p>To return from full-screen mode, call showNormal().</p>
<p>Full-screen mode works fine under Windows, but has certain problems under X. These problems are due to limitations of the ICCCM protocol that specifies the communication between X11 clients and the window manager. ICCCM simply does not understand the concept of non-decorated full-screen windows. Therefore, the best we can do is to request a borderless window and place and resize it to fill the entire screen. Depending on the window manager, this may or may not work. The borderless window is requested using MOTIF hints, which are at least partially supported by virtually all modern window managers.</p>
<p>An alternative would be to bypass the window manager entirely and create a window with the Qt::X11BypassWindowManagerHint flag. This has other severe problems though, like totally broken keyboard focus and very strange effects on desktop changes or when the user raises other windows.</p>
<p>X11 window managers that follow modern post-ICCCM specifications support full-screen mode properly.</p>

*/"/>
    <method name="public final void showMaximized()" doc="/**
<p>Shows the widget maximized.</p>
<p>Calling this function only affects windows.</p>
<p>On X11, this function may not work properly with certain window managers. See Window Geometry for an explanation.</p>

*/"/>
    <method name="public final void showMinimized()" doc="/**
<p>Shows the widget minimized, as an icon.</p>
<p>Calling this function only affects windows.</p>

*/"/>
    <method name="public final void showNormal()" doc="/**
<p>Restores the widget after it has been maximized or minimized.</p>
<p>Calling this function only affects windows.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QSize size()"/>
    <method name="public final com.trolltech.qt.core.QSize sizeIncrement()"/>
    <method name="public final com.trolltech.qt.gui.QSizePolicy sizePolicy()"/>
    <method name="public final void stackUnder(com.trolltech.qt.gui.QWidget arg__0)" doc="/**
<p>Places the widget under <i>w</i> in the parent widget's stack.</p>
<p>To make this work, the widget itself and <i>w</i> must be siblings.</p>

*/"/>
    <method name="public final java.lang.String statusTip()"/>
    <method name="public final com.trolltech.qt.gui.QStyle style()"/>
    <method name="public final java.lang.String styleSheet()"/>
    <method name="public final boolean testAttribute(com.trolltech.qt.core.Qt.WidgetAttribute arg__0)" doc="/**
<p>Returns true if attribute <i>attribute</i> is set on this widget; otherwise returns false.</p>

*/"/>
    <method name="public final java.lang.String toolTip()"/>
    <method name="public final com.trolltech.qt.gui.QWidget topLevelWidget()" doc="/**
<p>Use window() instead.</p>

*/"/>
    <method name="public final boolean underMouse()" doc="/**
<p>Returns true if the widget is under the mouse cursor; otherwise returns false.</p>
<p>This value is not updated properly during drag and drop operations.</p>

*/"/>
    <method name="public final void unsetCursor()"/>
    <method name="public final void unsetLayoutDirection()"/>
    <method name="public final void update(com.trolltech.qt.core.QRect arg__0)" doc="/**
<p>This version updates a rectangle <i>r</i> inside the widget.</p>

*/"/>
    <method name="public final void update()" doc="/**
<p>Updates the widget unless updates are disabled or the widget is hidden.</p>
<p>This function does not cause an immediate repaint; instead it schedules a paint event for processing when Qt returns to the main event loop. This permits Qt to optimize for more speed and less flicker than a call to repaint() does.</p>
<p>Calling update() several times normally results in just one paintEvent() call.</p>
<p>Qt normally erases the widget's area before the paintEvent() call. If the Qt::WA_OpaquePaintEvent widget attribute is set, the widget is responsible for painting all its pixels with an opaque color.</p>

*/"/>
    <method name="public final void update(int x__0, int y__1, int w__2, int h__3)" doc="/**
<p>This version updates a rectangle (<i>x</i>, <i>y</i>, <i>w</i>, <i>h</i>) inside the widget.</p>

*/"/>
    <method name="public final void update(com.trolltech.qt.gui.QRegion arg__0)" doc="/**
<p>This version repaints a region <i>rgn</i> inside the widget.</p>

*/"/>
    <method name="public final void updateGeometry()" doc="/**
<p>Notifies the layout system that this widget has changed and may need to change geometry.</p>
<p>Call this function if the sizeHint() or sizePolicy() have changed.</p>
<p>For explicitly hidden widgets, updateGeometry() is a no-op. The layout system will be notified as soon as the widget is shown.</p>

*/"/>
    <method name="protected final void updateMicroFocus()" doc="/**
<p>Updates the widget's micro focus.</p>

*/"/>
    <method name="public final boolean updatesEnabled()"/>
    <method name="public final com.trolltech.qt.gui.QRegion visibleRegion()" doc="/**
<p>Returns the unobscured region where paint events can occur.</p>
<p>For visible widgets, this is an approximation of the area not covered by other widgets; otherwise, this is an empty region.</p>
<p>The repaint() function calls this function if necessary, so in general you do not need to call it.</p>

*/"/>
    <method name="public final java.lang.String whatsThis()"/>
    <method name="public final com.trolltech.qt.gui.QWidget window()" doc="/**
<p>Returns the window for this widget, i.e. the next ancestor widget that has (or could have) a window-system frame.</p>
<p>If the widget is a window, the widget itself is returned.</p>
<p>Typical usage is changing the window title:</p>
<pre>    aWidget-&gt;window()-&gt;setWindowTitle(&quot;New Window Title&quot;);</pre>

*/"/>
    <method name="public final com.trolltech.qt.core.Qt.WindowFlags windowFlags()"/>
    <method name="public final com.trolltech.qt.gui.QIcon windowIcon()"/>
    <method name="public final java.lang.String windowIconText()"/>
    <method name="public final com.trolltech.qt.core.Qt.WindowModality windowModality()"/>
    <method name="public final double windowOpacity()"/>
    <method name="public final java.lang.String windowRole()" doc="/**
<p>Returns the window's role, or an empty string.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.Qt.WindowStates windowState()" doc="/**
<p>Returns the current window state. The window state is a OR'ed combination of Qt::WindowState: Qt::WindowMinimized, Qt::WindowMaximized, Qt::WindowFullScreen, and Qt::WindowActive.</p>

*/"/>
    <method name="public final java.lang.String windowTitle()"/>
    <method name="public final com.trolltech.qt.core.Qt.WindowType windowType()" doc="/**
<p>Returns the window type of this widget. This is identical to windowFlags() &amp; Qt::WindowType_Mask.</p>

*/"/>
    <method name="public final int x()"/>
    <method name="public final int y()"/>
    <method name="protected void actionEvent(com.trolltech.qt.gui.QActionEvent arg__0)" doc="/**
<p>This event handler is called with the given <i>event</i> whenever the widget's actions are changed.</p>

*/"/>
    <method name="public void addAction(com.trolltech.qt.gui.QAction action__0)" doc="/**
<p>Appends the action <i>action</i> to this widget's list of actions.</p>
<p>All QWidgets have a list of QActions, however they can be represented graphically in many different ways. The default use of the QAction list (as returned by actions()) is to create a context QMenu.</p>
<p>A QWidget should only have one of each action.</p>

*/"/>
    <method name="protected void changeEvent(com.trolltech.qt.core.QEvent arg__0)" doc="/**
<p>This event handler can be reimplemented to handle state changes.</p>
<p>The state being changed in this event can be retrieved through event <i>event</i>.</p>
<p>Change events include: QEvent::ToolBarChange, QEvent::ActivationChange, QEvent::EnabledChange, QEvent::FontChange, QEvent::StyleChange, QEvent::PaletteChange, QEvent::WindowTitleChange, QEvent::IconTextChange, QEcvent::ModifiedChange, QEvent::MouseTrackingChange, QEvent::ParentChange, QEvent::WindowStateChange, QEvent::LanguageChange, QEvent::LocaleChange, QEvent::LayoutDirectionChange.</p>

*/"/>
    <method name="protected void closeEvent(com.trolltech.qt.gui.QCloseEvent arg__0)" doc="/**
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive widget close events.</p>

*/"/>
    <method name="protected void contextMenuEvent(com.trolltech.qt.gui.QContextMenuEvent arg__0)" doc="/**
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive widget context menu events.</p>
<p>The handler is called when the widget's contextMenuPolicy is Qt::DefaultContextMenu.</p>
<p>The default implementation ignores the context event. See the QContextMenuEvent documentation for more details.</p>

*/"/>
    <method name="public int depth()"/>
    <method name="public int devType()"/>
    <method name="protected void dragEnterEvent(com.trolltech.qt.gui.QDragEnterEvent arg__0)" doc="/**
<p>This event handler is called when a drag is in progress and the mouse enters this widget. The event is passed in the <i>event</i> parameter.</p>
<p>See the Drag-and-drop documentation for an overview of how to provide drag-and-drop in your application.</p>

*/"/>
    <method name="protected void dragLeaveEvent(com.trolltech.qt.gui.QDragLeaveEvent arg__0)" doc="/**
<p>This event handler is called when a drag is in progress and the mouse leaves this widget. The event is passed in the <i>event</i> parameter.</p>
<p>See the Drag-and-drop documentation for an overview of how to provide drag-and-drop in your application.</p>

*/"/>
    <method name="protected void dragMoveEvent(com.trolltech.qt.gui.QDragMoveEvent arg__0)" doc="/**
<p>This event handler is called if a drag is in progress, and when any of the following conditions occurs: the cursor enters this widget, the cursor moves within this widget, or a modifier key is pressed on the keyboard while this widget has the focus. The event is passed in the <i>event</i> parameter.</p>
<p>See the Drag-and-drop documentation for an overview of how to provide drag-and-drop in your application.</p>

*/"/>
    <method name="protected void dropEvent(com.trolltech.qt.gui.QDropEvent arg__0)" doc="/**
<p>This event handler is called when the drag is dropped on this widget which are passed in the <i>event</i> parameter.</p>
<p>See the Drag-and-drop documentation for an overview of how to provide drag-and-drop in your application.</p>

*/"/>
    <method name="protected void enabledChange(boolean arg__0)"/>
    <method name="protected void enterEvent(com.trolltech.qt.core.QEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive widget enter events which are passed in the <i>event</i> parameter.</p>
<p>An event is sent to the widget when the mouse cursor enters the widget.</p>

*/"/>
    <method name="public boolean event(com.trolltech.qt.core.QEvent arg__0)" doc="/**
<p>This is the main event handler; it handles event <i>event</i>. You can reimplement this function in a subclass, but we recommend using one of the specialized event handlers instead.</p>
<p>Key press and release events are treated differently from other events. event() checks for Tab and Shift+Tab and tries to move the focus appropriately. If there is no widget to move the focus to (or the key press is not Tab or Shift+Tab), event() calls keyPressEvent().</p>
<p>Mouse and tablet event handling is also slightly special: only when the widget is enabled, event() will call the specialized handlers such as mousePressEvent(); otherwise it will discard the event.</p>
<p>This function returns true if the event was recognized, otherwise it returns false. If the recognized event was accepted (see QEvent::accepted), any further processing such as event propagation to the parent widget stops.</p>

*/"/>
    <method name="protected void focusInEvent(com.trolltech.qt.gui.QFocusEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive keyboard focus events (focus received) for the widget. The event is passed in the <i>event</i> parameter</p>
<p>A widget normally must setFocusPolicy() to something other than Qt::NoFocus in order to receive focus events. (Note that the application programmer can call setFocus() on any widget, even those that do not normally accept focus.)</p>
<p>The default implementation updates the widget (except for windows that do not specify a focusPolicy()).</p>

*/"/>
    <method name="protected boolean focusNextPrevChild(boolean next__0)" doc="/**
<p>Finds a new widget to give the keyboard focus to, as appropriate for Tab and Shift+Tab, and returns true if it can find a new widget, or false if it can't.</p>
<p>If <i>next</i> is true, this function searches forward, if <i>next</i> is false, it searches backward.</p>
<p>Sometimes, you will want to reimplement this function. For example, a web browser might reimplement it to move its &quot;current active link&quot; forward or backward, and call focusNextPrevChild() only when it reaches the last or first link on the &quot;page&quot;.</p>
<p>Child widgets call focusNextPrevChild() on their parent widgets, but only the window that contains the child widgets decides where to redirect focus. By reimplementing this function for an object, you thus gain control of focus traversal for all child widgets.</p>

*/"/>
    <method name="protected void focusOutEvent(com.trolltech.qt.gui.QFocusEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive keyboard focus events (focus lost) for the widget. The events is passed in the <i>event</i> parameter.</p>
<p>A widget normally must setFocusPolicy() to something other than Qt::NoFocus in order to receive focus events. (Note that the application programmer can call setFocus() on any widget, even those that do not normally accept focus.)</p>
<p>The default implementation updates the widget (except for windows that do not specify a focusPolicy()).</p>

*/"/>
    <method name="public com.trolltech.qt.gui.QFont font()"/>
    <method name="protected void fontChange(com.trolltech.qt.gui.QFont arg__0)"/>
    <method name="public int height()"/>
    <method name="public int heightForWidth(int arg__0)" doc="/**
<p>Returns the preferred height for this widget, given the width <i>w</i>.</p>
<p>If this widget has a layout, the default implementation returns the layout's preferred height. if there is no layout, the default implementation returns -1 indicating that the preferred height does not depend on the width.</p>

*/"/>
    <method name="protected void hideEvent(com.trolltech.qt.gui.QHideEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive widget hide events. The event is passed in the <i>event</i> parameter.</p>
<p>Hide events are sent to widgets immediately after they have been hidden.</p>
<p>Note: A widget receives spontaneous show and hide events when its mapping status is changed by the window system, e.g. a spontaneous hide event when the user minimizes the window, and a spontaneous show event when the window is restored again. After receiving a spontaneous hide event, a widget is still considered visible in the sense of isVisible().</p>

*/"/>
    <method name="protected void inputMethodEvent(com.trolltech.qt.gui.QInputMethodEvent arg__0)" doc="/**
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive Input Method composition events. This handler is called when the state of the input method changes.</p>
<p>Note that when creating custom text editing widgets, the Qt::WA_InputMethodEnabled window attribute must be set explicitly (using the setAttribute() function) in order to receive input method events.</p>
<p>The default implementation calls event-&gt;ignore(), which rejects the Input Method event. See the QInputMethodEvent documentation for more details.</p>

*/"/>
    <method name="public java.lang.Object inputMethodQuery(com.trolltech.qt.core.Qt.InputMethodQuery arg__0)" doc="/**
<p>This method is only relevant for input widgets. It is used by the input method to query a set of properties of the widget to be able to support complex input method operations as support for surrounding text and reconversions.</p>
<p><i>query</i> specifies which property is queried.</p>

*/"/>
    <method name="protected void keyPressEvent(com.trolltech.qt.gui.QKeyEvent arg__0)" doc="/**
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive key press events for the widget.</p>
<p>A widget must call setFocusPolicy() to accept focus initially and have focus in order to receive a key press event.</p>
<p>If you reimplement this handler, it is very important that you ignore() the event if you do not understand it, so that the widget's parent can interpret it.</p>
<p>The default implementation closes popup widgets if the user presses Esc. Otherwise the event is ignored.</p>

*/"/>
    <method name="protected void keyReleaseEvent(com.trolltech.qt.gui.QKeyEvent arg__0)" doc="/**
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive key release events for the widget.</p>
<p>A widget must accept focus initially and have focus in order to receive a key release event.</p>
<p>If you reimplement this handler, it is very important that you ignore() the release if you do not understand it, so that the widget's parent can interpret it.</p>
<p>The default implementation ignores the event.</p>

*/"/>
    <method name="protected void languageChange()"/>
    <method name="protected void leaveEvent(com.trolltech.qt.core.QEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive widget leave events which are passed in the <i>event</i> parameter.</p>
<p>A leave event is sent to the widget when the mouse cursor leaves the widget.</p>

*/"/>
    <method name="public int metric(com.trolltech.qt.gui.QPaintDevice.PaintDeviceMetric arg__0)" doc="/**
<p>Internal implementation of the virtual QPaintDevice::metric() function.</p>
<p><i>m</i> is the metric to get.</p>

*/"/>
    <method name="public com.trolltech.qt.core.QSize minimumSizeHint()"/>
    <method name="protected void mouseDoubleClickEvent(com.trolltech.qt.gui.QMouseEvent arg__0)" doc="/**
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive mouse double click events for the widget.</p>
<p>The default implementation generates a normal mouse press event.</p>
<p>Note that the widgets gets a mousePressEvent() and a mouseReleaseEvent() before the mouseDoubleClickEvent().</p>

*/"/>
    <method name="protected void mouseMoveEvent(com.trolltech.qt.gui.QMouseEvent arg__0)" doc="/**
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive mouse move events for the widget.</p>
<p>If mouse tracking is switched off, mouse move events only occur if a mouse button is pressed while the mouse is being moved. If mouse tracking is switched on, mouse move events occur even if no mouse button is pressed.</p>
<p>QMouseEvent::pos() reports the position of the mouse cursor, relative to this widget. For press and release events, the position is usually the same as the position of the last mouse move event, but it might be different if the user's hand shakes. This is a feature of the underlying window system, not Qt.</p>

*/"/>
    <method name="protected void mousePressEvent(com.trolltech.qt.gui.QMouseEvent arg__0)" doc="/**
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive mouse press events for the widget.</p>
<p>If you create new widgets in the mousePressEvent() the mouseReleaseEvent() may not end up where you expect, depending on the underlying window system (or X11 window manager), the widgets' location and maybe more.</p>
<p>The default implementation implements the closing of popup widgets when you click outside the window. For other widget types it does nothing.</p>

*/"/>
    <method name="protected void mouseReleaseEvent(com.trolltech.qt.gui.QMouseEvent arg__0)" doc="/**
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive mouse release events for the widget.</p>

*/"/>
    <method name="public void move(int x__0, int y__1)" doc="/**
<p>This corresponds to move(QPoint(<i>x</i>, <i>y</i>)).</p>

*/"/>
    <method name="public void move(com.trolltech.qt.core.QPoint arg__0)"/>
    <method name="protected void moveEvent(com.trolltech.qt.gui.QMoveEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive widget move events which are passed in the <i>event</i> parameter. When the widget receives this event, it is already at the new position.</p>
<p>The old position is accessible through QMoveEvent::oldPos().</p>

*/"/>
    <method name="public com.trolltech.qt.gui.QPaintEngine paintEngine()" doc="/**
<p>Returns the widget's paint engine.</p>

*/"/>
    <method name="protected void paintEvent(com.trolltech.qt.gui.QPaintEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive paint events which are passed in the <i>event</i> parameter.</p>
<p>A paint event is a request to repaint all or part of the widget. It can happen as a result of repaint() or update(), or because the widget was obscured and has now been uncovered, or for many other reasons.</p>
<p>Many widgets can simply repaint their entire surface when asked to, but some slow widgets need to optimize by painting only the requested region: QPaintEvent::region(). This speed optimization does not change the result, as painting is clipped to that region during event processing. QListView and QTableView do this, for example.</p>
<p>Qt also tries to speed up painting by merging multiple paint events into one. When update() is called several times or the window system sends several paint events, Qt merges these events into one event with a larger region (see QRegion::united()). repaint() does not permit this optimization, so we suggest using update() whenever possible.</p>
<p>When the paint event occurs, the update region has normally been erased, so that you're painting on the widget's background.</p>
<p>The background can be set using setBackgroundRole() and setPalette().</p>
<p>From Qt 4.0, QWidget automatically double-buffers its painting, so there's no need to write double-buffering code in paintEvent() to avoid flicker.</p>
<p>Note: Under X11 it is possible to toggle the global double buffering by calling <tt>qt_x11_set_global_double_buffer()</tt>. Example usage:</p>
<pre>    ...
    extern void qt_x11_set_global_double_buffer(bool);
    qt_x11_set_global_double_buffer(false);
    ...</pre>

*/"/>
    <method name="public boolean paintingActive()"/>
    <method name="protected void paletteChange(com.trolltech.qt.gui.QPalette arg__0)"/>
    <method name="public void repaint(com.trolltech.qt.core.QRect arg__0)" doc="/**
<p>This version repaints a rectangle <i>r</i> inside the widget.</p>

*/"/>
    <method name="public void repaint()" doc="/**
<p>Repaints the widget directly by calling paintEvent() immediately, unless updates are disabled or the widget is hidden.</p>
<p>We suggest only using repaint() if you need an immediate repaint, for example during animation. In almost all circumstances update() is better, as it permits Qt to optimize for speed and minimize flicker.</p>
<p><b>Warning:</b> If you call repaint() in a function which may itself be called from paintEvent(), you may get infinite recursion. The update() function never causes recursion.</p>

*/"/>
    <method name="public void repaint(com.trolltech.qt.gui.QRegion arg__0)" doc="/**
<p>This version repaints a region <i>rgn</i> inside the widget.</p>

*/"/>
    <method name="public void repaint(int x__0, int y__1, int w__2, int h__3)" doc="/**
<p>This version repaints a rectangle (<i>x</i>, <i>y</i>, <i>w</i>, <i>h</i>) inside the widget.</p>
<p>If <i>w</i> is negative, it is replaced with <tt>width() - x</tt>, and if <i>h</i> is negative, it is replaced width <tt>height() - y</tt>.</p>

*/"/>
    <method name="public void resize(int w__0, int h__1)" doc="/**
<p>This corresponds to resize(QSize(<i>w</i>, <i>h</i>)).</p>

*/"/>
    <method name="public void resize(com.trolltech.qt.core.QSize arg__0)"/>
    <method name="protected void resizeEvent(com.trolltech.qt.gui.QResizeEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive widget resize events which are passed in the <i>event</i> parameter. When resizeEvent() is called, the widget already has its new geometry. The old size is accessible through QResizeEvent::oldSize().</p>
<p>The widget will be erased and receive a paint event immediately after processing the resize event. No drawing need be (or should be) done inside this handler.</p>

*/"/>
    <method name="public void setFont(com.trolltech.qt.gui.QFont arg__0)"/>
    <method name="public void setGeometry(int x__0, int y__1, int w__2, int h__3)" doc="/**
<p>This corresponds to setGeometry(QRect(<i>x</i>, <i>y</i>, <i>w</i>, <i>h</i>)).</p>

*/"/>
    <method name="public void setGeometry(com.trolltech.qt.core.QRect arg__0)"/>
    <method name="public void setVisible(boolean visible__0)"/>
    <method name="public void setWindowModality(com.trolltech.qt.core.Qt.WindowModality windowModality__0)"/>
    <method name="public void setWindowTitle(java.lang.String arg__0)"/>
    <method name="protected void showEvent(com.trolltech.qt.gui.QShowEvent arg__0)" doc="/**
<p>This event handler can be reimplemented in a subclass to receive widget show events which are passed in the <i>event</i> parameter.</p>
<p>Non-spontaneous show events are sent to widgets immediately before they are shown. The spontaneous show events of windows are delivered afterwards.</p>
<p>Note: A widget receives spontaneous show and hide events when its mapping status is changed by the window system, e.g. a spontaneous hide event when the user minimizes the window, and a spontaneous show event when the window is restored again. After receiving a spontaneous hide event, a widget is still considered visible in the sense of isVisible().</p>

*/"/>
    <method name="public com.trolltech.qt.core.QSize sizeHint()"/>
    <method name="protected void tabletEvent(com.trolltech.qt.gui.QTabletEvent arg__0)" doc="/**
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive tablet events for the widget.</p>
<p>If you reimplement this handler, it is very important that you ignore() the event if you do not handle it, so that the widget's parent can interpret it.</p>
<p>The default implementation ignores the event.</p>

*/"/>
    <method name="protected void wheelEvent(com.trolltech.qt.gui.QWheelEvent arg__0)" doc="/**
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive wheel events for the widget.</p>
<p>If you reimplement this handler, it is very important that you ignore() the event if you do not handle it, so that the widget's parent can interpret it.</p>
<p>The default implementation ignores the event.</p>

*/"/>
    <method name="public int width()"/>
    <method name="protected void windowActivationChange(boolean arg__0)"/>
    <method name="public native static com.trolltech.qt.gui.QWidget keyboardGrabber()" doc="/**
<p>Returns the widget that is currently grabbing the keyboard input.</p>
<p>If no widget in this application is currently grabbing the keyboard, 0 is returned.</p>

*/"/>
    <method name="public native static com.trolltech.qt.gui.QWidget mouseGrabber()" doc="/**
<p>Returns the widget that is currently grabbing the mouse input.</p>
<p>If no widget in this application is currently grabbing the mouse, 0 is returned.</p>

*/"/>
    <method name="public final static void setTabOrder(com.trolltech.qt.gui.QWidget arg__0, com.trolltech.qt.gui.QWidget arg__1)" doc="/**
<p>Moves the <i>second</i> widget around the ring of focus widgets so that keyboard focus moves from the <i>first</i> widget to the <i>second</i> widget when the Tab key is pressed.</p>
<p>Note that since the tab order of the <i>second</i> widget is changed, you should order a chain like this:</p>
<pre>    setTabOrder(a, b); <span class=&quote;comment&quote;>// a to b</span>
    setTabOrder(b, c); <span class=&quote;comment&quote;>// a to b to c</span>
    setTabOrder(c, d); <span class=&quote;comment&quote;>// a to b to c to d</span></pre>
<p><i>not</i> like this:</p>
<pre><span class=&quote;comment&quote;>    // WRONG</span>
    setTabOrder(c, d); <span class=&quote;comment&quote;>// c to d</span>
    setTabOrder(a, b); <span class=&quote;comment&quote;>// a to b AND c to d</span>
    setTabOrder(b, c); <span class=&quote;comment&quote;>// a to b to c, but not c to d</span></pre>
<p>If <i>first</i> or <i>second</i> has a focus proxy, setTabOrder() correctly substitutes the proxy.</p>

*/"/>
</class>
