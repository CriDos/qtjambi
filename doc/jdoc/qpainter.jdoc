<class name="QPainter" doc="/**
<p>The QPainter class performs low-level painting on widgets and other paint devices.</p>
<p>QPainter provides highly optimized functions to do most of the drawing GUI programs require. It can draw everything from simple lines to complex shapes like pies and chords. It can also draw aligned text and pixmaps. Normally, it draws in a &quot;natural&quot; coordinate system, but it can also do view and world transformation. QPainter can operate on any object that inherits the QPaintDevice class.</p>
<p>The common use of QPainter is inside a widget's paint event: Construct and customize (e.g. set the pen or the brush) the painter. Then draw. Remember to destroy the QPainter object after drawing. For example:</p>
<pre>    void SimpleExampleWidget::paintEvent(QPaintEvent *)
    {
        QPainter painter(this);
        painter.setPen(Qt::blue);
        painter.setFont(QFont(&quot;Arial&quot;, 30));
        painter.drawText(rect(), Qt::AlignCenter, &quot;Qt&quot;);
    }</pre>
<p>The core functionality of QPainter is drawing, but the class also provide several functions that allows you to customize QPainter's settings and its rendering quality, and others that enable clipping. In addition you can control how different shapes are merged together by specifying the painter's composition mode.</p>
<p>The isActive() function indicates whether the painter is active. A painter is activated by the begin() function and the constructor that takes a QPaintDevice argument. The end() function, and the destructor, deactivates it.</p>
<p>Together with the QPaintDevice and QPaintEngine classes, QPainter form the basis for Qt's paint system. QPainter is the class used to perform drawing operations. QPaintDevice represents a device that can be painted on using a QPainter. QPaintEngine provides the interface that the painter uses to draw onto different types of devices. If the painter is active, device() returns the paint device on which the painter paints, and paintEngine() returns the paint engine that the painter is currently operating on. For more information, see The Paint System documentation.</p>
<p>Sometimes it is desirable to make someone else paint on an unusual QPaintDevice. QPainter supports a static function to do this, setRedirected().</p>
<p><b>Warning:</b> When the paintdevice is a widget, QPainter can only be used inside a paintEvent() function or in a function called by paintEvent(); that is unless the Qt::WA_PaintOutsidePaintEvent widget attribute is set. On Mac OS X and Windows, you can only paint in a paintEvent() function regardless of this attribute's setting.</p>
<ul><li><a href=&quote;#settings&quote;>Settings</a></li>
<li><a href=&quote;#drawing&quote;>Drawing</a></li>
<li><a href=&quote;#rendering-quality&quote;>Rendering Quality</a></li>
<li><a href=&quote;#coordinate-transformations&quote;>Coordinate Transformations</a></li>
<li><a href=&quote;#clipping&quote;>Clipping</a></li>
<li><a href=&quote;#composition-modes&quote;>Composition Modes</a></li>
</ul>
<a name=&quote;settings&quote;></a>
<h3>Settings</h3>
<p>There are several settings that you can customize to make QPainter draw according to your preferences:</p>
<ul>
<li>font() is the font used for drawing text. If the painter isActive(), you can retrieve information about the currently set font, and its metrics, using the fontInfo() and fontMetrics() functions respectively.</li>
<li>brush() defines the color or pattern that is used for filling shapes.</li>
<li>pen() defines the color or stipple that is used for drawing lines or boundaries.</li>
<li>backgroundMode() defines whether there is a background() or not, i.e it is either Qt::OpaqueMode or Qt::TransparentMode.</li>
<li>background() only applies when backgroundMode() is Qt::OpaqueMode and pen() is a stipple. In that case, it describes the color of the background pixels in the stipple.</li>
<li>brushOrigin() defines the origin of the tiled brushes, normally the origin of widget's background.</li>
<li>viewport(), window(), worldMatrix() make up the painter's coordinate transformation system. For more information, see the <a href=&quote;#coordinate-transformations&quote;>Coordinate Transformations</a> section and the The Coordinate System documentation.</li>
<li>hasClipping() tells whether the painter clips at all. (The paint device clips, too.) If the painter clips, it clips to clipRegion().</li>
<li>layoutDirection() defines the layout direction used by the painter when drawing text.</li>
<li>matrixEnabled() tells whether world transformation is enabled.</li>
<li>viewTransformEnabled() tells whether view transformation is enabled.</li>
</ul>
<p>Note that some of these settings mirror settings in some paint devices, e.g. QWidget::font(). The QPainter::begin() function (or equivalently the QPainter constructor) copies these attributes from the paint device.</p>
<p>You can at any time save the QPainter's state by calling the save() function which saves all the available settings on an internal stack. The restore() function pops them back.</p>
<a name=&quote;drawing&quote;></a>
<h3>Drawing</h3>
<p>QPainter provides functions to draw most primitives: drawPoint(), drawPoints(), drawLine(), drawRect(), drawRoundRect(), drawEllipse(), drawArc(), drawPie(), drawChord(), drawPolyline(), drawPolygon(), drawConvexPolygon() and drawCubicBezier(). The two convenience functions, drawRects() and drawLines(), draw the given number of rectangles or lines in the given array of QRects or QLines using the current pen and brush.</p>
<p>The QPainter class also provides the fillRect() function which fills the given QRect, with the given QBrush, and the eraseRect() function that erases the area inside the given rectangle.</p>
<p>All of these functions have both integer and floating point versions.</p>
<p><table width=&quote;100%&quote; align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><font color=&quote;red&quote;>[Missing image qpainter-basicdrawing.png]</font></td><td><b>Basic Drawing Example</b><p>The Basic Drawing example shows how to display basic graphics primitives in a variety of styles using the QPainter class.</p>
</td></tr>
</table></p>
<p>If you need to draw a complex shape, especially if you need to do so repeatedly, consider creating a QPainterPath and drawing it using drawPath().</p>
<p><table width=&quote;100%&quote; align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><b>Painter Paths example</b><p>The QPainterPath class provides a container for painting operations, enabling graphical shapes to be constructed and reused.</p>
<p>The Painter Paths example shows how painter paths can be used to build complex shapes for rendering.</p>
</td><td><font color=&quote;red&quote;>[Missing image qpainter-painterpaths.png]</font></td></tr>
</table></p>
<p>QPainter also provides the fillPath() function which fills the given QPainterPath with the given QBrush, and the strokePath() function that draws the outline of the given path (i.e. strokes the path).</p>
<p>See also the Vector Deformation demo which shows how to use advanced vector techniques to draw text using a QPainterPath, the Gradients demo which shows the different types of gradients that are available in Qt, and the Path Stroking demo which shows Qt's built-in dash patterns and shows how custom patterns can be used to extend the range of available patterns.</p>
<p><table align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><font color=&quote;red&quote;>[Missing image qpainter-vectordeformation.png]</font></td><td><font color=&quote;red&quote;>[Missing image qpainter-gradients.png]</font></td><td><font color=&quote;red&quote;>[Missing image qpainter-pathstroking.png]</font></td></tr>
<thead><tr valign=&quote;top&quote; class=&quote;qt-style&quote;><th>Vector Deformation</th><th>Gradients</th><th>Path Stroking</th></tr></thead>
</table></p>
<p>There are functions to draw pixmaps/images, namely drawPixmap(), drawImage() and drawTiledPixmap(). Both drawPixmap() and drawImage() produce the same result, except that drawPixmap() is faster on-screen while drawImage() may be faster on a QPrinter or other devices.</p>
<p>Text drawing is done using drawText(). When you need fine-grained positioning, boundingRect() tells you where a given drawText() command will draw.</p>
<p>There is a drawPicture() function that draws the contents of an entire QPicture. The drawPicture() function is the only function that disregards all the painter's settings as QPicture has its own settings.</p>
<a name=&quote;rendering-quality&quote;></a>
<h3>Rendering Quality</h3>
<p>To get the optimal rendering result using QPainter, you should use the platform independent QImage as paint device; i.e. using QImage will ensure that the result has an identical pixel representation on any platform.</p>
<p>The QPainter class also provides a means of controlling the rendering quality through its RenderHint enum and the support for floating point precision: All the functions for drawing primitives has a floating point version. These are often used in combination with the QPainter::AntiAliasing render hint.</p>
<p><table width=&quote;100%&quote; align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><font color=&quote;red&quote;>[Missing image qpainter-concentriccircles.png]</font></td><td><b>Concentric Circles Example</b><p>The Concentric Circles example shows the improved rendering quality that can be obtained using floating point precision and anti-aliasing when drawing custom widgets.</p>
<p>The application's main window displays several widgets which are drawn using the various combinations of precision and anti-aliasing.</p>
</td></tr>
</table></p>
<p>The RenderHint enum specifies flags to QPainter that may or may not be respected by any given engine. QPainter::AntiAliasing indicates that the engine should antialias edges of primitives if possible, QPainter::TextAntialiasing indicates that the engine should antialias text if possible, and finally the QPainter::SmoothPixmapTransform indicates that the engine should use a smooth pixmap transformation algorithm.</p>
<p>The renderHints() function returns a flag that specifies the rendering hints that are set for this painter. Use the setRenderHint() function to set or clear the currently set RenderHints.</p>
<a name=&quote;coordinate-transformations&quote;></a>
<h3>Coordinate Transformations</h3>
<p>Normally, the QPainter operates on the device's own coordinate system (usually pixels), but QPainter has good support for coordinate transformations.</p>
<p><table align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><font color=&quote;red&quote;>[Missing image qpainter-clock.png]</font></td><td><font color=&quote;red&quote;>[Missing image qpainter-rotation.png]</font></td><td><font color=&quote;red&quote;>[Missing image qpainter-scale.png]</font></td><td><font color=&quote;red&quote;>[Missing image qpainter-translation.png]</font></td></tr>
<thead><tr valign=&quote;top&quote; class=&quote;qt-style&quote;><th>nop</th><th>rotate()</th><th>scale()</th><th>translate()</th></tr></thead>
</table></p>
<p>The most commonly used transformations are scaling, rotation, translation and shearing. Use the scale() function to scale the coordinate system by a given offset, the rotate() function to rotate it clockwise and translate() to translate it (i.e. adding a given offset to the points). You can also twist the coordinate system around the origin using the shear() function. See the Affine Transformations demo for a visualization of a sheared coordinate system.</p>
<p>See also the Transformations example which shows how transformations influence the way that QPainter renders graphics primitives. In particular it shows how the order of transformations affects the result.</p>
<p><table width=&quote;100%&quote; align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><b>Affine Transformations Demo</b><p>The Affine Transformations demo show Qt's ability to perform affine transformations on painting operations. The demo also allows the user to experiment with the transformation operations and see the results immediately.</p>
</td><td><font color=&quote;red&quote;>[Missing image qpainter-affinetransformations.png]</font></td></tr>
</table></p>
<p>All the tranformation operations operate on the transformation worldMatrix(). A matrix transforms a point in the plane to another point. For more information about the transformation matrix, see the The Coordinate System and QMatrix documentation.</p>
<p>The setWorldMatrix() function can replace or add to the currently set worldMatrix(). The resetMatrix() function resets any transformations that were made using translate(), scale(), shear(), rotate(), setWorldMatrix(), setViewport() and setWindow() functions. The deviceMatrix() returns the matrix that transforms from logical coordinates to device coordinates of the platform dependent paint device. The latter function is only needed when using platform painting commands on the platform dependent handle, and the platform does not do transformations nativly.</p>
<p>When drawing with QPainter, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device. The mapping of the logical coordinates to the physical coordinates are handled by QPainter's combinedMatrix(), a combination of viewport() and window() and worldMatrix(). The viewport() represents the physical coordinates specifying an arbitrary rectangle, the window() describes the same rectangle in logical coordinates, and the worldMatrix() is identical with the transformation matrix.</p>
<p>See also The Coordinate System documentation.</p>
<a name=&quote;clipping&quote;></a>
<h3>Clipping</h3>
<p>QPainter can clip any drawing operation to a rectangle, a region, or a vector path. The current clip is available using the functions clipRegion() and clipPath(). Whether paths or regions are preferred (faster) depends on the underlying paintEngine(). For example, the QImage paint engine prefers paths while the X11 paint engine prefers regions. Setting a clip is done in the painters logical coordinates.</p>
<p>After QPainter's clipping, the paint device may also clip. For example, most widgets clip away the pixels used by child widgets, and most printers clip away an area near the edges of the paper. This additional clipping is not reflected by the return value of clipRegion() or hasClipping().</p>
<a name=&quote;composition-modes&quote;></a>
<h3>Composition Modes</h3>
<a name=&quote;composition-modes&quote;></a><p>QPainter provides the CompositionMode enum which defines the Porter-Duff rules for digital image compositing; it describes a model for combining the pixels in one image, the source, with the pixel in another image, the destination.</p>
<p>The two most common forms of composition are Source and SourceOver. Source is used to draw opaque objects onto a paint device. In this mode, each pixel in the source replaces the corresponding pixel in the destination. In SourceOver composition mode, the source object is transparent and is drawn on top of the destination.</p>
<p>Note that composition transformation operates pixelwise. For that reason, there is a difference between using the grahic primitive itself and its bounding rectangle: The bounding rect contains pixels with alpha == 0 (i.e the pixels surrounding the primitive). These pixels will overwrite the other image's pixels, affectively clearing those, while the primitive only overwrites its own area.</p>
<p><table width=&quote;100%&quote; align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><font color=&quote;red&quote;>[Missing image qpainter-compositiondemo.png]</font></td><td><b>Composition Modes Demo</b><p>The Composition Modes demo, available in Qt's demo directory, allows you to experiment with the various composition modes and see the results immediately.</p>
</td></tr>
</table></p>

*/">
    <method name="public QPainter()" doc="/**
<p>Constructs a painter.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QBrush background()" doc="/**
<p>Returns the current background brush.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.Qt.BGMode backgroundMode()" doc="/**
<p>Returns the current background mode.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QRect boundingRect(int x__0, int y__1, int w__2, int h__3, int flags__4, java.lang.String text__5)" doc="/**
<p>Returns the bounding rectangle of the given <i>text</i> as it will appear when drawn inside the rectangle beginning at the point (<i>x</i>, <i>y</i>) with width <i>w</i> and height <i>h</i>.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QRectF boundingRect(com.trolltech.qt.core.QRectF rect__0, java.lang.String text__1, com.trolltech.qt.gui.QTextOption o__2)" doc="/**
<p>Instead of specifying flags as a bitwise OR of the Qt::AlignmentFlag and Qt::TextFlag, this overloaded function takes an <i>option</i> argument. The QTextOption class provides a description of general rich text properties.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QRectF boundingRect(com.trolltech.qt.core.QRectF rect__0, int flags__1, java.lang.String text__2)" doc="/**
<p>Returns the bounding rectangle of the <i>text</i> as it will appear when drawn inside the given <i>rectangle</i> with the specified <i>flags</i> using the currently set font(); i.e the function tells you where the drawText() function will draw when given the same arguments.</p>
<p>If the <i>text</i> does not fit within the given <i>rectangle</i> using the specified <i>flags</i>, the function returns the required rectangle.</p>
<p>The <i>flags</i> argument is a bitwise OR of the following flags:</p>
<ul>
<li>Qt::AlignLeft</li>
<li>Qt::AlignRight</li>
<li>Qt::AlignHCenter</li>
<li>Qt::AlignTop</li>
<li>Qt::AlignBottom</li>
<li>Qt::AlignVCenter</li>
<li>Qt::AlignCenter</li>
<li>Qt::TextSingleLine</li>
<li>Qt::TextExpandTabs</li>
<li>Qt::TextShowMnemonic</li>
<li>Qt::TextWordWrap</li>
</ul>
<p>If several of the horizontal or several of the vertical alignment flags are set, the resulting alignment is undefined.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QRect boundingRect(com.trolltech.qt.core.QRect rect__0, int flags__1, java.lang.String text__2)" doc="/**
<p>Returns the bounding rectangle of the <i>text</i> as it will appear when drawn inside the given <i>rectangle</i> with the specified <i>flags</i> using the currently set font().</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QBrush brush()" doc="/**
<p>Returns the painter's current brush.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QPoint brushOrigin()" doc="/**
<p>Returns the currently set brush origin.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QPainterPath clipPath()" doc="/**
<p>Returns the currently clip as a path. Note that the clip path is given in logical coordinates.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QRegion clipRegion()" doc="/**
<p>Returns the currently set clip region. Note that the clip region is given in logical coordinates.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QMatrix combinedMatrix()" doc="/**
<p>Returns the transformation matrix combining the current window/viewport and world transformation.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QPainter.CompositionMode compositionMode()" doc="/**
<p>Returns the current composition mode.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QPaintDeviceInterface device()" doc="/**
<p>Returns the paint device on which this painter is currently painting, or 0 if the painter is not active.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QMatrix deviceMatrix()" doc="/**
<p>Returns the matrix that transforms from logical coordinates to device coordinates of the platform dependent paint device.</p>
<p>This function is <i>only</i> needed when using platform painting commands on the platform dependent handle ( Qt::HANDLE), and the platform does not do transformations nativly.</p>
<p>The QPaintEngine::PaintEngineFeature enum can be queried to determine whether the platform performs the transformations or not.</p>

*/"/>
    <method name="public final void drawArc(com.trolltech.qt.core.QRect arg__0, int a__1, int alen__2)" doc="/**
<p>Draws the arc defined by the given <i>rectangle</i>, <i>startAngle</i> and <i>spanAngle</i>.</p>

*/"/>
    <method name="public final void drawArc(com.trolltech.qt.core.QRectF rect__0, int a__1, int alen__2)" doc="/**
<p>Draws the arc defined by the given <i>rectangle</i>, <i>startAngle</i> and <i>spanAngle</i>.</p>
<p>The <i>startAngle</i> and <i>spanAngle</i> must be specified in 1/16th of a degree, i.e. a full circle equals 5760 (16 * 360). Positive values for the angles mean counter-clockwise while negative values mean the clockwise direction. Zero degrees is at the 3 o'clock position.</p>
<p><table width=&quote;100%&quote; align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><font color=&quote;red&quote;>[Missing image qpainter-arc.png]</font></td><td><pre>    QRectF rectangle(10.0, 20.0, 80.0, 60.0);
    int startAngle = 30 * 16;
    int spanAngle = 120 * 16;

    QPainter painter(this);
    painter.drawArc(rectangle, startAngle, spanAngle);</pre>
</td></tr>
</table></p>

*/"/>
    <method name="public final void drawArc(int x__0, int y__1, int w__2, int h__3, int a__4, int alen__5)" doc="/**
<p>Draws the arc defined by the rectangle beginning at (<i>x</i>, <i>y</i>) with the specified <i>width</i> and <i>height</i>, and the given <i>startAngle</i> and <i>spanAngle</i>.</p>

*/"/>
    <method name="public final void drawChord(int x__0, int y__1, int w__2, int h__3, int a__4, int alen__5)" doc="/**
<p>Draws the chord defined by the rectangle beginning at (<i>x</i>, <i>y</i>) with the specified <i>width</i> and <i>height</i>, and the given <i>startAngle</i> and <i>spanAngle</i>.</p>

*/"/>
    <method name="public final void drawChord(com.trolltech.qt.core.QRect arg__0, int a__1, int alen__2)" doc="/**
<p>Draws the chord defined by the given <i>rectangle</i>, <i>startAngle</i> and <i>spanAngle</i>.</p>

*/"/>
    <method name="public final void drawChord(com.trolltech.qt.core.QRectF rect__0, int a__1, int alen__2)" doc="/**
<p>Draws the chord defined by the given <i>rectangle</i>, <i>startAngle</i> and <i>spanAngle</i>. The chord is filled with the current brush().</p>
<p>The startAngle and spanAngle must be specified in 1/16th of a degree, i.e. a full circle equals 5760 (16 * 360). Positive values for the angles mean counter-clockwise while negative values mean the clockwise direction. Zero degrees is at the 3 o'clock position.</p>
<p><table width=&quote;100%&quote; align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><font color=&quote;red&quote;>[Missing image qpainter-chord.png]</font></td><td><pre>    QRectF rectangle(10.0, 20.0, 80.0, 60.0);
    int startAngle = 30 * 16;
    int spanAngle = 120 * 16;

    QPainter painter(this);
    painter.drawChord(rect, startAngle, spanAngle);</pre>
</td></tr>
</table></p>

*/"/>
    <method name="public final void drawConvexPolygon(com.trolltech.qt.gui.QPolygon polygon__0)" doc="/**
<p>Draws the convex polygon defined by <i>polygon</i> using the current pen and brush.</p>

*/"/>
    <method name="public final void drawConvexPolygon(com.trolltech.qt.gui.QPolygonF polygon__0)" doc="/**
<p>Draws the convex polygon defined by <i>polygon</i> using the current pen and brush.</p>

*/"/>
    <method name="public final void drawEllipse(com.trolltech.qt.core.QRect r__0)" doc="/**
<p>Draws the ellipse defined by the given <i>rectangle</i>.</p>

*/"/>
    <method name="public final void drawEllipse(com.trolltech.qt.core.QRectF r__0)" doc="/**
<p>Draws the ellipse defined by the given <i>rectangle</i>.</p>
<p>A filled ellipse has a size of <i>rectangle</i>.size(). A stroked ellipse has a size of <i>rectangle</i>.size() plus the pen width.</p>
<p><table width=&quote;100%&quote; align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><font color=&quote;red&quote;>[Missing image qpainter-ellipse.png]</font></td><td><pre>    QRectF rectangle(10.0, 20.0, 80.0, 60.0);

    QPainter painter(this);
    painter.drawEllipse(rectangle);</pre>
</td></tr>
</table></p>

*/"/>
    <method name="public final void drawEllipse(int x__0, int y__1, int w__2, int h__3)" doc="/**
<p>Draws the ellipse defined by the rectangle beginning at (<i>x</i>, <i>y</i>) with the given <i>width</i> and <i>height</i>.</p>

*/"/>
    <method name="public final void drawImage(com.trolltech.qt.core.QPointF p__0, com.trolltech.qt.gui.QImage image__1)" doc="/**
<p>Draws the given <i>image</i> at the given <i>point</i>.</p>

*/"/>
    <method name="public final void drawImage(com.trolltech.qt.core.QRectF r__0, com.trolltech.qt.gui.QImage image__1)" doc="/**
<p>Draws the given <i>image</i> into the given <i>rectangle</i>.</p>

*/"/>
    <method name="public final void drawImage(com.trolltech.qt.core.QPoint p__0, com.trolltech.qt.gui.QImage image__1)" doc="/**
<p>Draws the given <i>image</i> at the given <i>point</i>.</p>

*/"/>
    <method name="public final void drawImage(com.trolltech.qt.core.QRect r__0, com.trolltech.qt.gui.QImage image__1)" doc="/**
<p>Draws the given <i>image</i> into the given <i>rectangle</i>.</p>

*/"/>
    <method name="public final void drawImage(int x__0, int y__1, com.trolltech.qt.gui.QImage image__2, int sx__3, int sy__4, int sw__5, int sh__6, com.trolltech.qt.core.Qt.ImageConversionFlags flags__7)" doc="/**
<p>Draws an image at (<i>x</i>, <i>y</i>) by copying a part of <i>image</i> into the paint device.</p>
<p>(<i>x</i>, <i>y</i>) specifies the top-left point in the paint device that is to be drawn onto. (<i>sx</i>, <i>sy</i>) specifies the top-left point in <i>image</i> that is to be drawn. The default is (0, 0).</p>
<p>(<i>sw</i>, <i>sh</i>) specifies the size of the image that is to be drawn. The default, (-1, -1), means all the way to the bottom-right of the image.</p>

*/"/>
    <method name="public final void drawLine(com.trolltech.qt.core.QPoint p1__0, com.trolltech.qt.core.QPoint p2__1)" doc="/**
<p>Draws a line from <i>p1</i> to <i>p2</i>.</p>

*/"/>
    <method name="public final void drawLine(int x1__0, int y1__1, int x2__2, int y2__3)" doc="/**
<p>Draws a line from (<i>x1</i>, <i>y1</i>) to (<i>x2</i>, <i>y2</i>) and sets the current pen position to (<i>x2</i>, <i>y2</i>).</p>

*/"/>
    <method name="public final void drawLine(com.trolltech.qt.gui.QLine line__0)" doc="/**
<p>Draws a line defined by <i>line</i>.</p>

*/"/>
    <method name="public final void drawLine(com.trolltech.qt.gui.QLineF line__0)" doc="/**
<p>Draws a line defined by <i>line</i>.</p>
<p><table width=&quote;100%&quote; align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><font color=&quote;red&quote;>[Missing image qpainter-line.png]</font></td><td><pre>    QLineF line(10.0, 80.0, 90.0, 20.0);

    QPainter(this);
    painter.drawLine(line);</pre>
</td></tr>
</table></p>

*/"/>
    <method name="public final void drawLine(com.trolltech.qt.core.QPointF p1__0, com.trolltech.qt.core.QPointF p2__1)" doc="/**
<p>Draws a line from <i>p1</i> to <i>p2</i>.</p>

*/"/>
    <method name="public final void drawLines(java.util.List&lt;com.trolltech.qt.core.QPoint&gt; pointPairs__0)" doc="/**
<p>Draws a line for each pair of points in the vector <i>pointPairs</i> using the current pen.</p>

*/"/>
    <method name="public final void drawPath(com.trolltech.qt.gui.QPainterPath path__0)" doc="/**
<p>Draws the given painter <i>path</i> using the current pen for outline and the current brush for filling.</p>
<p><table width=&quote;100%&quote; align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><font color=&quote;red&quote;>[Missing image qpainter-path.png]</font></td><td><pre>    QPainterPath path;
    path.moveTo(20, 80);
    path.lineTo(20, 30);
    path.cubicTo(80, 0, 50, 50, 80, 80);

    QPainter painter(this);
    painter.drawPath(path);</pre>
</td></tr>
</table></p>

*/"/>
    <method name="public final void drawPicture(com.trolltech.qt.core.QPointF p__0, com.trolltech.qt.gui.QPicture picture__1)" doc="/**
<p>Replays the given <i>picture</i> at the given <i>point</i>.</p>
<p>The QPicture class is a paint device that records and replays QPainter commands. A picture serializes the painter commands to an IO device in a platform-independent format. Everything that can be painted on a widget or pixmap can also be stored in a picture.</p>
<p>This function does exactly the same as QPicture::play() when called with <i>point</i> = QPoint(0, 0).</p>
<p><table width=&quote;100%&quote; align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><pre>    QPicture picture;
    QPointF point(10.0, 20.0)
    picture.load(&quot;drawing.pic&quot;);

    QPainter painter(this);
    painter.drawPicture(0, 0, picture);</pre>
</td></tr>
</table></p>

*/"/>
    <method name="public final void drawPicture(com.trolltech.qt.core.QPoint p__0, com.trolltech.qt.gui.QPicture picture__1)" doc="/**
<p>Replays the given <i>picture</i> at the given <i>point</i>.</p>

*/"/>
    <method name="public final void drawPicture(int x__0, int y__1, com.trolltech.qt.gui.QPicture picture__2)" doc="/**
<p>Draws the given <i>picture</i> at point (<i>x</i>, <i>y</i>).</p>

*/"/>
    <method name="public final void drawPie(com.trolltech.qt.core.QRect arg__0, int a__1, int alen__2)" doc="/**
<p>Draws a pie defined by the given <i>rectangle</i>, <i>startAngle</i> and and <i>spanAngle</i>.</p>

*/"/>
    <method name="public final void drawPie(com.trolltech.qt.core.QRectF rect__0, int a__1, int alen__2)" doc="/**
<p>Draws a pie defined by the given <i>rectangle</i>, <i>startAngle</i> and and <i>spanAngle</i>.</p>
<p>The pie is filled with the current brush().</p>
<p>The startAngle and spanAngle must be specified in 1/16th of a degree, i.e. a full circle equals 5760 (16 * 360). Positive values for the angles mean counter-clockwise while negative values mean the clockwise direction. Zero degrees is at the 3 o'clock position.</p>
<p><table width=&quote;100%&quote; align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><font color=&quote;red&quote;>[Missing image qpainter-pie.png]</font></td><td><pre>    QRectF rectangle(10.0, 20.0, 80.0, 60.0);
    int startAngle = 30 * 16;
    int spanAngle = 120 * 16;

    QPainter painter(this);
    painter.drawPie(rectangle, startAngle, spanAngle);</pre>
</td></tr>
</table></p>

*/"/>
    <method name="public final void drawPie(int x__0, int y__1, int w__2, int h__3, int a__4, int alen__5)" doc="/**
<p>Draws the pie defined by the rectangle beginning at (<i>x</i>, <i>y</i>) with the specified <i>width</i> and <i>height</i>, and the given <i>startAngle</i> and <i>spanAngle</i>.</p>

*/"/>
    <method name="public final void drawPixmap(com.trolltech.qt.core.QPoint p__0, com.trolltech.qt.gui.QPixmap pm__1)" doc="/**
<p>Draws the given <i>pixmap</i> with its origin at the given <i>point</i>.</p>

*/"/>
    <method name="public final void drawPixmap(com.trolltech.qt.core.QRect targetRect__0, com.trolltech.qt.gui.QPixmap pixmap__1, com.trolltech.qt.core.QRect sourceRect__2)" doc="/**
<p>Draws the rectangular portion <i>source</i> of the given <i>pixmap</i> into the given <i>target</i> in the paint device.</p>

*/"/>
    <method name="public final void drawPixmap(com.trolltech.qt.core.QPointF p__0, com.trolltech.qt.gui.QPixmap pm__1)" doc="/**
<p>Draws the given <i>pixmap</i> with its origin at the given <i>point</i>.</p>

*/"/>
    <method name="public final void drawPixmap(int x__0, int y__1, com.trolltech.qt.gui.QPixmap pm__2, int sx__3, int sy__4, int sw__5, int sh__6)" doc="/**
<p>Draws a pixmap at (<i>x</i>, <i>y</i>) by copying a part of the given <i>pixmap</i> into the paint device.</p>
<p>(<i>x</i>, <i>y</i>) specifies the top-left point in the paint device that is to be drawn onto. (<i>sx</i>, <i>sy</i>) specifies the top-left point in <i>pixmap</i> that is to be drawn. The default is (0, 0).</p>
<p>(<i>sw</i>, <i>sh</i>) specifies the size of the pixmap that is to be drawn. The default, (-1, -1), means all the way to the bottom-right of the pixmap.</p>

*/"/>
    <method name="public final void drawPixmap(com.trolltech.qt.core.QPoint p__0, com.trolltech.qt.gui.QPixmap pm__1, com.trolltech.qt.core.QRect sr__2)" doc="/**
<p>Draws the rectangular portion <i>source</i> of the given <i>pixmap</i> with its origin at the given <i>point</i>.</p>

*/"/>
    <method name="public final void drawPixmap(int x__0, int y__1, com.trolltech.qt.gui.QPixmap pm__2)" doc="/**
<p>Draws the given <i>pixmap</i> at position (<i>x</i>, <i>y</i>).</p>

*/"/>
    <method name="public final void drawPixmap(com.trolltech.qt.core.QRect r__0, com.trolltech.qt.gui.QPixmap pm__1)" doc="/**
<p>Draws the given <i>pixmap</i> into the given <i>rectangle</i>.</p>

*/"/>
    <method name="public final void drawPixmap(int x__0, int y__1, int w__2, int h__3, com.trolltech.qt.gui.QPixmap pm__4, int sx__5, int sy__6, int sw__7, int sh__8)" doc="/**
<p>Draws the rectangular portion with the origin (<i>sx</i>, <i>sy</i>), width <i>sw</i> and height <i>sh</i>, of the given <i>pixmap</i> , at the point (<i>x</i>, <i>y</i>), with a width of <i>w</i> and a height of <i>h</i>.</p>

*/"/>
    <method name="public final void drawPixmap(int x__0, int y__1, int w__2, int h__3, com.trolltech.qt.gui.QPixmap pm__4)" doc="/**
<p>Draws the <i>pixmap</i> into the rectangle at position (<i>x</i>, <i>y</i>) with the given <i>width</i> and <i>height</i>.</p>

*/"/>
    <method name="public final void drawPixmap(com.trolltech.qt.core.QRectF targetRect__0, com.trolltech.qt.gui.QPixmap pixmap__1, com.trolltech.qt.core.QRectF sourceRect__2)" doc="/**
<p>Draws the rectangular portion <i>source</i> of the given <i>pixmap</i> into the given <i>target</i> in the paint device.</p>
<p><table width=&quote;100%&quote; align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><pre>    QRectF target(10.0, 20.0, 80.0, 60.0);
    QRectF source(0.0, 0.0, 70.0, 40.0);
    QPixmap pixmap(&quot;:myPixmap.png&quot;);

    QPainter(this);
    painter.drawPixmap(target, image, source);</pre>
</td></tr>
</table></p>

*/"/>
    <method name="public final void drawPixmap(com.trolltech.qt.core.QPointF p__0, com.trolltech.qt.gui.QPixmap pm__1, com.trolltech.qt.core.QRectF sr__2)" doc="/**
<p>Draws the rectangular portion <i>source</i> of the given <i>pixmap</i> with its origin at the given <i>point</i>.</p>

*/"/>
    <method name="public final void drawPoint(com.trolltech.qt.core.QPoint p__0)" doc="/**
<p>Draws a single point at the given <i>position</i> using the current pen's color.</p>

*/"/>
    <method name="public final void drawPoint(int x__0, int y__1)" doc="/**
<p>Draws a single point at position (<i>x</i>, <i>y</i>).</p>

*/"/>
    <method name="public final void drawPoint(com.trolltech.qt.core.QPointF pt__0)" doc="/**
<p>Draws a single point at the given <i>position</i> using the current pen's color.</p>

*/"/>
    <method name="public final void drawPoints(com.trolltech.qt.gui.QPolygon points__0)" doc="/**
<p>Draws the points in the vector <i>points</i>.</p>

*/"/>
    <method name="public final void drawPoints(com.trolltech.qt.gui.QPolygonF points__0)" doc="/**
<p>Draws the points in the vector <i>points</i>.</p>

*/"/>
    <method name="public final void drawPolygon(com.trolltech.qt.gui.QPolygonF polygon__0, com.trolltech.qt.core.Qt.FillRule fillRule__1)" doc="/**
<p>Draws the polygon defined by the given <i>points</i> using the fill rule <i>fillRule</i>.</p>

*/"/>
    <method name="public final void drawPolygon(com.trolltech.qt.gui.QPolygon polygon__0, com.trolltech.qt.core.Qt.FillRule fillRule__1)" doc="/**
<p>Draws the polygon defined by the given <i>points</i> using the fill rule <i>fillRule</i>.</p>

*/"/>
    <method name="public final void drawPolyline(com.trolltech.qt.gui.QPolygonF polyline__0)" doc="/**
<p>Draws the polyline defined by the given <i>points</i> using the current pen.</p>

*/"/>
    <method name="public final void drawPolyline(com.trolltech.qt.gui.QPolygon polygon__0)" doc="/**
<p>Draws the polyline defined by the given <i>points</i> using the current pen.</p>

*/"/>
    <method name="public final void drawRect(com.trolltech.qt.core.QRectF rect__0)" doc="/**
<p>Draws the current <i>rectangle</i> with the current pen and brush.</p>
<p>A filled rectangle has a size of <i>rectangle</i>.size(). A stroked rectangle has a size of <i>rectangle</i>.size() plus the pen width.</p>
<p><table width=&quote;100%&quote; align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><font color=&quote;red&quote;>[Missing image qpainter-rectangle.png]</font></td><td><pre>    QRectF rectangle(10.0, 20.0, 80.0, 60.0);

    QPainter painter(this);
    painter.drawRect(rectangle);</pre>
</td></tr>
</table></p>

*/"/>
    <method name="public final void drawRect(int x1__0, int y1__1, int w__2, int h__3)" doc="/**
<p>Draws a rectangle with upper left corner at (<i>x</i>, <i>y</i>) and with the given <i>width</i> and <i>height</i>.</p>

*/"/>
    <method name="public final void drawRect(com.trolltech.qt.core.QRect rect__0)" doc="/**
<p>Draws the current <i>rectangle</i> with the current pen and brush.</p>

*/"/>
    <method name="public final void drawRects(java.util.List&lt;com.trolltech.qt.core.QRect&gt; rectangles__0)" doc="/**
<p>Draws the given <i>rectangles</i> using the current pen and brush.</p>

*/"/>
    <method name="public final void drawRoundRect(com.trolltech.qt.core.QRect r__0, int xround__1, int yround__2)" doc="/**
<p>Draws the rectangle <i>r</i> with rounded corners.</p>

*/"/>
    <method name="public final void drawRoundRect(com.trolltech.qt.core.QRectF r__0, int xround__1, int yround__2)" doc="/**
<p>Draws a rectangle <i>r</i> with rounded corners.</p>
<p>The <i>xRnd</i> and <i>yRnd</i> arguments specify how rounded the corners should be. 0 is angled corners, 99 is maximum roundedness.</p>
<p>A filled rectangle has a size of r.size(). A stroked rectangle has a size of r.size() plus the pen width.</p>
<p><table width=&quote;100%&quote; align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><font color=&quote;red&quote;>[Missing image qpainter-roundrect.png]</font></td><td><pre>    QRectF rectangle(10.0, 20.0, 80.0, 60.0);

    QPainter painter(this);
    painter.drawRoundRect(rectangle);</pre>
</td></tr>
</table></p>

*/"/>
    <method name="public final void drawRoundRect(int x__0, int y__1, int w__2, int h__3, int arg__4, int arg__5)" doc="/**
<p>Draws the rectangle <i>x</i>, <i>y</i>, <i>w</i>, <i>h</i> with rounded corners.</p>

*/"/>
    <method name="public final void drawText(com.trolltech.qt.core.QRect r__0, int flags__1, java.lang.String text__2, com.trolltech.qt.QNativePointer br__3)" doc="/**
<p>Draws the given <i>text</i> within the provided <i>rectangle</i> according to the specified <i>flags</i>. The <i>boundingRect</i> (if not null) is set to the actual bounding rectangle of the output.</p>

*/"/>
    <method name="public final void drawText(com.trolltech.qt.core.QRectF r__0, java.lang.String text__1, com.trolltech.qt.gui.QTextOption o__2)" doc="/**
<p>Draws the given <i>text</i> in the <i>rectangle</i> specified using the <i>option</i> to control its positioning and orientation.</p>

*/"/>
    <method name="public final void drawText(int x__0, int y__1, int w__2, int h__3, int flags__4, java.lang.String text__5, com.trolltech.qt.QNativePointer br__6)" doc="/**
<p>Draws the given <i>text</i> within the rectangle with origin (<i>x</i>, <i>y</i>), <i>width</i> and <i>height</i>.</p>
<p>The <i>boundingRect</i> (if not null) is set to the actual bounding rectangle of the output. The <i>flags</i> argument is a bitwise OR of the following flags:</p>
<ul>
<li>Qt::AlignLeft</li>
<li>Qt::AlignRight</li>
<li>Qt::AlignHCenter</li>
<li>Qt::AlignTop</li>
<li>Qt::AlignBottom</li>
<li>Qt::AlignVCenter</li>
<li>Qt::AlignCenter</li>
<li>Qt::TextSingleLine</li>
<li>Qt::TextExpandTabs</li>
<li>Qt::TextShowMnemonic</li>
<li>Qt::TextWordWrap</li>
</ul>

*/"/>
    <method name="public final void drawText(com.trolltech.qt.core.QPointF p__0, java.lang.String s__1)" doc="/**
<p>Draws the given <i>text</i> with the currently defined text direction, beginning at the given <i>position</i>.</p>
<p>This function does not break text into multiple lines. Use the QPainter::drawText() overload that takes a rectangle instead if you want line breaking.</p>

*/"/>
    <method name="public final void drawText(com.trolltech.qt.core.QPoint p__0, java.lang.String s__1)" doc="/**
<p>Draws the given <i>text</i> with the currently defined text direction, beginning at the given <i>position</i>.</p>

*/"/>
    <method name="public final void drawText(com.trolltech.qt.core.QRectF r__0, int flags__1, java.lang.String text__2, com.trolltech.qt.QNativePointer br__3)" doc="/**
<p>Draws the given <i>text</i> within the provided <i>rectangle</i>.</p>
<p><table width=&quote;100%&quote; align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><font color=&quote;red&quote;>[Missing image qpainter-text.png]</font></td><td><pre>    QPainter painter(this);
    painter.drawText(rect, Qt::AlignCenter, tr(&quot;Qt by\nTrolltech&quot;));</pre>
</td></tr>
</table></p>
<p>The <i>boundingRect</i> (if not null) is set to the actual bounding rectangle of the output. The <i>flags</i> argument is a bitwise OR of the following flags:</p>
<ul>
<li>Qt::AlignLeft</li>
<li>Qt::AlignRight</li>
<li>Qt::AlignHCenter</li>
<li>Qt::AlignTop</li>
<li>Qt::AlignBottom</li>
<li>Qt::AlignVCenter</li>
<li>Qt::AlignCenter</li>
<li>Qt::TextSingleLine</li>
<li>Qt::TextExpandTabs</li>
<li>Qt::TextShowMnemonic</li>
<li>Qt::TextWordWrap</li>
</ul>

*/"/>
    <method name="public final void drawText(int x__0, int y__1, java.lang.String s__2)" doc="/**
<p>Draws the given <i>text</i> at position (<i>x</i>, <i>y</i>), using the painter's currently defined text direction.</p>

*/"/>
    <method name="public final void drawTextItem(com.trolltech.qt.core.QPointF p__0, com.trolltech.qt.gui.QTextItem ti__1)"/>
    <method name="public final void drawTextItem(com.trolltech.qt.core.QPoint p__0, com.trolltech.qt.gui.QTextItem ti__1)" doc="/**
<p>Draws the text item <i>ti</i> at position <i>p</i>.</p>

*/"/>
    <method name="public final void drawTextItem(int x__0, int y__1, com.trolltech.qt.gui.QTextItem ti__2)"/>
    <method name="public final void drawTiledPixmap(com.trolltech.qt.core.QRectF rect__0, com.trolltech.qt.gui.QPixmap pm__1, com.trolltech.qt.core.QPointF offset__2)" doc="/**
<p>Draws a tiled <i>pixmap</i>, inside the given <i>rectangle</i> with its origin at the given <i>position</i>.</p>
<p>Calling drawTiledPixmap() is similar to calling drawPixmap() several times to fill (tile) an area with a pixmap, but is potentially much more efficient depending on the underlying window system.</p>

*/"/>
    <method name="public final void drawTiledPixmap(int x__0, int y__1, int w__2, int h__3, com.trolltech.qt.gui.QPixmap arg__4, int sx__5, int sy__6)" doc="/**
<p>Draws a tiled <i>pixmap</i> in the specified rectangle.</p>
<p>(<i>x</i>, <i>y</i>) specifies the top-left point in the paint device that is to be drawn onto; with the given <i>width</i> and <i>height</i>. (<i>sx</i>, <i>sy</i>) specifies the top-left point in the <i>pixmap</i> that is to be drawn; this defaults to (0, 0).</p>

*/"/>
    <method name="public final void drawTiledPixmap(com.trolltech.qt.core.QRect arg__0, com.trolltech.qt.gui.QPixmap arg__1, com.trolltech.qt.core.QPoint arg__2)" doc="/**
<p>Draws a tiled <i>pixmap</i>, inside the given <i>rectangle</i> with its origin at the given <i>position</i>.</p>

*/"/>
    <method name="public final boolean end()" doc="/**
<p>Ends painting. Any resources used while painting are released. You don't normally need to call this since it is called by the destructor.</p>

*/"/>
    <method name="public final void eraseRect(com.trolltech.qt.core.QRectF arg__0)" doc="/**
<p>Erases the area inside the given <i>rectangle</i>. Equivalent to calling</p>
<pre>    fillRect(rectangle, background()).</pre>

*/"/>
    <method name="public final void eraseRect(com.trolltech.qt.core.QRect arg__0)" doc="/**
<p>Erases the area inside the given <i>rectangle</i>.</p>

*/"/>
    <method name="public final void eraseRect(int x__0, int y__1, int w__2, int h__3)" doc="/**
<p>Erases the area inside the rectangle beginning at (<i>x</i>, <i>y</i>) with the given <i>width</i> and <i>height</i>.</p>

*/"/>
    <method name="public final void fillPath(com.trolltech.qt.gui.QPainterPath path__0, com.trolltech.qt.gui.QBrush brush__1)" doc="/**
<p>Fills the given <i>path</i> using the given <i>brush</i>. The outline is not drawn.</p>
<p>Alternatively, you can specify a QColor instead of a QBrush; the QBrush constructor (taking a QColor argument) will automatically create a solid pattern brush.</p>

*/"/>
    <method name="public final void fillRect(com.trolltech.qt.core.QRectF arg__0, com.trolltech.qt.gui.QBrush arg__1)" doc="/**
<p>Fills the given <i>rectangle</i> with the given <i>brush</i>.</p>
<p>Alternatively, you can specify a QColor instead of a QBrush; the QBrush constructor (taking a QColor argument) will automatically create a solid pattern brush.</p>

*/"/>
    <method name="public final void fillRect(com.trolltech.qt.core.QRect arg__0, com.trolltech.qt.gui.QBrush arg__1)" doc="/**
<p>Fills the given <i>rectangle</i> with the given <i>brush</i>.</p>

*/"/>
    <method name="public final void fillRect(int x__0, int y__1, int w__2, int h__3, com.trolltech.qt.gui.QBrush arg__4)" doc="/**
<p>Fills the rectangle beginning at (<i>x</i>, <i>y</i>) with the given <i>width</i> and <i>height</i>, using the given <i>brush</i>.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QFont font()" doc="/**
<p>Returns the currently set font used for drawing text.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QFontInfo fontInfo()" doc="/**
<p>Returns the font info for the painter if the painter is active. Otherwise, the return value is undefined.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QFontMetrics fontMetrics()" doc="/**
<p>Returns the font metrics for the painter if the painter is active. Otherwise, the return value is undefined.</p>

*/"/>
    <method name="public final boolean hasClipping()" doc="/**
<p>Returns true if clipping has been set; otherwise returns false.</p>

*/"/>
    <method name="public final void initFrom(com.trolltech.qt.gui.QWidget widget__0)" doc="/**
<p>Initializes the painters pen, background and font to the same as the given <i>widget</i>. Call this function after begin() while the painter is active.</p>

*/"/>
    <method name="public final boolean isActive()" doc="/**
<p>Returns true if begin() has been called and end() has not yet been called; otherwise returns false.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.Qt.LayoutDirection layoutDirection()" doc="/**
<p>Returns the layout direction used by the painter when drawing text.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QMatrix matrix()" doc="/**
<p>Use worldMatrix() instead.</p>

*/"/>
    <method name="public final boolean matrixEnabled()" doc="/**
<p>Use worldMatrixEnabled() instead</p>

*/"/>
    <method name="public final double opacity()" doc="/**
<p>Returns the opacity of the painter. The default value is 1.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QPaintEngine paintEngine()" doc="/**
<p>Returns the paint engine that the painter is currently operating on if the painter is active; otherwise 0.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QPen pen()" doc="/**
<p>Returns the painter's current pen.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QPainter.RenderHints renderHints()" doc="/**
<p>Returns a flag that specifies the rendering hints that are set for this painter.</p>

*/"/>
    <method name="public final void resetMatrix()" doc="/**
<p>Resets any transformations that were made using translate(), scale(), shear(), rotate(), setWorldMatrix(), setViewport() and setWindow().</p>

*/"/>
    <method name="public final void restore()" doc="/**
<p>Restores the current painter state (pops a saved state off the stack).</p>

*/"/>
    <method name="public final void rotate(double a__0)" doc="/**
<p>Rotates the coordinate system the given <i>angle</i> clockwise.</p>

*/"/>
    <method name="public final void save()" doc="/**
<p>Saves the current painter state (pushes the state onto a stack). A save() must be followed by a corresponding restore(); the end() function unwinds the stack.</p>

*/"/>
    <method name="public final void scale(double sx__0, double sy__1)" doc="/**
<p>Scales the coordinate system by (<i>sx</i>, <i>sy</i>).</p>

*/"/>
    <method name="public final void setBackground(com.trolltech.qt.gui.QBrush bg__0)" doc="/**
<p>Sets the background brush of the painter to the given <i>brush</i>.</p>
<p>The background brush is the brush that is filled in when drawing opaque text, stippled lines and bitmaps. The background brush has no effect in transparent background mode (which is the default).</p>

*/"/>
    <method name="public final void setBackgroundMode(com.trolltech.qt.core.Qt.BGMode mode__0)" doc="/**
<p>Sets the background mode of the painter to the given <i>mode</i></p>
<p>Qt::TransparentMode (the default) draws stippled lines and text without setting the background pixels. Qt::OpaqueMode fills these space with the current background color.</p>
<p>Note that in order to draw a bitmap or pixmap transparently, you must use QPixmap::setMask().</p>

*/"/>
    <method name="public final void setBrush(com.trolltech.qt.core.Qt.BrushStyle style__0)" doc="/**
<p>Sets the painter's brush to black color and the specified <i>style</i>.</p>

*/"/>
    <method name="public final void setBrush(com.trolltech.qt.gui.QBrush brush__0)" doc="/**
<p>Sets the painter's brush to the given <i>brush</i>.</p>
<p>The painter's brush defines how shapes are filled.</p>

*/"/>
    <method name="public final void setBrushOrigin(int x__0, int y__1)" doc="/**
<p>Sets the brush's origin to point (<i>x</i>, <i>y</i>).</p>

*/"/>
    <method name="public final void setBrushOrigin(com.trolltech.qt.core.QPointF arg__0)" doc="/**
<p>Sets the brush origin to <i>position</i>.</p>
<p>The brush origin specifies the (0, 0) coordinate of the painter's brush. This setting only applies to pattern brushes and pixmap brushes.</p>
<p>Note that while the brushOrigin() was necessary to adopt the parent's background for a widget in Qt 3, this is no longer the case since the Qt 4 painter doesn't paint the background unless you explicitly tell it to do so by setting the widget's autoFillBackground property to true.</p>

*/"/>
    <method name="public final void setBrushOrigin(com.trolltech.qt.core.QPoint arg__0)" doc="/**
<p>Sets the brush's origin to the given <i>position</i>.</p>

*/"/>
    <method name="public final void setClipPath(com.trolltech.qt.gui.QPainterPath path__0, com.trolltech.qt.core.Qt.ClipOperation op__1)" doc="/**
<p>Enables clipping, and sets the clip path for the painter to the given <i>path</i>, with the clip <i>operation</i>.</p>
<p>Note that the clip path is specified in logical (painter) coordinates.</p>

*/"/>
    <method name="public final void setClipRect(com.trolltech.qt.core.QRect arg__0, com.trolltech.qt.core.Qt.ClipOperation op__1)" doc="/**
<p>Enables clipping, and sets the clip region to the given <i>rectangle</i> using the given clip <i>operation</i>.</p>

*/"/>
    <method name="public final void setClipRect(com.trolltech.qt.core.QRectF arg__0, com.trolltech.qt.core.Qt.ClipOperation op__1)" doc="/**
<p>Enables clipping, and sets the clip region to the given <i>rectangle</i> using the given clip <i>operation</i>. The default operation is to replace the current clip rectangle.</p>
<p>Note that the clip rectangle is specified in logical (painter) coordinates.</p>

*/"/>
    <method name="public final void setClipRect(int x__0, int y__1, int w__2, int h__3, com.trolltech.qt.core.Qt.ClipOperation op__4)" doc="/**
<p>Enables clipping, and sets the clip region to the rectangle beginning at (<i>x</i>, <i>y</i>) with the given <i>width</i> and <i>height</i>.</p>

*/"/>
    <method name="public final void setClipRegion(com.trolltech.qt.gui.QRegion arg__0, com.trolltech.qt.core.Qt.ClipOperation op__1)" doc="/**
<p>Sets the clip region to the givne <i>region</i> using the given clip <i>operation</i>. The default clip operation is to replace the current clip region.</p>
<p>Note that the clip region is given in logical coordinates.</p>

*/"/>
    <method name="public final void setClipping(boolean enable__0)" doc="/**
<p>Enables clipping if <i>enable</i> is true, or disables clipping if <i>enable</i> is false.</p>

*/"/>
    <method name="public final void setCompositionMode(com.trolltech.qt.gui.QPainter.CompositionMode mode__0)" doc="/**
<p>Sets the composition mode to the given <i>mode</i>.</p>
<p><b>Warning:</b> You can only set the composition mode for QPainter objects that operates on a QImage.</p>

*/"/>
    <method name="public final void setFont(com.trolltech.qt.gui.QFont f__0)" doc="/**
<p>Sets the painter's font to the given <i>font</i>.</p>
<p>This font is used by subsequent drawText() functions. The text color is the same as the pen color.</p>
<p>If you set a font that isn't available, Qt finds a close match. font() will return what you set using setFont() and fontInfo() returns the font actually being used (which may be the same).</p>

*/"/>
    <method name="public final void setLayoutDirection(com.trolltech.qt.core.Qt.LayoutDirection direction__0)" doc="/**
<p>Sets the layout direction used by the painter when drawing text, to the specified <i>direction</i>.</p>

*/"/>
    <method name="public final void setMatrix(com.trolltech.qt.gui.QMatrix matrix__0, boolean combine__1)" doc="/**
<p>Use setWorldMatrix() instead.</p>

*/"/>
    <method name="public final void setMatrixEnabled(boolean enabled__0)" doc="/**
<p>Use setWorldMatrixEnabled() instead.</p>

*/"/>
    <method name="public final void setOpacity(double opacity__0)" doc="/**
<p>Sets the opacity of the painter to <i>opacity</i>. The value should be in the range 0.0 to 1.0, where 0.0 is fully transparent and 1.0 is fully opaque.</p>
<p>Opacity set on the painter will apply to all drawing operations individually.</p>

*/"/>
    <method name="public final void setPen(com.trolltech.qt.core.Qt.PenStyle style__0)" doc="/**
<p>Sets the painter's pen to have the given <i>style</i>, width 0 and black color.</p>

*/"/>
    <method name="public final void setPen(com.trolltech.qt.gui.QPen pen__0)" doc="/**
<p>Sets the painter's pen to be the given <i>pen</i>.</p>
<p>The <i>pen</i> defines how to draw lines and outlines, and it also defines the text color.</p>

*/"/>
    <method name="public final void setPen(com.trolltech.qt.gui.QColor color__0)" doc="/**
<p>Sets the painter's pen to have style Qt::SolidLine, width 0 and the specified <i>color</i>.</p>

*/"/>
    <method name="public final void setRenderHint(com.trolltech.qt.gui.QPainter.RenderHint hint__0, boolean on__1)" doc="/**
<p>Sets the given render <i>hint</i> on the painter if <i>on</i> is true; otherwise clears the render hint.</p>

*/"/>
    <method name="public final void setRenderHints(com.trolltech.qt.gui.QPainter.RenderHints hints__0, boolean on__1)" doc="/**
<p>Sets the given render <i>hints</i> on the painter if <i>on</i> is true; otherwise clears the render hints.</p>

*/"/>
    <method name="public final void setViewTransformEnabled(boolean enable__0)" doc="/**
<p>Enables view transformations if <i>enable</i> is true, or disables view transformations if <i>enable</i> is false.</p>

*/"/>
    <method name="public final void setViewport(int x__0, int y__1, int w__2, int h__3)" doc="/**
<p>Sets the painter's viewport rectangle to be the rectangle beginning at (<i>x</i>, <i>y</i>) with the given <i>width</i> and <i>height</i>.</p>

*/"/>
    <method name="public final void setViewport(com.trolltech.qt.core.QRect viewport__0)" doc="/**
<p>Sets the painter's viewport rectangle to the given <i>rectangle</i>, and enables view transformations.</p>
<p>The viewport rectangle is part of the view transformation. The viewport specifies the device coordinate system. Its sister, the window(), specifies the logical coordinate system.</p>
<p>The default viewport rectangle is the same as the device's rectangle.</p>

*/"/>
    <method name="public final void setWindow(com.trolltech.qt.core.QRect window__0)" doc="/**
<p>Sets the painter's window to the given <i>rectangle</i>, and enables view transformations.</p>
<p>The window rectangle is part of the view transformation. The window specifies the logical coordinate system. Its sister, the viewport(), specifies the device coordinate system.</p>
<p>The default window rectangle is the same as the device's rectangle.</p>

*/"/>
    <method name="public final void setWindow(int x__0, int y__1, int w__2, int h__3)" doc="/**
<p>Sets the painter's window to the rectangle beginning at (<i>x</i>, <i>y</i>) and the given <i>width</i> and <i>height</i>.</p>

*/"/>
    <method name="public final void setWorldMatrix(com.trolltech.qt.gui.QMatrix matrix__0, boolean combine__1)" doc="/**
<p>Sets the transformation matrix to <i>matrix</i> and enables transformations.</p>
<p>If <i>combine</i> is true, then <i>matrix</i> is combined with the current transformation matrix; otherwise <i>matrix</i> replaces the current transformation matrix.</p>
<p>If <i>matrix</i> is the identity matrix and <i>combine</i> is false, this function calls setWorldMatrixEnabled(false). (The identity matrix is the matrix where QMatrix::m11() and QMatrix::m22() are 1.0 and the rest are 0.0.)</p>
<p>The following functions can transform the coordinate system without using a QMatrix:</p>
<ul>
<li>translate()</li>
<li>scale()</li>
<li>shear()</li>
<li>rotate()</li>
</ul>
<p>They operate on the painter's worldMatrix() and are implemented like this:</p>
<pre>    void QPainter::rotate(qreal angle)
    {
        QMatrix matrix;
        matrix.rotate(angle);
        setWorldMatrix(matrix, true);
    }</pre>
<p>Note that when using setWorldMatrix() function you should always have <i>combine</i> be true when you are drawing into a QPicture. Otherwise it may not be possible to replay the picture with additional transformations; using the translate(), scale(), etc. convenience functions is safe.</p>
<p>For more information about the coordinate system, transformations and window-viewport conversion, see The Coordinate System documentation.</p>

*/"/>
    <method name="public final void setWorldMatrixEnabled(boolean enabled__0)" doc="/**
<p>Enables transformations if <i>enable</i> is true, or disables transformations if <i>enable</i> is false. The world transformation matrix is not changed.</p>

*/"/>
    <method name="public final void shear(double sh__0, double sv__1)" doc="/**
<p>Shears the coordinate system by (<i>sh</i>, <i>sv</i>).</p>

*/"/>
    <method name="public final void strokePath(com.trolltech.qt.gui.QPainterPath path__0, com.trolltech.qt.gui.QPen pen__1)" doc="/**
<p>Draws the outline (strokes) the path <i>path</i> with the pen specified by <i>pen</i></p>

*/"/>
    <method name="public final void translate(com.trolltech.qt.core.QPoint offset__0)" doc="/**
<p>Translates the coordinate system by the given <i>offset</i>.</p>

*/"/>
    <method name="public final void translate(double dx__0, double dy__1)" doc="/**
<p>Translates the coordinate system by the vector (<i>dx</i>, <i>dy</i>).</p>

*/"/>
    <method name="public final void translate(com.trolltech.qt.core.QPointF offset__0)" doc="/**
<p>Translates the coordinate system by the given <i>offset</i>; i.e. the given <i>offset</i> is added to points.</p>

*/"/>
    <method name="public final boolean viewTransformEnabled()" doc="/**
<p>Returns true if view transformation is enabled; otherwise returns false.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QRect viewport()" doc="/**
<p>Returns the viewport rectangle.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QRect window()" doc="/**
<p>Returns the window rectangle.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QMatrix worldMatrix()" doc="/**
<p>Returns the world transformation matrix.</p>

*/"/>
    <method name="public final boolean worldMatrixEnabled()" doc="/**
<p>Returns true if world transformation is enabled; otherwise returns false.</p>

*/"/>
    <method name="public boolean begin(com.trolltech.qt.gui.QPaintDeviceInterface arg__0)" doc="/**
<p>Begins painting the paint <i>device</i> and returns true if successful; otherwise returns false.</p>
<p>Notice that all painter settings (setPen(), setBrush() etc.) are reset to default values when begin() is called.</p>
<p>The errors that can occur are serious problems, such as these:</p>
<pre>    painter-&gt;begin(0); <span class=&quote;comment&quote;>// impossible - paint device cannot be 0</span>

    QPixmap image(0, 0);
    painter-&gt;begin(&amp;image); <span class=&quote;comment&quote;>// impossible - image.isNull() == true;</span>

    painter-&gt;begin(myWidget);
    painter2-&gt;begin(myWidget); <span class=&quote;comment&quote;>// impossible - only one painter at a time</span></pre>
<p>Note that most of the time, you can use one of the constructors instead of begin(), and that end() is automatically done at destruction.</p>
<p><b>Warning:</b> A paint device can only be painted by one painter at a time.</p>

*/"/>
    <method name="public final static com.trolltech.qt.gui.QPaintDeviceInterface redirected(com.trolltech.qt.gui.QPaintDeviceInterface device__0, com.trolltech.qt.QNativePointer offset__1)" doc="/**
<p>Returns the replacement for given <i>device</i>. The optional out parameter <i>offset</i> returns the offset within the replaced device.</p>

*/"/>
    <method name="public final static void restoreRedirected(com.trolltech.qt.gui.QPaintDeviceInterface device__0)" doc="/**
<p>Restores the previous redirection for the given <i>device</i> after a call to setRedirected().</p>

*/"/>
    <method name="public final static void setRedirected(com.trolltech.qt.gui.QPaintDeviceInterface device__0, com.trolltech.qt.gui.QPaintDeviceInterface replacement__1, com.trolltech.qt.core.QPoint offset__2)" doc="/**
<p>Redirects all paint commands for the given paint <i>device</i>, to the <i>replacement</i> device. The optional point <i>offset</i> defines an offset within the source device.</p>
<p>The redirection will not be effective until the begin() function has been called; make sure to call end() for the given <i>device</i>'s painter (if any) before redirecting. Call restoreRedirected() to restore the previous redirection.</p>
<p>In general, you'll probably find that calling QPixmap::grabWidget() or QPixmap::grabWindow() is an easier solution.</p>

*/"/>
    <enum name="CompositionMode" doc="/**
<p>Defines the Porter-Duff rules for digital image compositing. Composition modes are used to specify how the pixels in one image, the source, are merged with the pixel in another image, the destination.</p>
<p align=&quote;center&quote;><font color=&quote;red&quote;>[Missing image qpainter-compositionmode1.png]</font></p><p align=&quote;center&quote;><font color=&quote;red&quote;>[Missing image qpainter-compositionmode2.png]</font></p><p>The most common type is SourceOver (often referred to as just alpha blending) where the source pixel is blended on top of the destination pixel in such a way that the alpha component of the source defines the translucency of the pixel.</p>
<p>Composition modes will only work when the paint device is a QImage in Format_ARGB32_Premultiplied or Format_ARGB32, where the premultiplied version is the preferred format.</p>
<p>When a composition mode is set it applies to all painting operator, pens, brushes, gradients and pixmap/image drawing.</p>
<p><table border=&quote;1&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; width=&quote;100%&quote;>
<tr><th width=&quote;25%&quote;>Constant</th><th width=&quote;15%&quote;>Value</th><th width=&quote;60%&quote;>Description</th></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>This is the default mode. The alpha of the source is used to blend the pixel on top of the destination.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The alpha of the destination is used to blend it on top of the source pixels. This mode is the inverse of CompositionMode_SourceOver.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The pixels in the destination are cleared (set to fully transparent) independent of the source.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The output is the source pixel. (This means a basic copy operation and is identical to SourceOver when the source pixel is opaque).</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The output is the destination pixel. This means that the blending has no effect. This mode is the inverse of CompositionMode_Source.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The output is the source, where the alpha is reduced by that of the destination.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The output is the destination, where the alpha is reduced by that of the source. This mode is the inverse of CompositionMode_SourceIn.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The output is the source, where the alpha is reduced by the inverse of destination.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The output is the destination, where the alpha is reduced by the inverse of the source. This mode is the inverse of CompositionMode_SourceOut.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The source pixel is blended on top of the destination, with the alpha of the source pixel reduced by the alpha of the destination pixel.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The destination pixel is blended on top of the source, with the alpha of the destination pixel is reduced by the alpha of the destination pixel. This mode is the inverse of CompositionMode_SourceAtop.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The source, which alpha is reduced with the inverse of the destination alpha, is merged with the destination, which alpha is reduced by the inverse of the source alpha. CompositionMode_Xor is not the same as the bitwise Xor.</td></tr>
</table></p>

*/"/>
    <enum name="RenderHint" doc="/**
<p>Renderhints are used to specify flags to QPainter that may or may not be respected by any given engine.</p>
<p><table border=&quote;1&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; width=&quote;100%&quote;>
<tr><th width=&quote;25%&quote;>Constant</th><th width=&quote;15%&quote;>Value</th><th width=&quote;60%&quote;>Description</th></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>Indicates that the engine should antialias edges of primitives if possible.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>Indicates that the engine should antialias text if possible.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>Indicates that the engine should use a smooth pixmap transformation algorithm (such as bilinear) rather than nearest neighbor.</td></tr>
</table></p>

*/"/>
</class>
