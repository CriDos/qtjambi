<class name="QTimeLine" doc="/**
<p>The QTimeLine class provides a timeline for controlling animations.</p>
<p>It's most commonly used to animate a GUI control by calling a slot periodically. You can construct a timeline by passing its duration in milliseconds to QTimeLine's constructor. The timeline's duration describes for how long the animation will run. Then you set a suitable frame range by calling setFrameRange(). Finally connect the frameChanged() signal to a suitable slot in the widget you wish to animate (e.g., setValue() in QProgressBar). When you proceed to calling start(), QTimeLine will enter Running state, and start emitting frameChanged() at regular intervals, causing your widget's connected property's value to grow from the lower end to the upper and of your frame range, at a steady rate. You can specify the update interval by calling setUpdateInterval(). When done, QTimeLine enters NotRunning state, and emits finished().</p>
<p>Example:</p>
<pre>    ...
    progressBar = new QProgressBar(this);
    progressBar-&gt;setRange(0, 100);

<span class=&quote;comment&quote;>    // Construct a 1-second timeline with a frame range of 0 - 100</span>
    QTimeLine *timeLine = new QTimeLine(1000, this);
    timeLine-&gt;setFrameRange(0, 100);
    connect(timeLine, SIGNAL(frameChanged(int)), progressBar, SLOT(setValue(int)));

<span class=&quote;comment&quote;>    // Clicking the pushbutton will start the progress bar animation</span>
    pushButton = new QPushButton(tr(&quot;Start animation&quot;), this);
    connect(pushButton, SIGNAL(clicked()), timeLine, SLOT(start()));
    ...</pre>
<p>By default the timeline runs once, from the beginning and towards the end, upon which you must call start() again to restart from the beginning. To make the timeline loop, you can call setLoopCount(), passing the number of times the timeline should run before finishing. The direction can also be changed, causing the timeline to run backward, by calling setDirection(). You can also pause and unpause the timeline while it's running by calling setPaused(). For interactive control, the setCurrentTime() function is provided, which sets the time position of the time line directly. Although most useful in NotRunning state, (e.g., connected to a valueChanged() signal in a QSlider,) this function can be called at any time.</p>
<p>The frame interface is useful for standard widgets, but QTimeLine can be used to control any type of animation. The heart of QTimeLine lies in the valueForTime() function, which generates a <i>value</i> between 0 and 1 for a given time. This value is typically used to describe the steps of an animation, where 0 is the first step of an animation, and 1 is the last step. When running, QTimeLine generates values between 0 and 1 by calling valueForTime() and emitting valueChanged(). By default, valueForTime() applies an interpolation algorithm to generate these value. You can choose from a set of predefined timeline algorithms by calling setCurveShape(). By default, QTimeLine uses the EaseInOut curve shape, which provides a value that grows slowly, then grows steadily, and finally grows slowly. For a custom timeline, you can reimplement valueForTime(), in which case QTimeLine's curveShape property is ignored.</p>

*/">
    <method name="public QTimeLine(int duration__0, com.trolltech.qt.core.QObject parent__1)" doc="/**
<p>Constructs a timeline with a duration of <i>duration</i> milliseconds. <i>parent</i> is passed to QObject's constructor. The default duration is 1000 milliseconds.</p>

*/"/>
    <method name="public final int currentFrame()" doc="/**
<p>Returns the frame corresponding to the current time.</p>

*/"/>
    <method name="public final int currentTime()"/>
    <method name="public final double currentValue()" doc="/**
<p>Returns the value corresponding to the current time.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QTimeLine.CurveShape curveShape()"/>
    <method name="public final com.trolltech.qt.core.QTimeLine.Direction direction()"/>
    <method name="public final int duration()"/>
    <method name="public final int endFrame()" doc="/**
<p>Returns the end frame, which is the frame corresponding to the end of the timeline (i.e., the frame for which the current value is 1).</p>

*/"/>
    <method name="public final int frameForTime(int msec__0)" doc="/**
<p>Returns the frame corresponding to the time <i>msec</i>. This value is calculated using a linear interpolation of the start and end frame, based on the value returned by valueForTime().</p>

*/"/>
    <method name="public final int loopCount()"/>
    <method name="public final void setCurrentTime(int msec__0)"/>
    <method name="public final void setCurveShape(com.trolltech.qt.core.QTimeLine.CurveShape shape__0)"/>
    <method name="public final void setDirection(com.trolltech.qt.core.QTimeLine.Direction direction__0)"/>
    <method name="public final void setDuration(int duration__0)"/>
    <method name="public final void setEndFrame(int frame__0)" doc="/**
<p>Sets the end frame, which is the frame corresponding to the end of the timeline (i.e., the frame for which the current value is 1), to <i>frame</i>.</p>

*/"/>
    <method name="public final void setFrameRange(int startFrame__0, int endFrame__1)" doc="/**
<p>Sets the timeline's frame counter to start at <i>startFrame</i>, and end and <i>endFrame</i>. For each time value, QTimeLine will find the corresponding frame when you call currentFrame() or frameForTime() by interpolating, using the return value of valueForTime().</p>
<p>When in Running state, QTimeLine also emits the frameChanged() signal when the frame changes.</p>

*/"/>
    <method name="public final void setLoopCount(int count__0)"/>
    <method name="public final void setPaused(boolean paused__0)" doc="/**
<p>If <i>paused</i> is true, the timeline is paused, causing QTimeLine to enter Paused state. No updates will be signaled until either start() or setPaused(false) is called. If <i>paused</i> is false, the timeline is resumed and continues where it left.</p>

*/"/>
    <method name="public final void setStartFrame(int frame__0)" doc="/**
<p>Sets the start frame, which is the frame corresponding to the start of the timeline (i.e., the frame for which the current value is 0), to <i>frame</i>.</p>

*/"/>
    <method name="public final void setUpdateInterval(int interval__0)"/>
    <method name="public final void start()" doc="/**
<p>Starts the timeline. QTimeLine will enter Running state, and once it enters the event loop, it will update its current time, frame and value at regular intervals. The default interval is 40 ms (i.e., 25 times per second). You can change the update interval by calling setUpdateInterval().</p>

*/"/>
    <method name="public final int startFrame()" doc="/**
<p>Returns the start frame, which is the frame corresponding to the start of the timeline (i.e., the frame for which the current value is 0).</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QTimeLine.State state()" doc="/**
<p>Returns the state of the timeline.</p>

*/"/>
    <method name="public final void stop()" doc="/**
<p>Stops the timeline, causing QTimeLine to enter NotRunning state.</p>

*/"/>
    <method name="public final void toggleDirection()" doc="/**
<p>Toggles the direction of the timeline. If the direction was Forward, it becomes Backward, and vice verca.</p>

*/"/>
    <method name="public final int updateInterval()"/>
    <method name="protected void timerEvent(com.trolltech.qt.core.QTimerEvent event__0)"/>
    <method name="public double valueForTime(int msec__0)" doc="/**
<p>Returns the timeline value for the time <i>msec</i>. The returned value, which varies depending on the curve shape, is always between 0 and 1. If <i>msec</i> is 0, the default implementation always returns 0.</p>
<p>Reimplement this function to provide a custom curve shape for your timeline.</p>

*/"/>
    <enum name="Direction" doc="/**
<p>This enum describes the direction of the timeline when in Running state.</p>
<p><table border=&quote;1&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; width=&quote;100%&quote;>
<tr><th width=&quote;25%&quote;>Constant</th><th width=&quote;15%&quote;>Value</th><th width=&quote;60%&quote;>Description</th></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The current time of the timeline increases with time (i.e., moves from 0 and towards the end / duration).</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The current time of the timeline decreases with time (i.e., moves from the end / duration and towards 0).</td></tr>
</table></p>

*/"/>
    <enum name="CurveShape" doc="/**
<p>This enum describes the default shape of QTimeLine's value curve. The default, shape is EaseInOutCurve. The curve defines the relation between the value and the timeline.</p>
<p><table border=&quote;1&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; width=&quote;100%&quote;>
<tr><th width=&quote;25%&quote;>Constant</th><th width=&quote;15%&quote;>Value</th><th width=&quote;60%&quote;>Description</th></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The value starts growing slowly, then increases in speed.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The value starts growing steadily, then ends slowly.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The value starts growing slowly, the runs steadily, then grows slowly again.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The value grows linearly (e.g., if the duration is 1000 ms, the value at time 500 ms is 0.5).</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The value grows sinusoidally.</td></tr>
</table></p>

*/"/>
    <enum name="State" doc="/**
<p>This enum describes the state of the timeline.</p>
<p><table border=&quote;1&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; width=&quote;100%&quote;>
<tr><th width=&quote;25%&quote;>Constant</th><th width=&quote;15%&quote;>Value</th><th width=&quote;60%&quote;>Description</th></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The timeline is not running. This is the initial state of QTimeLine, and the state QTimeLine reenters when finished. The current time, frame and value remain unchanged until either setCurrentTime() is called, or the timeline is started by calling start().</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The timeline is paused (i.e., temporarily suspended). Calling setPaused(false) will resume timeline activity.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The timeline is running. While control is in the event loop, QTimeLine will update its current time at regular intervals, emitting valueChanged() and frameChanged() when appropriate.</td></tr>
</table></p>

*/"/>
</class>
