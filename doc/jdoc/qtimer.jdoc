<class name="QTimer" doc="/**
<p>The QTimer class provides repetitive and single-shot timers.</p>
<p>The QTimer class provides a high-level programming interface for timers. To use it, create a QTimer, connect its timeout() signal to the appropriate slots, and call start(). From then on it will emit the timeout() signal at constant intervals.</p>
<p>Example for a one second (1000 millisecond) timer (from the Analog Clock example):</p>
<pre>        QTimer *timer = new QTimer(this);
        connect(timer, SIGNAL(timeout()), this, SLOT(update()));
        timer-&gt;start(1000);</pre>
<p>From then on, the <tt>update()</tt> slot is called every second.</p>
<p>You can set a timer to time out only once by calling setSingleShot(true). You can also use the static QTimer::singleShot() function to call a slot after a specified interval:</p>
<pre>        QTimer::singleShot(200, this, SLOT(updateCaption()));</pre>
<p>In multithreaded applications, you can use QTimer in any thread that has an event loop. To start an event loop from a non-GUI thread, use QThread::exec(). Qt uses the the timer's thread affinity to determine which thread will emit the timeout() signal. Because of this, you must start and stop the timer in its thread; it is not possible to start a timer from another thread.</p>
<p>As a special case, a QTimer with a timeout of 0 will time out as soon as all the events in the window system's event queue have been processed. This can be used to do heavy work while providing a snappy user interface:</p>
<pre>        QTimer *timer = new QTimer(this);
        connect(timer, SIGNAL(timeout()), this, SLOT(processOneThing()));
        timer-&gt;start();</pre>
<p><tt>processOneThing()</tt> will from then on be called repeatedly. It should be written in such a way that it always returns quickly (typically after processing one data item) so that Qt can deliver events to widgets and stop the timer as soon as it has done all its work. This is the traditional way of implementing heavy work in GUI applications; multithreading is now becoming available on more and more platforms, and we expect that zero-millisecond QTimers will gradually be replaced by QThreads.</p>
<p>Note that QTimer's accuracy depends on the underlying operating system and hardware. Most platforms support an accuracy of 1 millisecond, but Windows 98 supports only 55. If Qt is unable to deliver the requested number of timer clicks, it will silently discard some.</p>
<p>An alternative to using QTimer is to call QObject::startTimer() for your object and reimplement the QObject::timerEvent() event handler in your class (which must inherit QObject). The disadvantage is that timerEvent() does not support such high-level features as single-shot timers or signals.</p>
<p>Another alternative to using QTimer is to use QBasicTimer. It is typically less cumbersome than using QObject::startTimer() directly. See Timers for an overview of all three approaches.</p>
<p>Some operating systems limit the number of timers that may be used; Qt tries to work around these limitations.</p>

*/">
    <method name="public QTimer(com.trolltech.qt.core.QObject parent__0)" doc="/**
<p>Constructs a timer with the given <i>parent</i>.</p>

*/"/>
    <method name="public final int interval()"/>
    <method name="public final boolean isActive()" doc="/**
<p>Returns true if the timer is running (pending); otherwise returns false.</p>

*/"/>
    <method name="public final boolean isSingleShot()"/>
    <method name="public final void setInterval(int msec__0)"/>
    <method name="public final void setSingleShot(boolean singleShot__0)"/>
    <method name="public final void start(int msec__0)" doc="/**
<p>Starts or restarts the timer with a timeout interval of <i>msec</i> milliseconds.</p>

*/"/>
    <method name="public final void start()" doc="/**
<p>Starts or restarts the timer with the timeout specified in interval.</p>
<p>If singleShot is true, the timer will be activated only once.</p>

*/"/>
    <method name="public final void stop()" doc="/**
<p>Stops the timer.</p>

*/"/>
    <method name="public final int timerId()" doc="/**
<p>Returns the ID of the timer if the timer is running; otherwise returns -1.</p>

*/"/>
    <method name="protected void timerEvent(com.trolltech.qt.core.QTimerEvent arg__0)"/>
</class>
