<class name="QGraphicsView" doc="/**
<p>The QGraphicsView class provides a widget for displaying the contents of a QGraphicsScene.</p>
<p>QGraphicsView visualizes the contents of a QGraphicsScene in a scrollable viewport. To create a scene with geometrical items, see QGraphicsScene's documentation. QGraphicsView is part of The Graphics View Framework.</p>
<p>To visualize a scene, you start by constructing a QGraphicsView object, passing the address of the scene you want to visualize to QGraphicsView's constructor. Alternatively, you can call setScene() to set the scene at a later point. After you call show(), the view will by default scroll to the center of the scene and display any items that are visible at this point. For example:</p>
<pre>    QGraphicsScene scene;
    scene.addText(&quot;Hello, world!&quot;);

    QGraphicsView view(&amp;scene);
    view.show();</pre>
<p>You can explicitly scroll to any position on the scene by using the scrollbars, or by calling centerOn(). By passing a point to centerOn(), QGraphicsView will scroll its viewport to ensure that the point is centered in the view. An overload is provided for scrolling to a QGraphicsItem, in which case QGraphicsView will see to that the center of the item is centered in the view. If all you want is to ensure that a certain area is visible, (but not necessarily centered,) you can call ensureVisible() instead.</p>
<p>QGraphicsView can be used to visualize a whole scene, or only parts of it. The visualized area is by default detected automatically when the view is displayed for the first time (by calling QGraphicsScene::itemsBoundingRect()). To set the visualized area rectangle yourself, you can call setSceneRect(). This will adjust the scrollbars' ranges appropriately.</p>
<p>QGraphicsView visualizes the scene by calling render(). By default, the items are drawn onto the viewport by using a regular QPainter, and using default render hints. To change the default render hints that QGraphicsView passes to QPainter when painting items, you can call setRenderHints().</p>
<p>By default, QGraphicsView provides a regular QWidget for the viewport widget. You can access this widget by calling viewport(), or you can replace it by calling setViewport(). To render using OpenGL, simply call setViewport(new QGLWidget). QGraphicsView takes ownership of the viewport widget.</p>
<p>QGraphicsView supports affine transformations, using QMatrix. You can either pass a matrix to setMatrix(), or you can call one of the convenience functions rotate(), scale(), translate() or shear(). The most two common transformations are scaling, which is used to implement zooming, and rotation. QGraphicsView keeps the center of the view fixed during a transformation.</p>
<p>You can interact with the items on the scene by using the mouse and keyboard. QGraphicsView translates the mouse and key events into <i>scene</i> events, (events that inherit QGraphicsSceneEvent,), and forward them to the visualized scene. In the end, it's the individual item that handles the events and reacts to them. For example, if you click on a selectable item, the item will typically let the scene know that it has been selected, and it will also redraw itself to display a selection rectangle. Similiary, if you click and drag the mouse to move a movable item, it's the item that handles the mouse moves and moves itself. Item interaction is enabled by default, and you can toggle it by calling setInteractive().</p>
<p>You can also provide your own custom scene interaction, by creating a subclass of QGraphicsView, and reimplementing the mouse and key event handlers. To simplify how you programmatically interact with items in the view, QGraphicsView provides the mapping functions mapToScene() and mapFromScene(), and the item accessors items() and itemAt(). These functions allow you to map points, rectangles, polygons and paths between view coordinates and scene coordinates, and to find items on the scene using view coordinates.</p>
<p align=&quote;center&quote;><font color=&quote;red&quote;>[Missing image graphicsview-view.png]</font></p>
*/">
    <method name="public QGraphicsView(com.trolltech.qt.gui.QWidget parent__0)" doc="/**
<p>Constructs a QGraphicsView. <i>parent</i> is passed to QWidget's constructor.</p>

*/"/>
    <method name="public QGraphicsView(com.trolltech.qt.gui.QGraphicsScene scene__0, com.trolltech.qt.gui.QWidget parent__1)" doc="/**
<p>Constructs a QGraphicsView and sets the visualized scene to <i>scene</i>. <i>parent</i> is passed to QWidget's constructor.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.Qt.Alignment alignment()"/>
    <method name="public final com.trolltech.qt.gui.QBrush backgroundBrush()"/>
    <method name="public final com.trolltech.qt.gui.QGraphicsView.CacheMode cacheMode()"/>
    <method name="public final void centerOn(double x__0, double y__1)" doc="/**
<p>This function is provided for convenience. It's equivalent to calling centerOn(QPointF(<i>x</i>, <i>y</i>)).</p>

*/"/>
    <method name="public final void centerOn(com.trolltech.qt.gui.QGraphicsItemInterface item__0)" doc="/**
<p>Scrolls the contents of the viewport to ensure that <i>item</i> is centered in the view.</p>

*/"/>
    <method name="public final void centerOn(com.trolltech.qt.core.QPointF pos__0)" doc="/**
<p>Scrolls the contents of the viewport to ensure that the scene coordinate <i>pos</i>, is centered in the view.</p>
<p>Because <i>pos</i> is a floating point coordinate, and the scroll bars operate on integer coordinates, the centering is only an approximation.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QGraphicsView.DragMode dragMode()"/>
    <method name="public final void ensureVisible(com.trolltech.qt.gui.QGraphicsItemInterface item__0, int xmargin__1, int ymargin__2)" doc="/**
<p>Scrolls the contents of the viewport so that the center of item <i>item</i> is visible, with margins specified in pixels by <i>xmargin</i> and <i>ymargin</i>. If the specified point cannot be reached, the contents are scrolled to the nearest valid position. The default value for both margins is 50 pixels.</p>

*/"/>
    <method name="public final void ensureVisible(double x__0, double y__1, double w__2, double h__3, int xmargin__4, int ymargin__5)" doc="/**
<p>This function is provided for convenience. It's equivalent to calling ensureVisible(QRectF(<i>x</i>, <i>y</i>, <i>w</i>, <i>h</i>), <i>xmargin</i>, <i>ymargin</i>).</p>

*/"/>
    <method name="public final void ensureVisible(com.trolltech.qt.core.QRectF rect__0, int xmargin__1, int ymargin__2)" doc="/**
<p>Scrolls the contents of the viewport so that the scene rectangle <i>rect</i> is visible, with margins specified in pixels by <i>xmargin</i> and <i>ymargin</i>. If the specified rect cannot be reached, the contents are scrolled to the nearest valid position. The default value for both margins is 50 pixels.</p>

*/"/>
    <method name="public final void fitInView(com.trolltech.qt.core.QRectF rect__0, com.trolltech.qt.core.Qt.AspectRatioMode aspectRadioMode__1)" doc="/**
<p>Scales the view matrix and scrolls the scroll bars to ensures that the scene rectangle <i>rect</i> fits inside the view.</p>
<p>This function keeps the view's rotation, translation, or shear. The view is scaled according to <i>aspectRatioMode</i>. <i>rect</i> will be centered in the view if it does not fit tightly.</p>

*/"/>
    <method name="public final void fitInView(com.trolltech.qt.gui.QGraphicsItemInterface item__0, com.trolltech.qt.core.Qt.AspectRatioMode aspectRadioMode__1)" doc="/**
<p>Ensures that <i>item</i> fits tightly inside the view, scaling the view according to <i>aspectRatioMode</i>.</p>

*/"/>
    <method name="public final void fitInView(double x__0, double y__1, double w__2, double h__3, com.trolltech.qt.core.Qt.AspectRatioMode aspectRadioMode__4)" doc="/**
<p>This convenience function is equivalent to calling fitInView(QRectF(<i>x</i>, <i>y</i>, <i>w</i>, <i>h</i>), <i>aspectRatioMode</i>).</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QBrush foregroundBrush()"/>
    <method name="public final boolean isInteractive()"/>
    <method name="public final com.trolltech.qt.gui.QGraphicsItemInterface itemAt(com.trolltech.qt.core.QPoint pos__0)" doc="/**
<p>Returns the item at position <i>pos</i>, which is in viewport coordinates. If there are several items at this position, this function returns the topmost item.</p>
<p>Example:</p>
<pre>    void CustomView::mousePressEvent(QMouseEvent *event)
    {
        if (QGraphicsItem *item = itemAt(event-&gt;pos())) {
            qDebug() &lt;&lt; &quot;You clicked on item&quot; &lt;&lt; item;
        } else {
            qDebug() &lt;&lt; &quot;You didn't click on an item.&quot;;
        }
    }</pre>

*/"/>
    <method name="public final com.trolltech.qt.gui.QGraphicsItemInterface itemAt(int x__0, int y__1)" doc="/**
<p>This function is provided for convenience. It's equivalent to calling itemAt(QPoint(<i>x</i>, <i>y</i>)).</p>

*/"/>
    <method name="public final java.util.List&lt;com.trolltech.qt.gui.QGraphicsItemInterface&gt; items(com.trolltech.qt.core.QPoint pos__0)" doc="/**
<p>Returns a list of all the items at the position <i>pos</i> in the view. The items are listed in descending Z order (i.e., the first item in the list is the top-most item, and the last item is the bottom-most item). <i>pos</i> is in viewport coordinates.</p>
<p>This function is most commonly called from within mouse event handlers in a subclass in QGraphicsView. <i>pos</i> is in untransformed viewport coordinates, just like QMouseEvent::pos().</p>
<pre>    void CustomView::mousePressEvent(QMouseEvent *event)
    {
        qDebug() &lt;&lt; &quot;There are&quot; &lt;&lt; items(event-&gt;pos()).size()
                 &lt;&lt; &quot;items at position&quot; &lt;&lt; mapToScene(event-&gt;pos());
    }</pre>

*/"/>
    <method name="public final java.util.List&lt;com.trolltech.qt.gui.QGraphicsItemInterface&gt; items(com.trolltech.qt.core.QRect rect__0, com.trolltech.qt.core.Qt.ItemSelectionMode mode__1)" doc="/**
<p>Returns a list of all the items that, depending on <i>mode</i>, are either contained by or intersect with <i>rect</i>. <i>rect</i> is in viewport coordinates.</p>
<p>The default value for <i>mode</i> is Qt::IntersectsItemShape; all items whose exact shape intersects with or is contained by <i>rect</i> are returned.</p>

*/"/>
    <method name="public final java.util.List&lt;com.trolltech.qt.gui.QGraphicsItemInterface&gt; items(int x__0, int y__1)" doc="/**
<p>This function is provided for convenience. It's equivalent to calling items(QPoint(<i>x</i>, <i>y</i>)).</p>

*/"/>
    <method name="public final java.util.List&lt;com.trolltech.qt.gui.QGraphicsItemInterface&gt; items(com.trolltech.qt.gui.QPainterPath path__0, com.trolltech.qt.core.Qt.ItemSelectionMode mode__1)" doc="/**
<p>Returns a list of all the items that, depending on <i>mode</i>, are either contained by or intersect with <i>path</i>. <i>path</i> is in viewport coordinates.</p>
<p>The default value for <i>mode</i> is Qt::IntersectsItemShape; all items whose exact shape intersects with or is contained by <i>path</i> are returned.</p>

*/"/>
    <method name="public final java.util.List&lt;com.trolltech.qt.gui.QGraphicsItemInterface&gt; items()" doc="/**
<p>Returns a list of all the items in the associated scene.</p>

*/"/>
    <method name="public final java.util.List&lt;com.trolltech.qt.gui.QGraphicsItemInterface&gt; items(com.trolltech.qt.gui.QPolygon polygon__0, com.trolltech.qt.core.Qt.ItemSelectionMode mode__1)" doc="/**
<p>Returns a list of all the items that, depending on <i>mode</i>, are either contained by or intersect with <i>polygon</i>. <i>polygon</i> is in viewport coordinates.</p>
<p>The default value for <i>mode</i> is Qt::IntersectsItemShape; all items whose exact shape intersects with or is contained by <i>polygon</i> are returned.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QPainterPath mapFromScene(com.trolltech.qt.gui.QPainterPath path__0)" doc="/**
<p>Returns the scene coordinate painter path <i>path</i> to a viewport coordinate painter path.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QPolygon mapFromScene(double x__0, double y__1, double w__2, double h__3)" doc="/**
<p>This function is provided for convenience. It's equivalent to calling mapFromScene(QRectF(<i>x</i>, <i>y</i>, <i>w</i>, <i>h</i>)).</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QPoint mapFromScene(double x__0, double y__1)" doc="/**
<p>This function is provided for convenience. It's equivalent to calling mapFromScene(QPointF(<i>x</i>, <i>y</i>)).</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QPolygon mapFromScene(com.trolltech.qt.core.QRectF rect__0)" doc="/**
<p>Returns the scene rectangle <i>rect</i> to a viewport coordinate polygon.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QPoint mapFromScene(com.trolltech.qt.core.QPointF point__0)" doc="/**
<p>Returns the scene coordinate <i>point</i> to viewport coordinates.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QPolygon mapFromScene(com.trolltech.qt.gui.QPolygonF polygon__0)" doc="/**
<p>Returns the scene coordinate polygon <i>polygon</i> to a viewport coordinate polygon.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QPolygonF mapToScene(com.trolltech.qt.gui.QPolygon polygon__0)" doc="/**
<p>Returns the viewport polygon <i>polygon</i> mapped to a scene coordinate polygon.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QPainterPath mapToScene(com.trolltech.qt.gui.QPainterPath path__0)" doc="/**
<p>Returns the viewport painter path <i>path</i> mapped to a scene coordinate painter path.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QPolygonF mapToScene(com.trolltech.qt.core.QRect rect__0)" doc="/**
<p>Returns the viewport rectangle <i>rect</i> mapped to a scene coordinate polygon.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QPointF mapToScene(int x__0, int y__1)" doc="/**
<p>This function is provided for convenience. It's equivalent to calling mapToScene(QPoint(<i>x</i>, <i>y</i>)).</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QPolygonF mapToScene(int x__0, int y__1, int w__2, int h__3)" doc="/**
<p>This function is provided for convenience. It's equivalent to calling mapToScene(QRect(<i>x</i>, <i>y</i>, <i>w</i>, <i>h</i>)).</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QPointF mapToScene(com.trolltech.qt.core.QPoint point__0)" doc="/**
<p>Returns the viewport coordinate <i>point</i> mapped to scene coordinates.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QMatrix matrix()" doc="/**
<p>Returns the current transformation matrix for the view. If no current transformation is set, the identity matrix is returned.</p>

*/"/>
    <method name="public final void render(com.trolltech.qt.gui.QPainter painter__0, com.trolltech.qt.core.QRectF target__1, com.trolltech.qt.core.QRect source__2, com.trolltech.qt.core.Qt.AspectRatioMode aspectRatioMode__3)" doc="/**
<p>Renders the <i>source</i> rect, which is in view coordinates, from the scene into <i>target</i>, which is in paint device coordinates, using <i>painter</i>. This function is useful for capturing the contents of the view onto a paint device, such as a QImage (e.g., to take a screenshot), or for printing to QPrinter. For example:</p>
<pre>    QGraphicsScene scene;
    scene.addItem(...
    ...

    QGraphicsView view(&amp;scene);
    view.show();
    ...

    QPrinter printer(QPrinter::HighResolution);
    printer.setPageSize(QPrinter::A4);
    QPainter painter(&amp;printer);

<span class=&quote;comment&quote;>    // print, fitting the viewport contents into a full page</span>
    view.render(&amp;painter);

<span class=&quote;comment&quote;>    // print the upper half of the viewport into the lower.</span>
<span class=&quote;comment&quote;>    // half of the page.</span>
    QRect viewport = view.viewport()-&gt;rect();
    view.render(&amp;painter,
                QRectF(0, printer.height() / 2,
                       printer.width(), printer.height() / 2),
                viewport.adjusted(0, 0, 0, -viewport.height() / 2));</pre>
<p>If <i>source</i> is a null rect, this function will use viewport()-&gt;rect() to determine what to draw. If <i>target</i> is a null rect, the full dimensions of <i>painter</i>'s paint device (e.g., for a QPrinter, the page size) will be used.</p>
<p>The source rect contents will be transformed according to <i>aspectRatioMode</i> to fit into the target rect. By default, the aspect ratio is kept, and <i>source</i> is scaled to fit in <i>target</i>.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QPainter.RenderHints renderHints()"/>
    <method name="public final void resetCachedContent()" doc="/**
<p>Resets any cached content. Calling this function will clear QGraphicsView's cache. If the current cache mode is CacheNone, this function does nothing.</p>
<p>This function is called automatically for you when the backgroundBrush or QGraphicsScene::backgroundBrush properties change; you only need to call this function if you have reimplemented QGraphicsScene::drawBackground() or QGraphicsView::drawBackground() to draw a custom background, and need to trigger a full redraw.</p>

*/"/>
    <method name="public final void resetMatrix()" doc="/**
<p>Resets the view transformation matrix to the identity matrix.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QGraphicsView.ViewportAnchor resizeAnchor()"/>
    <method name="public final void rotate(double angle__0)" doc="/**
<p>Rotates the current view transformation <i>angle</i> degrees clockwise.</p>

*/"/>
    <method name="public final void scale(double sx__0, double sy__1)" doc="/**
<p>Scales the current view transformation by (<i>sx</i>, <i>sy</i>).</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QGraphicsScene scene()" doc="/**
<p>Returns a pointer to the scene that is currently visualized in the view. If no scene is currently visualized, 0 is returned.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QRectF sceneRect()"/>
    <method name="public final void setAlignment(com.trolltech.qt.core.Qt.Alignment alignment__0)"/>
    <method name="public final void setBackgroundBrush(com.trolltech.qt.gui.QBrush brush__0)"/>
    <method name="public final void setCacheMode(com.trolltech.qt.gui.QGraphicsView.CacheMode mode__0)"/>
    <method name="public final void setDragMode(com.trolltech.qt.gui.QGraphicsView.DragMode mode__0)"/>
    <method name="public final void setForegroundBrush(com.trolltech.qt.gui.QBrush brush__0)"/>
    <method name="public final void setInteractive(boolean allowed__0)"/>
    <method name="public final void setMatrix(com.trolltech.qt.gui.QMatrix matrix__0, boolean combine__1)" doc="/**
<p>Sets the view's current transformation matrix to <i>matrix</i>.</p>
<p>If <i>combine</i> is true, then <i>matrix</i> is combined with the current matrix; otherwise, <i>matrix</i> <i>replaces</i> the current matrix. <i>combine</i> is false by default.</p>
<p>The transformation matrix tranforms the scene into view coordinates. Using the default transformation, provided by the identity matrix, one pixel in the view represents one unit in the scene (e.g., a 10x10 rectangular item is drawn using 10x10 pixels in the view). If a 2x2 scaling matrix is applied, the scene will be drawn in 1:2 (e.g., a 10x10 rectangular item is then drawn using 20x20 pixels in the view).</p>
<p>Example:</p>
<pre>    QGraphicsScene scene;
    scene.addText(&quot;GraphicsView rotated clockwise&quot;);

    QGraphicsView view(&amp;scene);
    view.rotate(90); <span class=&quote;comment&quote;>// the text is rendered with a 90 degree clockwise rotation</span>
    view.show();</pre>
<p>To simplify interation with items using a transformed view, QGraphicsView provides mapTo... and mapFrom... functions that can translate between scene and view coordinates. For example, you can call mapToScene() to map a view coordiate to a floating point scene coordinate, or mapFromScene() to map from floating point scene coordinates to view coordinates.</p>

*/"/>
    <method name="public final void setRenderHint(com.trolltech.qt.gui.QPainter.RenderHint hint__0, boolean enabled__1)" doc="/**
<p>If <i>enabled</i> is true, the render hint <i>hint</i> is enabled; otherwise it is disabled.</p>

*/"/>
    <method name="public final void setRenderHints(com.trolltech.qt.gui.QPainter.RenderHints hints__0)"/>
    <method name="public final void setResizeAnchor(com.trolltech.qt.gui.QGraphicsView.ViewportAnchor anchor__0)"/>
    <method name="public final void setScene(com.trolltech.qt.gui.QGraphicsScene scene__0)" doc="/**
<p>Sets the current scene to <i>scene</i>. If <i>scene</i> is already being viewed, this function does nothing.</p>
<p>When a scene is set on a view, the QGraphicsScene::changed() signal is automatically connected to this view's updateScene() slot, and the view's scrollbars are adjusted to fit the size of the scene.</p>

*/"/>
    <method name="public final void setSceneRect(com.trolltech.qt.core.QRectF rect__0)"/>
    <method name="public final void setSceneRect(double x__0, double y__1, double w__2, double h__3)"/>
    <method name="public final void setTransformationAnchor(com.trolltech.qt.gui.QGraphicsView.ViewportAnchor anchor__0)"/>
    <method name="protected final void setupViewport(com.trolltech.qt.gui.QWidget widget__0)" doc="/**
<p>This slot is called by QAbstractScrollArea after setViewport() has been called. Reimplement this function in a subclass of QGraphicsView to initialize the new viewport <i>widget</i> before it is used.</p>

*/"/>
    <method name="public final void shear(double sh__0, double sv__1)" doc="/**
<p>Shears the current view transformation by (<i>sh</i>, <i>sv</i>).</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QGraphicsView.ViewportAnchor transformationAnchor()"/>
    <method name="public final void translate(double dx__0, double dy__1)" doc="/**
<p>Translates the current view transformation by (<i>dx</i>, <i>dy</i>).</p>

*/"/>
    <method name="public final void updateScene(java.util.List&lt;com.trolltech.qt.core.QRectF&gt; rects__0)" doc="/**
<p>Schedules an update of the scene rectangles <i>rects</i>.</p>

*/"/>
    <method name="public final void updateSceneRect(com.trolltech.qt.core.QRectF rect__0)" doc="/**
<p>Notifies QGraphicsView that the scene's scene rect has changed. <i>rect</i> is the new scene rect. If the view already has an explicitly set scene rect, this function does nothing.</p>

*/"/>
    <method name="protected void contextMenuEvent(com.trolltech.qt.gui.QContextMenuEvent event__0)"/>
    <method name="protected void dragEnterEvent(com.trolltech.qt.gui.QDragEnterEvent event__0)"/>
    <method name="protected void dragLeaveEvent(com.trolltech.qt.gui.QDragLeaveEvent event__0)"/>
    <method name="protected void dragMoveEvent(com.trolltech.qt.gui.QDragMoveEvent event__0)"/>
    <method name="protected void drawBackground(com.trolltech.qt.gui.QPainter painter__0, com.trolltech.qt.core.QRectF rect__1)" doc="/**
<p>Draws the background of the scene using <i>painter</i>, before any items and the foreground are drawn. Reimplement this function to provide a custom background for this view.</p>
<p>If all you want is to define a color, texture or gradient for the background, you can call setBackgroundBrush() instead.</p>
<p>All painting is done in <i>scene</i> coordinates. <i>rect</i> is the exposed rectangle.</p>
<p>The default implementation fills <i>rect</i> using the view's backgroundBrush. If no such brush is defined (the default), the scene's drawBackground() function is called instead.</p>

*/"/>
    <method name="protected void drawForeground(com.trolltech.qt.gui.QPainter painter__0, com.trolltech.qt.core.QRectF rect__1)" doc="/**
<p>Draws the foreground of the scene using <i>painter</i>, after the background and all items are drawn. Reimplement this function to provide a custom foreground for this view.</p>
<p>If all you want is to define a color, texture or gradient for the foreground, you can call setForegroundBrush() instead.</p>
<p>All painting is done in <i>scene</i> coordinates. <i>rect</i> is the exposed rectangle.</p>
<p>The default implementation fills <i>rect</i> using the view's foregroundBrush. If no such brush is defined (the default), the scene's drawForeground() function is called instead.</p>

*/"/>
    <method name="protected void drawItems(com.trolltech.qt.gui.QPainter painter__0, int numItems__1, com.trolltech.qt.QNativePointer items__2, com.trolltech.qt.gui.QStyleOptionGraphicsItem options__3)" doc="/**
<p>Draws the items <i>items</i> in the scene using <i>painter</i>, after the background and before the foreground are drawn. <i>numItems</i> is the number of items in <i>items</i> and options in <i>options</i>. <i>options</i> is a list of styleoptions; one for each item. Reimplement this function to provide custom item drawing for this view.</p>
<p>The default implementation calls the scene's drawItems() function.</p>

*/"/>
    <method name="protected void dropEvent(com.trolltech.qt.gui.QDropEvent event__0)"/>
    <method name="public boolean event(com.trolltech.qt.core.QEvent event__0)"/>
    <method name="protected void focusInEvent(com.trolltech.qt.gui.QFocusEvent event__0)"/>
    <method name="protected void focusOutEvent(com.trolltech.qt.gui.QFocusEvent event__0)"/>
    <method name="protected void inputMethodEvent(com.trolltech.qt.gui.QInputMethodEvent event__0)"/>
    <method name="public java.lang.Object inputMethodQuery(com.trolltech.qt.core.Qt.InputMethodQuery query__0)"/>
    <method name="protected void keyPressEvent(com.trolltech.qt.gui.QKeyEvent event__0)"/>
    <method name="protected void keyReleaseEvent(com.trolltech.qt.gui.QKeyEvent event__0)"/>
    <method name="protected void mouseDoubleClickEvent(com.trolltech.qt.gui.QMouseEvent event__0)"/>
    <method name="protected void mouseMoveEvent(com.trolltech.qt.gui.QMouseEvent event__0)"/>
    <method name="protected void mousePressEvent(com.trolltech.qt.gui.QMouseEvent event__0)"/>
    <method name="protected void mouseReleaseEvent(com.trolltech.qt.gui.QMouseEvent event__0)"/>
    <method name="protected void paintEvent(com.trolltech.qt.gui.QPaintEvent event__0)"/>
    <method name="protected void resizeEvent(com.trolltech.qt.gui.QResizeEvent event__0)"/>
    <method name="protected void scrollContentsBy(int dx__0, int dy__1)"/>
    <method name="protected void showEvent(com.trolltech.qt.gui.QShowEvent event__0)"/>
    <method name="public com.trolltech.qt.core.QSize sizeHint()"/>
    <method name="protected boolean viewportEvent(com.trolltech.qt.core.QEvent event__0)"/>
    <method name="protected void wheelEvent(com.trolltech.qt.gui.QWheelEvent event__0)"/>
    <enum name="ViewportAnchor" doc="/**
<p>This enums describe the possible anchors that QGraphicsView can use when the user resizes the view or when the view is transformed.</p>
<p><table border=&quote;1&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; width=&quote;100%&quote;>
<tr><th width=&quote;25%&quote;>Constant</th><th width=&quote;15%&quote;>Value</th><th width=&quote;60%&quote;>Description</th></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>No anchor, i.e. the view leaves the scene's position unchanged.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The scene point at the center of the view is used as the anchor.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The point under the mouse is used as the anchor.</td></tr>
</table></p>

*/"/>
    <enum name="CacheModeFlag" doc="/**
<p>This enum describes the flags that you can set for a QGraphicsView's cache mode.</p>
<p><table border=&quote;1&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; width=&quote;100%&quote;>
<tr><th width=&quote;25%&quote;>Constant</th><th width=&quote;15%&quote;>Value</th><th width=&quote;60%&quote;>Description</th></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>All painting is done directly onto the viewport.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The background is cached. This affects both custom backgrounds, and backgrounds based on the backgroundBrush property. When this flag is enabled, QGraphicsView will allocate one pixmap with the full size of the viewport.</td></tr>
</table></p>

*/"/>
    <enum name="DragMode" doc="/**
<p>This enum describes the default action for the view when pressing and dragging the mouse over the viewport.</p>
<p><table border=&quote;1&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; width=&quote;100%&quote;>
<tr><th width=&quote;25%&quote;>Constant</th><th width=&quote;15%&quote;>Value</th><th width=&quote;60%&quote;>Description</th></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>Nothing happens; the mouse event is ignored.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The cursor changes into a pointing hand, and dragging the mouse around will scroll the scrolbars.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>A rubber band will appear. Dragging the mouse will set the rubber band geometry, and all items covered by the rubber band are selected.</td></tr>
</table></p>

*/"/>
</class>
