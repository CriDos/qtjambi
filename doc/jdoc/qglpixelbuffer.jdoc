<class name="QGLPixelBuffer" doc="/**
<p>The QGLPixelBuffer class encapsulates an OpenGL pbuffer.</p>
<p>Rendering into a pbuffer is normally done using full hardware acceleration. This can be significantly faster than rendering into a QPixmap.</p>
<p>There are three approaches to using this class:</p>
<ol type=&quote;1&quote;>
<li><b>We can draw into the pbuffer and convert it to a QImage using toImage().</b> This is normally much faster than calling QGLWidget::renderPixmap().</li>
<li><b>We can draw into the pbuffer and copy the contents into an OpenGL texture using updateDynamicTexture().</b> This allows us to create dynamic textures and works on all systems with pbuffer support.</li>
<li><b>On systems that support it, we can bind the pbuffer to an OpenGL texture.</b> The texture is then updated automatically when the pbuffer contents change, eliminating the need for additional copy operations. This is supported only on Windows and Mac OS X systems that provide the <tt>render_texture</tt> extension.</li>
</ol>
<p>Pbuffers are provided by the OpenGL <tt>pbuffer</tt> extension; call hasOpenGLPbuffer() to find out if the system provides pbuffers.</p>

*/">
    <method name="public QGLPixelBuffer(com.trolltech.qt.core.QSize size__0, com.trolltech.qt.opengl.QGLFormat format__1, com.trolltech.qt.opengl.QGLWidget shareWidget__2)" doc="/**
<p>Constructs an OpenGL pbuffer of the given <i>size</i>. If no <i>format</i> is specified, the default format is used. If the <i>shareWidget</i> parameter points to a valid QGLWidget, the pbuffer will share its context with <i>shareWidget</i>.</p>
<p>If you intend to bind this pbuffer as a dynamic texture, the width and height components of <tt>size</tt> must be powers of two (e.g., 512 x 128).</p>

*/"/>
    <method name="public QGLPixelBuffer(int width__0, int height__1, com.trolltech.qt.opengl.QGLFormat format__2, com.trolltech.qt.opengl.QGLWidget shareWidget__3)" doc="/**
<p>Constructs an OpenGL pbuffer with the <i>width</i> and <i>height</i>. If no <i>format</i> is specified, the default format is used. If the <i>shareWidget</i> parameter points to a valid QGLWidget, the pbuffer will share its context with <i>shareWidget</i>.</p>
<p>If you intend to bind this pbuffer as a dynamic texture, the width and height components of <tt>size</tt> must be powers of two (e.g., 512 x 128).</p>

*/"/>
    <method name="public final int bindTexture(java.lang.String fileName__0)" doc="/**
<p>Reads the DirectDrawSurface (DDS) compressed file <i>fileName</i> and generates a 2D GL texture from it.</p>
<p>Equivalent to calling QGLContext::bindTexture().</p>

*/"/>
    <method name="public final int bindTexture(com.trolltech.qt.gui.QImage image__0, int target__1)" doc="/**
<p>Generates and binds a 2D GL texture to the current context, based on <i>image</i>. The generated texture id is returned and can be used in later glBindTexture() calls.</p>
<p>The <i>target</i> parameter specifies the texture target.</p>
<p>Equivalent to calling QGLContext::bindTexture().</p>

*/"/>
    <method name="public final int bindTexture(com.trolltech.qt.gui.QPixmap pixmap__0, int target__1)" doc="/**
<p>Generates and binds a 2D GL texture based on <i>pixmap</i>.</p>
<p>Equivalent to calling QGLContext::bindTexture().</p>

*/"/>
    <method name="public final boolean bindToDynamicTexture(int texture__0)" doc="/**
<p>Binds the texture specified by <i>texture_id</i> to this pbuffer. Returns true on success; otherwise returns false.</p>
<p>The texture must be of the same size and format as the pbuffer.</p>
<p>To unbind the texture, call releaseFromDynamicTexture(). While the texture is bound, it is updated automatically when the pbuffer contents change, eliminating the need for additional copy operations.</p>
<p>Example:</p>
<pre>    QGLPixelBuffer pbuffer(...);
    ...
    pbuffer.makeCurrent();
    GLuint dynamicTexture = pbuffer.generateDynamicTexture();
    pbuffer.bindToDynamicTexture(dynamicTexture);
    ...
    pbuffer.releaseFromDynamicTexture();</pre>
<p><b>Warning:</b> This function uses the <tt>render_texture</tt> extension, which is currently not supported under X11. An alternative that works on all systems (including X11) is to manually copy the pbuffer contents to a texture using updateDynamicTexture().</p>
<p><b>Warning:</b> For the bindToDynamicTexture() call to succeed on the Mac OS X, the pbuffer needs a shared context, i.e. the QGLPixelBuffer must be created with a share widget.</p>

*/"/>
    <method name="public final void deleteTexture(int texture_id__0)" doc="/**
<p>Removes the texture identified by <i>texture_id</i> from the texture cache.</p>
<p>Equivalent to calling QGLContext::deleteTexture().</p>

*/"/>
    <method name="public final int depth()"/>
    <method name="public final boolean doneCurrent()" doc="/**
<p>Makes no context the current OpenGL context. Returns true on success; otherwise returns false.</p>

*/"/>
    <method name="public final com.trolltech.qt.opengl.QGLFormat format()" doc="/**
<p>Returns the format of the pbuffer. The format may be different from the one that was requested.</p>

*/"/>
    <method name="public final int generateDynamicTexture()" doc="/**
<p>Generates and binds a 2D GL texture that is the same size as the pbuffer, and returns the texture's ID. This can be used in conjunction with bindToDynamicTexture() and updateDynamicTexture().</p>

*/"/>
    <method name="public final long handle()" doc="/**
<p>Returns the native pbuffer handle.</p>

*/"/>
    <method name="public final boolean isValid()" doc="/**
<p>Returns true if this pbuffer is valid; otherwise returns false.</p>

*/"/>
    <method name="public final boolean makeCurrent()" doc="/**
<p>Makes this pbuffer the current OpenGL rendering context. Returns true on success; otherwise returns false.</p>

*/"/>
    <method name="public final boolean paintingActive()"/>
    <method name="public final void releaseFromDynamicTexture()" doc="/**
<p>Releases the pbuffer from any previously bound texture. Returns true on success; otherwise returns false.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QSize size()" doc="/**
<p>Returns the size of the pbuffer.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QImage toImage()" doc="/**
<p>Returns the contents of the pbuffer as a QImage.</p>

*/"/>
    <method name="public final void updateDynamicTexture(int texture_id__0)" doc="/**
<p>Copies the pbuffer contents into the texture specified with <i>texture_id</i>.</p>
<p>The texture must be of the same size and format as the pbuffer.</p>
<p>Example:</p>
<pre>    QGLPixelBuffer pbuffer(...);
    ...
    pbuffer.makeCurrent();
    GLuint dynamicTexture = pbuffer.generateDynamicTexture();
    ...
    pbuffer.updateDynamicTexture(dynamicTexture);</pre>
<p>An alternative on Windows and Mac OS X systems that support the <tt>render_texture</tt> extension is to use bindToDynamicTexture() to get dynamic updates of the texture.</p>

*/"/>
    <method name="public int devType()"/>
    <method name="public int metric(com.trolltech.qt.gui.QPaintDevice.PaintDeviceMetric metric__0)" doc="/**
<p>Returns the metric information for the given paint device <i>metric</i>.</p>

*/"/>
    <method name="public com.trolltech.qt.gui.QPaintEngine paintEngine()"/>
    <method name="public native static boolean hasOpenGLPbuffers()" doc="/**
<p>Returns true if the OpenGL <tt>pbuffer</tt> extension is present on this system; otherwise returns false.</p>

*/"/>
</class>
