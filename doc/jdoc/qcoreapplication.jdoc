<class name="QCoreApplication" doc="/**
<p>The QCoreApplication class provides an event loop for console Qt applications.</p>
<p>This class is used by non-GUI applications to provide their event loop. For non-GUI application that uses Qt, there should be exactly one QCoreApplication object. For GUI applications, see QApplication.</p>
<p>QCoreApplication contains the main event loop, where all events from the operating system (e.g., timer and network events) and other sources are processed and dispatched. It also handles the application's initialization and finalization, as well as system-wide and application-wide settings.</p>
<p>The command line arguments which QCoreApplication's constructor should be called with are accessible using arguments(). The event loop is started with a call to exec(). Long running operations can call processEvents() to keep the application responsive.</p>
<p>Some Qt classes, such as QString, can be used without a QCoreApplication object. However, in general, we recommend that you create a QCoreApplication or a QApplication object in your <tt>main()</tt> function as early as possible.</p>
<p>An application has an applicationDirPath() and an applicationFilePath(). Translation files can be added or removed using installTranslator() and removeTranslator(). Application strings can be translated using translate(). The QObject::tr() and QObject::trUtf8() functions are implemented in terms of translate().</p>
<p>The class provides a quit() slot and an aboutToQuit() signal.</p>
<p>Several static convenience functions are also provided. The QCoreApplication object is available from instance(). Events can be sent or posted using sendEvent(), postEvent(), and sendPostedEvents(). Pending events can be removed with removePostedEvents() or flushed with flush(). Library paths (see QLibrary) can be retrieved with libraryPaths() and manipulated by setLibraryPaths(), addLibraryPath(), and removeLibraryPath().</p>

*/">
    <method name="private QCoreApplication(com.trolltech.qt.QNativePointer argc__0, com.trolltech.qt.QNativePointer argv__1)" doc="/**
<p>Constructs a Qt kernel application. Kernel applications are applications without a graphical user interface. These type of applications are used at the console or as server processes.</p>
<p>The <i>argc</i> and <i>argv</i> arguments are processed by the application, and made available in a more convenient form by the arguments() function.</p>

*/"/>
    <method name="public boolean event(com.trolltech.qt.core.QEvent arg__0)"/>
    <method name="public boolean notify(com.trolltech.qt.core.QObject arg__0, com.trolltech.qt.core.QEvent arg__1)" doc="/**
<p>Sends <i>event</i> to <i>receiver</i>: <i>receiver</i>-&gt;event(<i>event</i>). Returns the value that is returned from the receiver's event handler.</p>
<p>For certain types of events (e.g. mouse and key events), the event will be propagated to the receiver's parent and so on up to the top-level object if the receiver is not interested in the event (i.e., it returns false).</p>
<p>There are five different ways that events can be processed; reimplementing this virtual function is just one of them. All five approaches are listed below:</p>
<ol type=&quote;1&quote;>
<li>Reimplementing paintEvent(), mousePressEvent() and so on. This is the commonest, easiest and least powerful way.</li>
<li>Reimplementing this function. This is very powerful, providing complete control; but only one subclass can be active at a time.</li>
<li>Installing an event filter on QCoreApplication::instance(). Such an event filter is able to process all events for all widgets, so it's just as powerful as reimplementing notify(); furthermore, it's possible to have more than one application-global event filter. Global event filters even see mouse events for disabled widgets.</li>
<li>Reimplementing QObject::event() (as QWidget does). If you do this you get Tab key presses, and you get to see the events before any widget-specific event filters.</li>
<li>Installing an event filter on the object. Such an event filter gets all the events except Tab and Shift-Tab key presses.</li>
</ol>

*/"/>
    <method name="public native static void addLibraryPath(java.lang.String arg__0)" doc="/**
<p>Appends <i>path</i> to the end of the library path list. If <i>path</i> is empty or already in the path list, the path list is not changed.</p>
<p>The default path list consists of a single entry, the installation directory for plugins. The default installation directory for plugins is <tt>INSTALL/plugins</tt>, where <tt>INSTALL</tt> is the directory where Qt was installed.</p>

*/"/>
    <method name="public native static java.lang.String applicationDirPath()" doc="/**
<p>Returns the directory that contains the application executable.</p>
<p>For example, if you have installed Qt in the <tt>C:\Trolltech\Qt</tt> directory, and you run the <tt>regexp</tt> example, this function will return &quot;C:/Trolltech/Qt/examples/tools/regexp&quot;.</p>
<p>On Mac OS X this will point to the directory actually containing the executable, which may be inside of an application bundle (if the application is bundled).</p>
<p><b>Warning:</b> On Unix, this function assumes that argv[0] contains the file name of the executable (which it normally does). It also assumes that the current directory hasn't been changed by the application.</p>

*/"/>
    <method name="public native static java.lang.String applicationFilePath()" doc="/**
<p>Returns the file path of the application executable.</p>
<p>For example, if you have installed Qt in the <tt>/usr/local/qt</tt> directory, and you run the <tt>regexp</tt> example, this function will return &quot;/usr/local/qt/examples/tools/regexp/regexp&quot;.</p>
<p><b>Warning:</b> On Unix, this function assumes that argv[0] contains the file name of the executable (which it normally does). It also assumes that the current directory hasn't been changed by the application.</p>

*/"/>
    <method name="public native static java.lang.String applicationName()"/>
    <method name="public native static java.util.List&lt;java.lang.String&gt; arguments()" doc="/**
<p>Returns the list of command-line arguments.</p>
<p>arguments().at(0) is the program name, arguments().at(1) is the first argument, and arguments().last() is the last argument.</p>
<p>Calling this function is slow - you should store the result in a variable when parsing the command line.</p>
<p><b>Warning:</b> On Unix, this list is built from the argc and argv parameters passed to the constructor in the main() function. The string-data in argv is interpreted using QString::fromLocal8Bit(); hence it is not possible to pass i.e. Japanese command line arguments on a system that runs in a latin1 locale. Most modern Unix systems do not have this limitation, as they are Unicode based.</p>
<p>On NT-based Windows, this limitation does not apply either.</p>

*/"/>
    <method name="public native static boolean closingDown()" doc="/**
<p>Returns true if the application objects are being destroyed; otherwise returns false.</p>

*/"/>
    <method name="public native static int exec()" doc="/**
<p>Enters the main event loop and waits until exit() is called. Returns the value that was set to exit() (which is 0 if exit() is called via quit()).</p>
<p>It is necessary to call this function to start event handling. The main event loop receives events from the window system and dispatches these to the application widgets.</p>
<p>To make your application perform idle processing (i.e. executing a special function whenever there are no pending events), use a QTimer with 0 timeout. More advanced idle processing schemes can be achieved using processEvents().</p>

*/"/>
    <method name="public native static void exit(int retcode__0)" doc="/**
<p>Tells the application to exit with a return code.</p>
<p>After this function has been called, the application leaves the main event loop and returns from the call to exec(). The exec() function returns <i>returnCode</i>.</p>
<p>By convention, a <i>returnCode</i> of 0 means success, and any non-zero value indicates an error.</p>
<p>Note that unlike the C library function of the same name, this function <i>does</i> return to the caller -- it is event processing that stops.</p>

*/"/>
    <method name="public native static void flush()" doc="/**
<p>Flushes the platform specific event queues.</p>
<p>If you are doing graphical changes inside a loop that does not return to the event loop on asynchronous window systems like X11 or double buffered window systems like Mac OS X, and you want to visualize these changes immediately (e.g. Splash Screens), call this function.</p>

*/"/>
    <method name="public native static boolean hasPendingEvents()" doc="/**
<p>This function returns true if there are pending events; otherwise returns false. Pending events can be either from the window system or posted events using postEvent().</p>

*/"/>
    <method name="public final static void installTranslator(com.trolltech.qt.core.QTranslator messageFile__0)" doc="/**
<p>Adds the translation file <i>translationFile</i> to the list of translation files to be used for translations.</p>
<p>Multiple translation files can be installed. Translations are searched for in the last installed translation file on, back to the first installed translation file. The search stops as soon as a matching translation is found.</p>

*/"/>
    <method name="public native static com.trolltech.qt.core.QCoreApplication instance()" doc="/**
<p>Returns a pointer to the application's QCoreApplication (or QApplication) instance.</p>

*/"/>
    <method name="public native static java.util.List&lt;java.lang.String&gt; libraryPaths()" doc="/**
<p>Returns a list of paths that the application will search when dynamically loading libraries.</p>
<p>This list will include the installation directory for plugins if it exists (the default installation directory for plugins is <tt>INSTALL/plugins</tt>, where <tt>INSTALL</tt> is the directory where Qt was installed). The directory of the application executable (NOT the working directory) is always added, as well as the colon separated entries of the QT_PLUGIN_PATH environment variable.</p>
<p>If you want to iterate over the list, you can use the foreach pseudo-keyword:</p>
<pre>    foreach (QString path, app.libraryPaths())
        do_something(path);</pre>

*/"/>
    <method name="public native static java.lang.String organizationDomain()"/>
    <method name="public native static java.lang.String organizationName()"/>
    <method name="public final static void postEvent(com.trolltech.qt.core.QObject receiver__0, com.trolltech.qt.core.QEvent event__1)" doc="/**
<p>Adds the event <i>event</i> with the object <i>receiver</i> as the receiver of the event, to an event queue and returns immediately.</p>
<p>The event must be allocated on the heap since the post event queue will take ownership of the event and delete it once it has been posted. It is <i>not safe</i> to modify or delete the event after it has been posted.</p>
<p>When control returns to the main event loop, all events that are stored in the queue will be sent using the notify() function.</p>

*/"/>
    <method name="public final static void processEvents(com.trolltech.qt.core.QEventLoop.ProcessEventsFlags flags__0)" doc="/**
<p>Processes all pending events according to the specified <i>flags</i> until there are no more events to process.</p>
<p>You can call this function occasionally when your program is busy performing a long operation (e.g. copying a file).</p>

*/"/>
    <method name="public final static void processEvents(com.trolltech.qt.core.QEventLoop.ProcessEventsFlags flags__0, int maxtime__1)" doc="/**
<p>Processes pending events for <i>maxtime</i> milliseconds or until there are no more events to process, whichever is shorter.</p>
<p>You can call this function occasionally when you program is busy doing a long operation (e.g. copying a file).</p>

*/"/>
    <method name="public native static void quit()" doc="/**
<p>Tells the application to exit with return code 0 (success). Equivalent to calling QCoreApplication::exit(0).</p>
<p>It's common to connect the QApplication::lastWindowClosed() signal to quit(), and you also often connect e.g. QAbstractButton::clicked() or signals in QAction, QMenu, or QMenuBar to it.</p>
<p>Example:</p>
<pre>    QPushButton *quitButton = new QPushButton(&quot;Quit&quot;);
    connect(quitButton, SIGNAL(clicked()), &amp;app, SLOT(quit()));</pre>

*/"/>
    <method name="public native static void removeLibraryPath(java.lang.String arg__0)" doc="/**
<p>Removes <i>path</i> from the library path list. If <i>path</i> is empty or not in the path list, the list is not changed.</p>

*/"/>
    <method name="public final static void removePostedEvents(com.trolltech.qt.core.QObject receiver__0)" doc="/**
<p>Removes all events posted using postEvent() for <i>receiver</i>.</p>
<p>The events are <i>not</i> dispatched, instead they are removed from the queue. You should never need to call this function. If you do call it, be aware that killing events may cause <i>receiver</i> to break one or more invariants.</p>

*/"/>
    <method name="public final static void removeTranslator(com.trolltech.qt.core.QTranslator messageFile__0)" doc="/**
<p>Removes the translation file <i>translationFile</i> from the list of translation files used by this application. (It does not delete the translation file from the file system.)</p>

*/"/>
    <method name="public final static boolean sendEvent(com.trolltech.qt.core.QObject receiver__0, com.trolltech.qt.core.QEvent event__1)" doc="/**
<p>Sends event <i>event</i> directly to receiver <i>receiver</i>, using the notify() function. Returns the value that was returned from the event handler.</p>
<p>The event is <i>not</i> deleted when the event has been sent. The normal approach is to create the event on the stack, for example:</p>
<pre>    QMouseEvent event(QEvent::MouseButtonPress, pos, 0, 0);
    QApplication::sendEvent(mainWindow, &amp;event);</pre>

*/"/>
    <method name="public final static void sendPostedEvents(com.trolltech.qt.core.QObject receiver__0, int event_type__1)" doc="/**
<p>Immediately dispatches all events which have been previously queued with QCoreApplication::postEvent() and which are for the object <i>receiver</i> and have the event type <i>event_type</i>.</p>
<p>Note that events from the window system are <i>not</i> dispatched by this function, but by processEvents().</p>
<p>If <i>receiver</i> is null, the events of <i>event_type</i> are sent for all objects. If <i>event_type</i> is 0, all the events are sent for <i>receiver</i>.</p>

*/"/>
    <method name="public native static void sendPostedEvents()" doc="/**
<p>Dispatches all posted events, i.e. empties the event queue.</p>

*/"/>
    <method name="public native static void setApplicationName(java.lang.String application__0)"/>
    <method name="public final static void setAttribute(com.trolltech.qt.core.Qt.ApplicationAttribute attribute__0, boolean on__1)" doc="/**
<p>Sets the attribute <i>attribute</i> if <i>on</i> is true; otherwise clears the attribute.</p>

*/"/>
    <method name="public native static void setLibraryPaths(java.util.List&lt;java.lang.String&gt; arg__0)" doc="/**
<p>Sets the list of directories to search when loading libraries to <i>paths</i>. All existing paths will be deleted and the path list will consist of the paths given in <i>paths</i>.</p>

*/"/>
    <method name="public native static void setOrganizationDomain(java.lang.String orgDomain__0)"/>
    <method name="public native static void setOrganizationName(java.lang.String orgName__0)"/>
    <method name="public native static boolean startingUp()" doc="/**
<p>Returns true if an application object has not been created yet; otherwise returns false.</p>

*/"/>
    <method name="public final static boolean testAttribute(com.trolltech.qt.core.Qt.ApplicationAttribute attribute__0)" doc="/**
<p>Returns true if attribute <i>attribute</i> is set; otherwise returns false.</p>

*/"/>
    <method name="public final static java.lang.String translate(com.trolltech.qt.QNativePointer context__0, com.trolltech.qt.QNativePointer key__1, com.trolltech.qt.QNativePointer comment__2, com.trolltech.qt.core.QCoreApplication.Encoding encoding__3)"/>
    <method name="public final static java.lang.String translate(com.trolltech.qt.QNativePointer context__0, com.trolltech.qt.QNativePointer key__1, com.trolltech.qt.QNativePointer comment__2, com.trolltech.qt.core.QCoreApplication.Encoding encoding__3, int n__4)" doc="/**
<p>Returns the translation text for <i>sourceText</i>, by querying the installed translation files. The translation files are searched from the most recently installed file back to the first installed file.</p>
<p>QObject::tr() and QObject::trUtf8() provide this functionality more conveniently.</p>
<p><i>context</i> is typically a class name (e.g., &quot;MyDialog&quot;) and <i>sourceText</i> is either English text or a short identifying text.</p>
<p><i>comment</i> is a disambiguating comment, for when the same <i>sourceText</i> is used in different roles within the same context. By default, it is null. <i>encoding</i> indicates the 8-bit encoding of character stings See the QTranslator documentation for more information about contexts and comments.</p>
<p><i>n</i> is used in conjunction with <tt>%n</tt> to support plural forms. See QObject::tr() for details.</p>
<p>If none of the translation files contain a translation for <i>sourceText</i> in <i>context</i>, this function returns a QString equivalent of <i>sourceText</i>. The encoding of <i>sourceText</i> is specified by <i>encoding</i>; it defaults to CodecForTr.</p>
<p>This function is not virtual. You can use alternative translation techniques by subclassing QTranslator.</p>
<p><b>Warning:</b> This method is reentrant only if all translators are installed <i>before</i> calling this method. Installing or removing translators while performing translations is not supported. Doing so will most likely result in crashes or other undesirable behavior.</p>

*/"/>
    <enum name="Encoding" doc="/**
<p>This enum type defines the 8-bit encoding of character string arguments to translate():</p>
<p><table border=&quote;1&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; width=&quote;100%&quote;>
<tr><th width=&quote;25%&quote;>Constant</th><th width=&quote;15%&quote;>Value</th><th width=&quote;60%&quote;>Description</th></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The encoding specified by QTextCodec::codecForTr() (Latin-1 if none has been set).</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>UTF-8.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>(Obsolete) Use CodecForTr instead.</td></tr>
</table></p>

*/"/>
</class>
