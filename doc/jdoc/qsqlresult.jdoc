<class name="QSqlResult" doc="/**
<p>The QSqlResult class provides an abstract interface for accessing data from specific SQL databases.</p>
<p>Normally, you would use QSqlQuery instead of QSqlResult, since QSqlQuery provides a generic wrapper for database-specific implementations of QSqlResult.</p>
<p>If you are implementing your own SQL driver (by subclassing QSqlDriver), you will need to provide your own QSqlResult subclass that implements all the pure virtual functions and other virtual functions that you need.</p>

*/">
    <method name="protected QSqlResult(com.trolltech.qt.sql.QSqlDriver db__0)" doc="/**
<p>Creates a QSqlResult using database driver <i>db</i>. The object is initialized to an inactive state.</p>

*/"/>
    <method name="protected final void addBindValue(java.lang.Object val__0, com.trolltech.qt.sql.QSql.ParamType type__1)" doc="/**
<p>Binds the value <i>val</i> of parameter type <i>paramType</i> to the next available position in the current record (row).</p>

*/"/>
    <method name="protected final int at()" doc="/**
<p>Returns the current (zero-based) row position of the result. May return the special values QSql::BeforeFirstRow or QSql::AfterLastRow.</p>

*/"/>
    <method name="protected final com.trolltech.qt.sql.QSql.ParamType bindValueType(java.lang.String placeholder__0)" doc="/**
<p>Returns the parameter type for the value bound with the given <i>placeholder</i> name.</p>

*/"/>
    <method name="protected final com.trolltech.qt.sql.QSql.ParamType bindValueType(int pos__0)" doc="/**
<p>Returns the parameter type for the value bound at position <i>index</i>.</p>

*/"/>
    <method name="protected final com.trolltech.qt.sql.QSqlResult.BindingSyntax bindingSyntax()" doc="/**
<p>Returns the binding syntax used by prepared queries.</p>

*/"/>
    <method name="protected final java.lang.Object boundValue(int pos__0)" doc="/**
<p>Returns the value bound at position <i>index</i> in the current record (row).</p>

*/"/>
    <method name="protected final java.lang.Object boundValue(java.lang.String placeholder__0)" doc="/**
<p>Returns the value bound by the given <i>placeholder</i> name in the current record (row).</p>

*/"/>
    <method name="protected final int boundValueCount()" doc="/**
<p>Returns the number of bound values in the result.</p>

*/"/>
    <method name="protected final java.lang.String boundValueName(int pos__0)" doc="/**
<p>Returns the name of the bound value at position <i>index</i> in the current record (row).</p>

*/"/>
    <method name="protected final java.util.List&lt;java.lang.Object&gt; boundValues()" doc="/**
<p>Returns a vector of the result's bound values for the current record (row).</p>

*/"/>
    <method name="protected final void clear()" doc="/**
<p>Clears the entire result set and releases any associated resources.</p>

*/"/>
    <method name="protected final com.trolltech.qt.sql.QSqlDriver driver()" doc="/**
<p>Returns the driver associated with the result. This is the object that was passed to the constructor.</p>

*/"/>
    <method name="protected final boolean execBatch(boolean arrayBind__0)" doc="/**
<p>Executes a prepared query in batch mode if the driver supports it, otherwise emulates a batch execution using bindValue() and exec(). QSqlDriver::hasFeature() can be used to find out whether a driver supports batch execution.</p>
<p>Batch execution can be faster for large amounts of data since it reduces network roundtrips.</p>
<p>For batch executions, bound values have to be provided as lists of variants (QVariantList).</p>
<p>Each list must contain values of the same type. All lists must contain equal amount of values (rows).</p>
<p>NULL values are passed in as typed QVariants, for example <tt>QVariant(QVariant::Int)</tt> for an integer NULL value.</p>
<p>Example:</p>
<pre>    QSqlQuery q;
    q.prepare(&quot;insert into test (i1, i2, s) values (?, ?, ?)&quot;);

    QVariantList col1;
    QVariantList col2;
    QVariantList col3;

    col1 &lt;&lt; 1 &lt;&lt; 3;
    col2 &lt;&lt; 2 &lt;&lt; 4;
    col3 &lt;&lt; &quot;hello&quot; &lt;&lt; &quot;world&quot;;

    q.bindValue(0, col1);
    q.bindValue(1, col2);
    q.bindValue(2, col3);

    if (!q.execBatch())
        qDebug() &lt;&lt; q.lastError();</pre>
<p>Here, we insert two rows into a SQL table, with each row containing three values.</p>

*/"/>
    <method name="protected final java.lang.String executedQuery()" doc="/**
<p>Returns the query that was actually executed. This may differ from the query that was passed, for example if bound values were used with a prepared query and the underlying database doesn't support prepared queries.</p>

*/"/>
    <method name="protected final boolean hasOutValues()" doc="/**
<p>Returns true if at least one of the query's bound values is a <tt>QSql::Out</tt> or a QSql::InOut; otherwise returns false.</p>

*/"/>
    <method name="protected final boolean isActive()" doc="/**
<p>Returns true if the result has records to be retrieved; otherwise returns false.</p>

*/"/>
    <method name="protected final boolean isForwardOnly()" doc="/**
<p>Returns true if you can only scroll forward through the result set; otherwise returns false.</p>

*/"/>
    <method name="protected final boolean isSelect()" doc="/**
<p>Returns true if the current result is from a <tt>SELECT</tt> statement; otherwise returns false.</p>

*/"/>
    <method name="protected final boolean isValid()" doc="/**
<p>Returns true if the result is positioned on a valid record (that is, the result is not positioned before the first or after the last record); otherwise returns false.</p>

*/"/>
    <method name="protected final com.trolltech.qt.sql.QSqlError lastError()" doc="/**
<p>Returns the last error associated with the result.</p>

*/"/>
    <method name="protected final java.lang.String lastQuery()" doc="/**
<p>Returns the current SQL query text, or an empty string if there isn't one.</p>

*/"/>
    <method name="protected abstract java.lang.Object data(int i__0)" doc="/**
<p>Returns the data for field <i>index</i> in the current row as a QVariant. This function is only called if the result is in an active state and is positioned on a valid record and <i>index</i> is non-negative. Derived classes must reimplement this function and return the value of field <i>index</i>, or QVariant() if it cannot be determined.</p>

*/"/>
    <method name="protected boolean exec()" doc="/**
<p>Executes the query.</p>

*/"/>
    <method name="protected abstract boolean fetch(int i__0)" doc="/**
<p>Positions the result to an arbitrary (zero-based) row <i>index</i>.</p>
<p>This function is only called if the result is in an active state. Derived classes must reimplement this function and position the result to the row <i>index</i>, and call setAt() with an appropriate value. Return true to indicate success, or false to signify failure.</p>

*/"/>
    <method name="protected abstract boolean fetchFirst()" doc="/**
<p>Positions the result to the first record (row 0) in the result.</p>
<p>This function is only called if the result is in an active state. Derived classes must reimplement this function and position the result to the first record, and call setAt() with an appropriate value. Return true to indicate success, or false to signify failure.</p>

*/"/>
    <method name="protected abstract boolean fetchLast()" doc="/**
<p>Positions the result to the last record (last row) in the result.</p>
<p>This function is only called if the result is in an active state. Derived classes must reimplement this function and position the result to the last record, and call setAt() with an appropriate value. Return true to indicate success, or false to signify failure.</p>

*/"/>
    <method name="protected boolean fetchNext()" doc="/**
<p>Positions the result to the next available record (row) in the result.</p>
<p>This function is only called if the result is in an active state. The default implementation calls fetch() with the next index. Derived classes can reimplement this function and position the result to the next record in some other way, and call setAt() with an appropriate value. Return true to indicate success, or false to signify failure.</p>

*/"/>
    <method name="protected boolean fetchPrevious()" doc="/**
<p>Positions the result to the previous record (row) in the result.</p>
<p>This function is only called if the result is in an active state. The default implementation calls fetch() with the previous index. Derived classes can reimplement this function and position the result to the next record in some other way, and call setAt() with an appropriate value. Return true to indicate success, or false to signify failure.</p>

*/"/>
    <method name="public java.lang.Object handle()" doc="/**
<p>Returns the low-level database handle for this result set wrapped in a QVariant or an invalid QVariant if there is no handle.</p>
<p><b>Warning:</b> Use this with uttermost care and only if you know what you're doing.</p>
<p><b>Warning:</b> The handle returned here can become a stale pointer if the result is modified (for example, if you clear it).</p>
<p><b>Warning:</b> The handle can be NULL if the result was not executed yet.</p>
<p>The handle returned here is database-dependent, you should query the type name of the variant before accessing it.</p>
<p>This example retrieves the handle for a sqlite result:</p>
<pre>    QSqlQuery query = ...
    QVariant v = query.result()-&gt;handle();
    if (v.isValid() &amp;&amp; v.typeName() == &quot;sqlite3_stmt*&quot;) {
        <span class=&quote;comment&quote;>// v.data() returns a pointer to the handle</span>
        sqlite3_stmt *handle = *static_cast&lt;sqlite3_stmt **&gt;(v.data());
        if (handle != 0) { <span class=&quote;comment&quote;>// check that it is not NULL</span>
            ...
        }
    }</pre>
<p>This snippet returns the handle for PostgreSQL or MySQL:</p>
<pre>    if (v.typeName() == &quot;PGresult*&quot;) {
        PGresult *handle = *static_cast&lt;PGresult **&gt;(v.data());
        if (handle != 0) ...
    }

    if (v.typeName() == &quot;MYSQL_STMT*&quot;) {
        MYSQL_STMT *handle = *static_cast&lt;MYSQL_STMT **&gt;(v.data());
        if (handle != 0) ...
    }</pre>

*/"/>
    <method name="protected abstract boolean isNull(int i__0)" doc="/**
<p>Returns true if the field at position <i>index</i> in the current row is null; otherwise returns false.</p>

*/"/>
    <method name="protected java.lang.Object lastInsertId()" doc="/**
<p>Returns the object ID of the most recent inserted row if the database supports it. An invalid QVariant will be returned if the query did not insert any value or if the database does not report the id back. If more than one row was touched by the insert, the behavior is undefined.</p>

*/"/>
    <method name="protected abstract int numRowsAffected()" doc="/**
<p>Returns the number of rows affected by the last query executed, or -1 if it cannot be determined or if the query is a <tt>SELECT</tt> statement.</p>

*/"/>
    <method name="protected boolean prepare(java.lang.String query__0)" doc="/**
<p>Prepares the given <i>query</i> for execution; the query will normally use placeholders so that it can be executed repeatedly.</p>

*/"/>
    <method name="protected com.trolltech.qt.sql.QSqlRecord record()" doc="/**
<p>Returns the current record if the query is active; otherwise returns an empty QSqlRecord.</p>
<p>The default implementation always returns an empty QSqlRecord.</p>

*/"/>
    <method name="protected abstract boolean reset(java.lang.String sqlquery__0)" doc="/**
<p>Sets the result to use the SQL statement <i>query</i> for subsequent data retrieval.</p>
<p>Derived classes must reimplement this function and apply the <i>query</i> to the database. This function is only called after the result is set to an inactive state and is positioned before the first record of the new result. Derived classes should return true if the query was successful and ready to be used, or false otherwise.</p>

*/"/>
    <method name="protected boolean savePrepare(java.lang.String sqlquery__0)" doc="/**
<p>Prepares the given <i>query</i>, using the underlying database functionality where possible.</p>

*/"/>
    <method name="protected void setActive(boolean a__0)" doc="/**
<p>This function is provided for derived classes to set the internal active state to <i>active</i>.</p>

*/"/>
    <method name="protected void setAt(int at__0)" doc="/**
<p>This function is provided for derived classes to set the internal (zero-based) row position to <i>index</i>.</p>

*/"/>
    <method name="protected void setForwardOnly(boolean forward__0)" doc="/**
<p>Sets forward only mode to <i>forward</i>. If <i>forward</i> is true, only fetchNext() is allowed for navigating the results. Forward only mode needs much less memory since results do not have to be cached. By default, this feature is disabled.</p>

*/"/>
    <method name="protected void setLastError(com.trolltech.qt.sql.QSqlError e__0)" doc="/**
<p>This function is provided for derived classes to set the last error to <i>error</i>.</p>

*/"/>
    <method name="protected void setQuery(java.lang.String query__0)" doc="/**
<p>Sets the current query for the result to <i>query</i>. You must call reset() to execute the query on the database.</p>

*/"/>
    <method name="protected void setSelect(boolean s__0)" doc="/**
<p>This function is provided for derived classes to indicate whether or not the current statement is a SQL <tt>SELECT</tt> statement. The <i>select</i> parameter should be true if the statement is a <tt>SELECT</tt> statement; otherwise it should be false.</p>

*/"/>
    <method name="protected abstract int size()" doc="/**
<p>Returns the size of the <tt>SELECT</tt> result, or -1 if it cannot be determined or if the query is not a <tt>SELECT</tt> statement.</p>

*/"/>
    <method name="protected void virtual_hook(int id__0, com.trolltech.qt.QNativePointer data__1)"/>
    <enum name="BindingSyntax" doc="/**
<p>This enum type specifies the different syntaxes for specifying placeholders in prepared queries.</p>
<p><table border=&quote;1&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; width=&quote;100%&quote;>
<tr><th width=&quote;25%&quote;>Constant</th><th width=&quote;15%&quote;>Value</th><th width=&quote;60%&quote;>Description</th></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>Use the ODBC-style positional syntax, with &quot;?&quot; as placeholders.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>Use the Oracle-style syntax with named placeholders (e.g., &quot;:id&quot;)</td></tr>
</table></p>

*/"/>
    <enum name="VirtualHookOperation"/>
</class>
