<class name="QImageReader" doc="/**
<p>The QImageReader class provides a format independent interface for reading images from files or other devices.</p>
<p>The most common way to read images is through QImage and QPixmap's constructors, or by calling QImage::load() and QPixmap::load(). QImageReader is a specialized class which gives you more control when reading images. For example, you can read an image into a specific size by calling setScaledSize(), and you can select a clip rect, effectively loading only parts of an image, by calling setClipRect(). Depending on the underlying support in the image format, this can save memory and speed up loading of images.</p>
<p>To read an image, you start by constructing a QImageReader object. Pass either a file name or a device pointer, and the image format to QImageReader's constructor. You can then set several options, such as the clip rect (by calling setClipRect()) and scaled size (by calling setScaledSize()). canRead() returns the image if the QImageReader can read the image (i.e., the image format is supported and the device is open for reading). Call read() to read the image.</p>
<p>If any error occurs when reading the image, read() will return a null QImage. You can then call error() to find the type of error that occurred, or errorString() to get a human readable description of what went wrong.</p>
<p>Call supportedImageFormats() for a list of formats that QImageReader can read. QImageReader supports all built-in image formats, in addition to any image format plugins that support reading.</p>
<div style=&quote;padding: 0.5em; background: #e0e0e0; color: black&quote;><p>Qt supports GIF reading if it is configured that way during installation. If it is, we are required to state that &quot;The Graphics Interchange Format(c) is the Copyright property of CompuServe Incorporated. GIF(sm) is a Service Mark property of CompuServe Incorporated.&quot;</p>
<p><b>Warning:</b> If you are in a country that recognizes software patents and in which Unisys holds a patent on LZW compression and/or decompression and you want to use GIF, Unisys may require you to license that technology. Such countries include Canada, Japan, the US, France, Germany, Italy and the UK.</p>
<p>GIF support may be removed completely in a future version of Qt. We recommend using the MNG or PNG format.</p>
</div>
*/">
    <method name="public QImageReader(java.lang.String fileName__0, com.trolltech.qt.core.QByteArray format__1)" doc="/**
<p>Constructs a QImageReader object with the file name <i>fileName</i> and the image format <i>format</i>.</p>

*/"/>
    <method name="public QImageReader()" doc="/**
<p>Constructs an empty QImageReader object. Before reading an image, call setDevice() or setFileName().</p>

*/"/>
    <method name="public QImageReader(com.trolltech.qt.core.QIODevice device__0, com.trolltech.qt.core.QByteArray format__1)" doc="/**
<p>Constructs a QImageReader object with the device <i>device</i> and the image format <i>format</i>.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QColor backgroundColor()" doc="/**
<p>Returns the background color that's used when reading an image. If the image format does not support setting the background color an invalid color is returned.</p>

*/"/>
    <method name="public final boolean canRead()" doc="/**
<p>Returns true if an image can be read for the device (i.e., the image format is supported, and the device seems to contain valid data); otherwise returns false.</p>
<p>canRead() is a lightweight function that only does a quick test to see if the image data is valid. read() may still return false after canRead() returns true, if the image data is corrupt.</p>
<p>For images that support animation, canRead() returns false when all frames have been read.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QRect clipRect()" doc="/**
<p>Returns the clip rect (also known as the ROI, or Region Of Interest) of the image. If no clip rect has been set, an invalid QRect is returned.</p>

*/"/>
    <method name="public final int currentImageNumber()" doc="/**
<p>For image formats that support animation, this function returns the sequence number of the current frame. Otherwise, -1 is returned.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QRect currentImageRect()" doc="/**
<p>For image formats that support animation, this function returns the rect for the current frame. Otherwise, a null rect is returned.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QIODevice device()" doc="/**
<p>Returns the device currently assigned to QImageReader, or 0 if no device has been assigned.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QImageReader.ImageReaderError error()" doc="/**
<p>Returns the type of error that occurred last.</p>

*/"/>
    <method name="public final java.lang.String errorString()" doc="/**
<p>Returns a human readable description of the last error that occurred.</p>

*/"/>
    <method name="public final java.lang.String fileName()" doc="/**
<p>If the currently assigned device is a QFile, or if setFileName() has been called, this function returns the name of the file QImageReader reads from. Otherwise (i.e., if no device has been assigned or the device is not a QFile), an empty QString is returned.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QByteArray format()" doc="/**
<p>Returns the format QImageReader uses for reading images.</p>
<p>You can call this function after assigning a device to the reader to determine the format of the device. For example:</p>
<pre>    QImageReader reader(&quot;image.png&quot;);
<span class=&quote;comment&quote;>    // reader.format() == &quot;png&quot;</span></pre>

*/"/>
    <method name="public final int imageCount()" doc="/**
<p>For image formats that support animation, this function returns the total number of images in the animation.</p>
<p>Certain animation formats do not support this feature, in which case 0 is returned.</p>

*/"/>
    <method name="public final boolean jumpToImage(int imageNumber__0)" doc="/**
<p>For image formats that support animation, this function skips to the image whose sequence number is <i>imageNumber</i>. The next call to read() will attempt to read this image.</p>

*/"/>
    <method name="public final boolean jumpToNextImage()" doc="/**
<p>For image formats that support animation, this function steps over the current image.</p>
<p>The default implementation calls read(), and then discards the resulting image, but the image handler may have a more efficient way of implementing this operation.</p>

*/"/>
    <method name="public final int loopCount()" doc="/**
<p>For image formats that support animation, this function returns the number of times the animation should loop. Otherwise, it returns -1.</p>

*/"/>
    <method name="public final int nextImageDelay()" doc="/**
<p>For image formats that support animation, this function returns the number of milliseconds to wait until displaying the next frame in the animation. Otherwise, 0 is returned.</p>

*/"/>
    <method name="public final int quality()" doc="/**
<p>Returns the quality level of the image.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QImage read()" doc="/**
<p>Reads an image from the device. On success, the image that was read is returned; otherwise, a null QImage is returned. You can then call error() to find the type of error that occurred, or errorString() to get a human readable description of the error.</p>
<p>For image formats that support animation, calling read() repeatedly will return the next frame. When all frames have been read, a null image will be returned.</p>

*/"/>
    <method name="public final boolean read(com.trolltech.qt.QNativePointer image__0)" doc="/**
<p>Reads an image from the device into <i>image</i>, which must point to a QImage. Returns true on success; otherwise, returns false.</p>
<p>If <i>image</i> has same format and size as the image data that is about to be read, this function may not need to allocate a new image before reading. Because of this, it can be faster than the other read() overload, which always constructs a new image; especially when reading several images with the same format and size.</p>
<pre>    QImage icon(64, 64, QImage::Format_RGB32);
    QImageReader reader(&quot;icon_64x64.bmp&quot;);
    if (reader.read(&amp;icon)) {
        <span class=&quote;comment&quote;>// Display icon</span>
    }</pre>
<p>For image formats that support animation, calling read() repeatedly will return the next frame. When all frames have been read, a null image will be returned.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QRect scaledClipRect()" doc="/**
<p>Returns the scaled clip rect of the image.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QSize scaledSize()" doc="/**
<p>Returns the scaled size of the image.</p>

*/"/>
    <method name="public final void setBackgroundColor(com.trolltech.qt.gui.QColor color__0)" doc="/**
<p>Sets the background color to <i>color</i>. Image formats that support this operation are expected to initialize the background to <i>color</i> before reading an image.</p>

*/"/>
    <method name="public final void setClipRect(com.trolltech.qt.core.QRect rect__0)" doc="/**
<p>Sets the image clip rect (also known as the ROI, or Region Of Interest) to <i>rect</i>. The coordinates of <i>rect</i> are relative to the untransformed image size, as returned by size().</p>

*/"/>
    <method name="public final void setDevice(com.trolltech.qt.core.QIODevice device__0)" doc="/**
<p>Sets QImageReader's device to <i>device</i>. If a device has already been set, the old device is removed from QImageReader and is otherwise left unchanged.</p>
<p>If the device is not already open, QImageReader will attempt to open the device in QIODevice::ReadOnly mode by calling open(). Note that this does not work for certain devices, such as QProcess, QTcpSocket and QUdpSocket, where more logic is required to open the device.</p>

*/"/>
    <method name="public final void setFileName(java.lang.String fileName__0)" doc="/**
<p>Sets the file name of QImageReader to <i>fileName</i>. Internally, QImageReader will create a QFile object and open it in QIODevice::ReadOnly mode, and use this when reading images.</p>
<p>If <i>fileName</i> does not include a file extension (e.g., .png or .bmp), QImageReader will cycle through all supported extensions until it finds a matching file.</p>

*/"/>
    <method name="public final void setFormat(com.trolltech.qt.core.QByteArray format__0)" doc="/**
<p>Sets the format QImageReader will use when reading images, to <i>format</i>. <i>format</i> is a case insensitive text string. Example:</p>
<pre>    QImageReader reader;
    reader.setFormat(&quot;png&quot;); <span class=&quote;comment&quote;>// same as reader.setFormat(&quot;PNG&quot;);</span></pre>
<p>You can call supportedImageFormats() for the full list of formats QImageReader supports.</p>

*/"/>
    <method name="public final void setQuality(int quality__0)" doc="/**
<p>This is an image format specific function that sets the quality level of the image to <i>quality</i>. For image formats that do not support setting the quality, this value is ignored.</p>
<p>The value range of <i>quality</i> depends on the image format. For example, the &quot;jpeg&quot; format supports a quality range from 0 (low quality, high compression) to 100 (high quality, low compression).</p>

*/"/>
    <method name="public final void setScaledClipRect(com.trolltech.qt.core.QRect rect__0)" doc="/**
<p>Sets the scaled clip rect to <i>rect</i>. The scaled clip rect is the clip rect (also known as ROI, or Region Of Interest) that is applied after the image has been scaled.</p>

*/"/>
    <method name="public final void setScaledSize(com.trolltech.qt.core.QSize size__0)" doc="/**
<p>Sets the scaled size of the image to <i>size</i>. The scaling is performed after the initial clip rect, but before the scaled clip rect is applied. The algorithm used for scaling depends on the image format. By default (i.e., if the image format does not support scaling), QImageReader will use QImage::scale() with Qt::SmoothScaling.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QSize size()" doc="/**
<p>Returns the size of the image, without actually reading the image contents.</p>
<p>If the image format does not support this feature, this function returns an invalid size. Qt's built-in image handlers all support this feature, but custom image format plugins are not required to do so.</p>

*/"/>
    <method name="public final boolean supportsAnimation()" doc="/**
<p>Returns true if the image format supports animation; otherwise, false is returned.</p>

*/"/>
    <method name="public final boolean supportsOption(com.trolltech.qt.gui.QImageIOHandler.ImageOption option__0)" doc="/**
<p>Returns true if the reader supports <i>option</i>; otherwise returns false.</p>
<p>Different image formats support different options. Call this function to determine whether a certain option is supported by the current format. For example, the PNG format allows you to embed text into the image's metadata (see text()), and the BMP format allows you to determine the image's size without loading the whole image into memory (see size()).</p>
<pre>    QImageReader reader(&quot;:/image.png&quot;);
    if (reader.supportsOption(QImageIOHandler::Size))
        qDebug() &lt;&lt; &quot;Size:&quot; &lt;&lt; reader.size();</pre>

*/"/>
    <method name="public final java.lang.String text(java.lang.String key__0)" doc="/**
<p>Returns the image text associated with <i>key</i>.</p>
<p>Support for this option is implemented through QImageIOHandler::Description.</p>

*/"/>
    <method name="public final java.util.List&lt;java.lang.String&gt; textKeys()" doc="/**
<p>Returns the text keys for this image. You can use these keys with text() to list the image text for a certain key.</p>
<p>Support for this option is implemented through QImageIOHandler::Description.</p>

*/"/>
    <method name="public native static com.trolltech.qt.core.QByteArray imageFormat(java.lang.String fileName__0)" doc="/**
<p>If supported, this function returns the image format of the file <i>fileName</i>. Otherwise, an empty string is returned.</p>

*/"/>
    <method name="public final static com.trolltech.qt.core.QByteArray imageFormat(com.trolltech.qt.core.QIODevice device__0)" doc="/**
<p>If supported, this function returns the image format of the device <i>device</i>. Otherwise, an empty string is returned.</p>

*/"/>
    <method name="public native static java.util.List&lt;com.trolltech.qt.core.QByteArray&gt; supportedImageFormats()" doc="/**
<p>Returns the list of image formats supported by QImageReader.</p>
<p>By default, Qt can read the following formats:</p>
<p><table align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<thead><tr valign=&quote;top&quote; class=&quote;qt-style&quote;><th>Format</th><th>Description</th></tr></thead>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>BMP</td><td>Windows Bitmap</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>GIF</td><td>Graphic Interchange Format (optional)</td></tr>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>JPG</td><td>Joint Photographic Experts Group</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>JPEG</td><td>Joint Photographic Experts Group</td></tr>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>MNG</td><td>Multiple-image Network Graphics</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>PNG</td><td>Portable Network Graphics</td></tr>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>PBM</td><td>Portable Bitmap</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>PGM</td><td>Portable Graymap</td></tr>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>PPM</td><td>Portable Pixmap</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>XBM</td><td>X11 Bitmap</td></tr>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>XPM</td><td>X11 Pixmap</td></tr>
</table></p>
<p>To configure Qt with GIF support, pass <tt>-qt-gif</tt> to the <tt>configure</tt> script or check the appropriate option in the graphical installer.</p>

*/"/>
    <enum name="ImageReaderError" doc="/**
<p>This enum describes the different types of errors that can occur when reading images with QImageReader.</p>
<p><table border=&quote;1&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; width=&quote;100%&quote;>
<tr><th width=&quote;25%&quote;>Constant</th><th width=&quote;15%&quote;>Value</th><th width=&quote;60%&quote;>Description</th></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>QImageReader was used with a file name, but not file was found with that name. This can also happen if the file name contained no extension, and the file with the correct extension is not supported by Qt.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>QImageReader encountered a device error when reading the image. You can consult your particular device for more details on what went wrong.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>Qt does not support the requested image format.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The image data was invalid, and QImageReader was unable to read an image from it. The can happen if the image file is damaged.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>An unknown error occurred. If you get this value after calling read(), it is most likely caused by a bug in QImageReader.</td></tr>
</table></p>

*/"/>
</class>
