<class name="QImage" doc="/**
<p>The QImage class provides a hardware-independent image representation that allows direct access to the pixel data, and can be used as a paint device.</p>
<p>Qt provides four classes for handling image data: QImage, QPixmap, QBitmap and QPicture. QImage is designed and optimized for I/O, and for direct pixel access and manipulation, while QPixmap is designed and optimized for showing images on screen. QBitmap is only a convenience class that inherits QPixmap, ensuring a depth of 1. Finally, the QPicture class is a paint device that records and replays QPainter commands.</p>
<p>Because QImage is a QPaintDevice subclass, QPainter can be used to draw directly onto images. When using QPainter on a QImage, the painting can be performed in another thread than the current GUI thread, that is except rendering text (because QFont is GUI dependent). To render text in another thread, the text must first be derived as a QPainterPath in the GUI thread.</p>
<p>The QImage class supports several image formats described by the Format enum. These include monochrome, 8-bit, 32-bit and alpha-blended images which are available in all versions of Qt 4.x. In addition, QImage supports several formats that are specific to Qtopia Core.</p>
<p>QImage provides a collection of functions that can be used to obtain a variety of information about the image. There are also several functions that enables transformation of the image.</p>
<p>QImage objects can be passed around by value since the QImage class uses implicit data sharing. QImage objects can also be streamed and compared.</p>
<ul><li><a href=&quote;#reading-and-writing-image-files&quote;>Reading and Writing Image Files</a></li>
<li><a href=&quote;#image-information&quote;>Image Information</a></li>
<li><a href=&quote;#pixel-manipulation&quote;>Pixel Manipulation</a></li>
<li><a href=&quote;#image-formats&quote;>Image Formats</a></li>
<li><a href=&quote;#image-transformations&quote;>Image Transformations</a></li>
</ul>
<a name=&quote;reading-and-writing-image-files&quote;></a>
<h3>Reading and Writing Image Files</h3>
<p>QImage provides several ways of loading an image file: The file can be loaded when constructing the QImage object, or by using the load() or loadFromData() functions later on. QImage also provides the static fromData() function, constructing a QImage from the given data. When loading an image, the file name can either refer to an actual file on disk or to one of the application's embedded resources. See The Qt Resource System overview for details on how to embed images and other resource files in the application's executable.</p>
<p>Simply call the save() function to save a QImage object.</p>
<p>The complete list of supported file formats are available through the QImageReader::supportedImageFormats() and QImageWriter::supportedImageFormats() functions. New file formats can be added as plugins. By default, Qt supports the following formats:</p>
<p><table align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<thead><tr valign=&quote;top&quote; class=&quote;qt-style&quote;><th>Format</th><th>Description</th><th>Qt's support</th></tr></thead>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>BMP</td><td>Windows Bitmap</td><td>Read/write</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>GIF</td><td>Graphic Interchange Format (optional)</td><td>Read</td></tr>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>JPG</td><td>Joint Photographic Experts Group</td><td>Read/write</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>JPEG</td><td>Joint Photographic Experts Group</td><td>Read/write</td></tr>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>PNG</td><td>Portable Network Graphics</td><td>Read/write</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>PBM</td><td>Portable Bitmap</td><td>Read</td></tr>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>PGM</td><td>Portable Graymap</td><td>Read</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>PPM</td><td>Portable Pixmap</td><td>Read/write</td></tr>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>XBM</td><td>X11 Bitmap</td><td>Read/write</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>XPM</td><td>X11 Pixmap</td><td>Read/write</td></tr>
</table></p>
<p>(To configure Qt with GIF support, pass <tt>-qt-gif</tt> to the <tt>configure</tt> script or check the appropriate option in the graphical installer.)</p>
<a name=&quote;image-information&quote;></a>
<h3>Image Information</h3>
<p>QImage provides a collection of functions that can be used to obtain a variety of information about the image:</p>
<p><table align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<thead><tr valign=&quote;top&quote; class=&quote;qt-style&quote;><th></th><th>Available Functions</th></tr></thead>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>Geometry</td><td>The size(), width(), height(), dotsPerMeterX(), and dotsPerMeterY() functions provide information about the image size and aspect ratio.<p>The rect() function returns the image's enclosing rectangle. The valid() function tells if a given pair of coordinates is within this rectangle. The offset() function returns the number of pixels by which the image is intended to be offset by when positioned relative to other images, which also can be manipulated using the setOffset() function.</p>
</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>Colors</td><td>The color of a pixel can be retrieved by passing its coordinates to the pixel() function. The pixel() function returns the color as a QRgb value indepedent of the image's format.<p>In case of monochrome and 8-bit images, the numColors() and colorTable() functions provide information about the color components used to store the image data: The colorTable() function returns the image's entire color table. To obtain a single entry, use the pixelIndex() function to retrieve the pixel index for a given pair of coordinates, then use the color() function to retrieve the color.</p>
<p>The hasAlphaChannel() function tells if the image's format respects the alpha channel, or not. The allGray() and isGrayscale() functions tell whether an image's colors are all shades of gray.</p>
<p>See also the Pixel Manipulation and Image Transformations sections.</p>
</td></tr>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>Text</td><td>The text() function returns the image text associated with the given text key. An image's text keys can be retrieved using the textKeys() function. Use the setText() function to alter an image's text.</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>Low-level information</td><td>The depth() function returns the depth of the image. The supported depths are 1 (monochrome), 8 and 32 (for more information see the Image Formats section).<p>The format(), bytesPerLine(), and numBytes() functions provide low-level information about the data stored in the image.</p>
<p>The serialNumber() function returns a number that uniquely identifies the contents of this QImage object.</p>
</td></tr>
</table></p>
<a name=&quote;pixel-manipulation&quote;></a>
<h3>Pixel Manipulation</h3>
<p>The functions used to manipulate an image's pixels depend on the image format. The reason is that monochrome and 8-bit images are index-based and use a color lookup table, while 32-bit images store ARGB values directly. For more information on image formats, see the <a href=&quote;#image-formats&quote;>Image Formats</a> section.</p>
<p>In case of a 32-bit image, the setPixel() function can be used to alter the color of the pixel at the given coordinates to any other color specified as an ARGB quadruplet. To make a suitable QRgb value, use the qRgb() (adding a default alpha component to the given RGB values, i.e. creating an opaque color) or qRgba() function. For example:</p>
<p><table align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><font color=&quote;red&quote;>[Missing image qimage-32bit_scaled.png]</font></td><td><pre>    QImage image(3, 3, QImage::Format_RGB32);
    QRgb value;

    value = qRgb(189, 149, 39); <span class=&quote;comment&quote;>// 0xffbd9527</span>
    image.setPixel(1, 1, value);

    value = qRgb(122, 163, 39); <span class=&quote;comment&quote;>// 0xff7aa327</span>
    image.setPixel(0, 1, value);
    image.setPixel(1, 0, value);

    value = qRgb(237, 187, 51); <span class=&quote;comment&quote;>// 0xffedba31</span>
    image.setPixel(2, 1, value);</pre>
</td></tr>
<thead><tr valign=&quote;top&quote; class=&quote;qt-style&quote;><th colspan=&quote;2&quote;>32-bit</th></tr></thead>
</table></p>
<p>In case of a 8-bit and monchrome images , the pixel value is only an index from the image's color table. So the setPixel() function can only be used to alter the color of the pixel at the given coordinates to a predefined color from the image's color table, i.e. it can only change the pixel's index value. To alter or add a color to an image's color table, use the setColor() function.</p>
<p>An entry in the color table is an ARGB quadruplet encoded as an QRgb value. Use the qRgb() and qRgba() functions to make a suitable QRgb value for use with the setColor() function. For example:</p>
<p><table align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><font color=&quote;red&quote;>[Missing image qimage-8bit_scaled.png]</font></td><td><pre>    QImage image(3, 3, QImage::Format_Indexed8);
    QRgb value;

    value = qRgb(122, 163, 39); <span class=&quote;comment&quote;>// 0xff7aa327</span>
    image.setColor(0, value);

    value = qRgb(237, 187, 51); <span class=&quote;comment&quote;>// 0xffedba31</span>
    image.setColor(1, value);

    value = qRgb(189, 149, 39); <span class=&quote;comment&quote;>// 0xffbd9527</span>
    image.setColor(2, value);

    image.setPixel(0, 1, 0);
    image.setPixel(1, 0, 0);
    image.setPixel(1, 1, 2);
    image.setPixel(2, 1, 1);</pre>
</td></tr>
<thead><tr valign=&quote;top&quote; class=&quote;qt-style&quote;><th colspan=&quote;2&quote;>8-bit</th></tr></thead>
</table></p>
<p>QImage also provide the scanLine() function which returns a pointer to the pixel data at the scanline with the given index, and the bits() function which returns a pointer to the first pixel data (this is equivalent to <tt>scanLine(0)</tt>).</p>
<a name=&quote;image-formats&quote;></a>
<h3>Image Formats</h3>
<p>Each pixel stored in a QImage is represented by an integer. The size of the integer varies depending on the format. QImage supports several image formats described by the Format enum. The monochrome (1-bit), 8-bit and 32-bit images are available in all versions of Qt. In addition Qtopia Core also supports 2-bit, 4-bit, and 16-bit images. For more information about the Qtopia specific formats, see the documentation of the Format enum.</p>
<p>Monochrome images are stored using 1-bit indexes into a color table with at most two colors. There are two different types of monochrome images: big endian (MSB first) or little endian (LSB first) bit order.</p>
<p>8-bit images are stored using 8-bit indexes into a color table, i.e. they have a single byte per pixel. The color table is a QVector&lt;QRgb&gt;, and the QRgb typedef is equivalent to an unsigned int containing an ARGB quadruplet on the format 0xAARRGGBB.</p>
<p>32-bit images have no color table; instead, each pixel contains an QRgb value. There are three different types of 32-bit images storing RGB (i.e. 0xffRRGGBB), ARGB and premultiplied ARGB values respectively. In the premultiplied format the red, green, and blue channels are multiplied by the alpha component divided by 255.</p>
<p>An image's format can be retrieved using the format() function. Use the convertToFormat() functions to convert an image into another format. The allGray() and isGrayscale() functions tell whether a color image can safely be converted to a grayscale image.</p>
<a name=&quote;image-transformations&quote;></a>
<h3>Image Transformations</h3>
<p>QImage supports a number of functions for creating a new image that is a transformed version of the original: The createAlphaMask() function builds and returns a 1-bpp mask from the alpha buffer in this image, and the createHeuristicMask() function creates and returns a 1-bpp heuristic mask for this image. The latter function works by selecting a color from one of the corners, then chipping away pixels of that color starting at all the edges.</p>
<p>The mirrored() function returns a mirror of the image in the desired direction, the scaled() returns a copy of the image scaled to a rectangle of the desired measures, the rgbSwapped() fucntion constructs a BGR image from a RGB image, and the alphaChannel() function constructs an image from this image's alpha channel.</p>
<p>The scaledToWidth() and scaledToHeight() functions return scaled copies of the image.</p>
<p>The transformed() function returns a copy of the image that is transformed with the given transformation matrix and transformation mode: Internally, the transformation matrix is adjusted to compensate for unwanted translation, i.e. transformed() returns the smallest image containing all transformed points of the original image. The static trueMatrix() function returns the actual matrix used for transforming the image.</p>
<p>There are also functions for changing attributes of an image in-place:</p>
<p><table align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<thead><tr valign=&quote;top&quote; class=&quote;qt-style&quote;><th>Function</th><th>Description</th></tr></thead>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>setAlphaChannel()</td><td>Sets the alpha channel of the image.</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>setDotsPerMeterX()</td><td>Defines the aspect ratio by setting the number of pixels that fit horizontally in a physical meter.</td></tr>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>setDotsPerMeterY()</td><td>Defines the aspect ratio by setting the number of pixels that fit vertically in a physical meter.</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>fill()</td><td>Fills the entire image with the given pixel value.</td></tr>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>invertPixels()</td><td>Inverts all pixel values in the image using the given InvertMode value.</td></tr>
<tr valign=&quote;top&quote; class=&quote;even&quote;><td>setColorTable()</td><td>Sets the color table used to translate color indexes. Only monochrome and 8-bit formats.</td></tr>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td>setNumColors()</td><td>Resizes the color table. Only monochrome and 8-bit formats.</td></tr>
</table></p>

*/">
    <method name="public QImage(int width__0, int height__1, com.trolltech.qt.gui.QImage.Format format__2)" doc="/**
<p>Constructs an image with the given <i>width</i>, <i>height</i> and <i>format</i>.</p>

*/"/>
    <method name="public QImage()" doc="/**
<p>Constructs a null image.</p>

*/"/>
    <method name="public QImage(com.trolltech.qt.core.QSize size__0, com.trolltech.qt.gui.QImage.Format format__1)" doc="/**
<p>Constructs an image with the given <i>size</i> and <i>format</i>.</p>

*/"/>
    <method name="public QImage(com.trolltech.qt.gui.QImage arg__0)" doc="/**
<p>Constructs a shallow copy of the given <i>image</i>.</p>
<p>For more information about shallow copies, see the Implicit Data Sharing documentation.</p>

*/"/>
    <method name="public QImage(java.lang.String fileName__0, com.trolltech.qt.QNativePointer format__1)" doc="/**
<p>Constructs an image and tries to load the image from the file with the given <i>fileName</i>.</p>
<p>The loader attempts to read the image using the specified <i>format</i>. If the <i>format</i> is not specified (which is the default), the loader probes the file for a header to guess the file format.</p>
<p>If the loading of the image failed, this object is a null image.</p>
<p>The file name can either refer to an actual file on disk or to one of the application's embedded resources. See the Resource System overview for details on how to embed images and other resource files in the application's executable.</p>

*/"/>
    <method name="public final boolean allGray()" doc="/**
<p>Returns true if all the colors in the image are shades of gray (i.e. their red, green and blue components are equal); otherwise false.</p>
<p>Note that this function is slow for images without color table.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QImage alphaChannel()" doc="/**
<p>Extracts the alpha channel from this image as an 8 bit gray scale image and returns it.</p>

*/"/>
    <method name="public final com.trolltech.qt.QNativePointer bits()"/>
    <method name="public final int bytesPerLine()" doc="/**
<p>Returns the number of bytes per image scanline.</p>
<p>This is equivalent to numBytes()/ height().</p>

*/"/>
    <method name="public final int color(int i__0)" doc="/**
<p>Returns the color in the color table at index <i>i</i>. The first color is at index 0.</p>
<p>The colors in an image's color table are specified as ARGB quadruplets (QRgb). Use the qAlpha(), qRed(), qGreen(), and qBlue() functions to get the color value components.</p>

*/"/>
    <method name="public final java.util.List&lt;java.lang.Integer&gt; colorTable()" doc="/**
<p>Returns a list of the colors contained in the image's color table, or an empty list if the image does not have a color table</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QImage convertToFormat(com.trolltech.qt.gui.QImage.Format f__0, java.util.List&lt;java.lang.Integer&gt; colorTable__1, com.trolltech.qt.core.Qt.ImageConversionFlags flags__2)" doc="/**
<p>Returns a copy of the image converted to the given <i>format</i>, using the specified <i>colorTable</i>.</p>
<p>Conversion from 32 bit to 8 bit indexed is a slow operation and will use a straightforward nearest color approach, with no dithering.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QImage convertToFormat(com.trolltech.qt.gui.QImage.Format f__0, com.trolltech.qt.core.Qt.ImageConversionFlags flags__1)" doc="/**
<p>Returns a copy of the image in the given <i>format</i>.</p>
<p>The specified image conversion <i>flags</i> control how the image data is handled during the conversion process.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QImage copy(int x__0, int y__1, int w__2, int h__3)" doc="/**
<p>The returned image is copied from the position (<i>x</i>, <i>y</i>) in this image, and will always have the given <i>width</i> and <i>height</i>. In areas beyond this image, pixels are set to 0.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QImage copy(com.trolltech.qt.core.QRect rect__0)" doc="/**
<p>Returns a sub-area of the image as a new image.</p>
<p>The returned image is copied from the position (<i>rectangle</i>.x(), <i>rectangle</i>.y()) in this image, and will always have the size of the given <i>rectangle</i>.</p>
<p>In areas beyond this image, pixels are set to 0. For 32-bit RGB images, this means black; for 32-bit ARGB images, this means transparent black; for 8-bit images, this means the color with index 0 in the color table which can be anything; for 1-bit images, this means Qt::color0.</p>
<p>If the given <i>rectangle</i> is a null rectangle the entire image is copied.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QImage createAlphaMask(com.trolltech.qt.core.Qt.ImageConversionFlags flags__0)" doc="/**
<p>Builds and returns a 1-bpp mask from the alpha buffer in this image. Returns a null image if the image's format is QImage::Format_RGB32.</p>
<p>The <i>flags</i> argument is a bitwise-OR of the Qt::ImageConversionFlags, and controls the conversion process. Passing 0 for flags sets all the default options.</p>
<p>The returned image has little-endian bit order (i.e. the image's format is QImage::Format_MonoLSB), which you can convert to big-endian (QImage::Format_Mono) using the convertToFormat() function.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QImage createHeuristicMask(boolean clipTight__0)" doc="/**
<p>Creates and returns a 1-bpp heuristic mask for this image.</p>
<p>The function works by selecting a color from one of the corners, then chipping away pixels of that color starting at all the edges. The four corners vote for which color is to be masked away. In case of a draw (this generally means that this function is not applicable to the image), the result is arbitrary.</p>
<p>The returned image has little-endian bit order (i.e. the image's format is QImage::Format_MonoLSB), which you can convert to big-endian (QImage::Format_Mono) using the convertToFormat() function.</p>
<p>If <i>clipTight</i> is true (the default) the mask is just large enough to cover the pixels; otherwise, the mask is larger than the data pixels.</p>
<p>Note that this function disregards the alpha buffer.</p>

*/"/>
    <method name="public final void detach()" doc="/**
<p>If multiple images share common data, this image makes a copy of the data and detaches itself from the sharing mechanism, making sure that this image is the only one referring to the data.</p>
<p>Nothing is done if there is just a single reference.</p>

*/"/>
    <method name="public final int dotsPerMeterX()" doc="/**
<p>Returns the number of pixels that fit horizontally in a physical meter. Together with dotsPerMeterY(), this number defines the intended scale and aspect ratio of the image.</p>

*/"/>
    <method name="public final int dotsPerMeterY()" doc="/**
<p>Returns the number of pixels that fit vertically in a physical meter. Together with dotsPerMeterX(), this number defines the intended scale and aspect ratio of the image.</p>

*/"/>
    <method name="public final void fill(int pixel__0)" doc="/**
<p>Fills the entire image with the given <i>pixelValue</i>.</p>
<p>If the depth of this image is 1, only the lowest bit is used. If you say fill(0), fill(2), etc., the image is filled with 0s. If you say fill(1), fill(3), etc., the image is filled with 1s. If the depth is 8, the lowest 8 bits are used and if the depth is 16 the lowest 16 bits are used.</p>
<p>Note: QImage::pixel() returns the color of the pixel at the given coordinates while QColor::pixel() returns the pixel value of the underlying window system (essentially an index value), so normally you will want to use QImage::pixel() to use a color from an existing image or QColor::rgb() to use a specific color.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QImage.Format format()" doc="/**
<p>Returns the format of the image.</p>

*/"/>
    <method name="public final boolean hasAlphaChannel()" doc="/**
<p>Returns true if the image has a format that respects the alpha channel, otherwise returns false.</p>

*/"/>
    <method name="public final void invertPixels(com.trolltech.qt.gui.QImage.InvertMode arg__0)" doc="/**
<p>Inverts all pixel values in the image.</p>
<p>The given invert <i>mode</i> only have a meaning when the image's depth is 32. The default <i>mode</i> is InvertRgb, which leaves the alpha channel unchanged. If the <i>mode</i> is InvertRgba, the alpha bits are also inverted.</p>
<p>Inverting an 8-bit image means to replace all pixels using color index <i>i</i> with a pixel using color index 255 minus <i>i</i>. The same is the case for a 1-bit image. Note that the color table is <i>not</i> changed.</p>

*/"/>
    <method name="public final boolean isDetached()" doc="/**
<p>Returns true if the image is detached; otherwise returns false.</p>

*/"/>
    <method name="public final boolean isGrayscale()" doc="/**
<p>For 32-bit images, this function is equivalent to allGray().</p>
<p>For 8-bpp images, this function returns true if color(i) is QRgb(i, i, i) for all indexes of the color table; otherwise returns false.</p>

*/"/>
    <method name="public final boolean isNull()" doc="/**
<p>Returns true if it is a null image, otherwise returns false.</p>
<p>A null image has all parameters set to zero and no allocated data.</p>

*/"/>
    <method name="public final boolean load(com.trolltech.qt.core.QIODevice device__0, com.trolltech.qt.QNativePointer format__1)" doc="/**
<p>This function reads a QImage from the given <i>device</i>. This can, for example, be used to load an image directly into a QByteArray.</p>

*/"/>
    <method name="public final boolean load(java.lang.String fileName__0, com.trolltech.qt.QNativePointer format__1)" doc="/**
<p>Loads an image from the file with the given <i>fileName</i>. Returns true if the image was successfully loaded; otherwise returns false.</p>
<p>The loader attempts to read the image using the specified <i>format</i>. If the <i>format</i> is not specified (which is the default), the loader probes the file for a header to guess the file format.</p>
<p>The file name can either refer to an actual file on disk or to one of the application's embedded resources. See the Resource System overview for details on how to embed images and other resource files in the application's executable.</p>

*/"/>
    <method name="public final boolean loadFromData(com.trolltech.qt.core.QByteArray data__0, com.trolltech.qt.QNativePointer aformat__1)" doc="/**
<p>Loads an image from the given QByteArray <i>data</i>.</p>

*/"/>
    <method name="public final boolean loadFromData(com.trolltech.qt.QNativePointer buf__0, int len__1, com.trolltech.qt.QNativePointer format__2)" doc="/**
<p>Loads an image from the first <i>len</i> bytes of the given binary <i>data</i>. Returns true if the image was successfully loaded; otherwise returns false.</p>
<p>The loader attempts to read the image using the specified format. If the <i>format</i> is not specified (which is the default), the loader probes the file for a header to guess the file format.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QImage mirrored(boolean horizontally__0, boolean vertically__1)" doc="/**
<p>Returns a mirror of the image, mirrored in the horizontal and/or the vertical direction depending on whether <i>horizontal</i> and <i>vertical</i> are set to true or false.</p>
<p>Note that the original image is not changed.</p>

*/"/>
    <method name="public final int numBytes()" doc="/**
<p>Returns the number of bytes occupied by the image data.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QPoint offset()" doc="/**
<p>Returns the number of pixels by which the image is intended to be offset by when positioning relative to other images.</p>

*/"/>
    <method name="public final int pixel(com.trolltech.qt.core.QPoint pt__0)" doc="/**
<p>Returns the color of the pixel at the given <i>position</i>.</p>
<p>If the <i>position</i> is not valid, the results are undefined.</p>

*/"/>
    <method name="public final int pixel(int x__0, int y__1)" doc="/**
<p>Returns the color of the pixel at coordinates (<i>x</i>, <i>y</i>).</p>

*/"/>
    <method name="public final int pixelIndex(int x__0, int y__1)" doc="/**
<p>Returns the pixel index at (<i>x</i>, <i>y</i>).</p>

*/"/>
    <method name="public final int pixelIndex(com.trolltech.qt.core.QPoint pt__0)" doc="/**
<p>Returns the pixel index at the given <i>position</i>.</p>
<p>If <i>position</i> is not valid, or if the image is not a paletted image (depth() &gt; 8), the results are undefined.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QRect rect()" doc="/**
<p>Returns the enclosing rectangle (0, 0, width(), height()) of the image.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QImage rgbSwapped()" doc="/**
<p>Returns a QImage in which the values of the red and blue components of all pixels have been swapped, effectively converting an RGB image to an BGR image.</p>
<p>The original QImage is not changed.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QImage scaled(com.trolltech.qt.core.QSize s__0, com.trolltech.qt.core.Qt.AspectRatioMode aspectMode__1, com.trolltech.qt.core.Qt.TransformationMode mode__2)" doc="/**
<p>Returns a copy of the image scaled to a rectangle defined by the given <i>size</i> according to the given <i>aspectRatioMode</i> and <i>transformMode</i>.</p>
<p align=&quote;center&quote;><font color=&quote;red&quote;>[Missing image qimage-scaling.png]</font></p><ul>
<li>If <i>aspectRatioMode</i> is Qt::IgnoreAspectRatio, the image is scaled to <i>size</i>.</li>
<li>If <i>aspectRatioMode</i> is Qt::KeepAspectRatio, the image is scaled to a rectangle as large as possible inside <i>size</i>, preserving the aspect ratio.</li>
<li>If <i>aspectRatioMode</i> is Qt::KeepAspectRatioByExpanding, the image is scaled to a rectangle as small as possible outside <i>size</i>, preserving the aspect ratio.</li>
</ul>
<p>If the given <i>size</i> is empty, this function returns a null image.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QImage scaled(int w__0, int h__1, com.trolltech.qt.core.Qt.AspectRatioMode aspectMode__2, com.trolltech.qt.core.Qt.TransformationMode mode__3)" doc="/**
<p>Returns a copy of the image scaled to a rectangle with the given <i>width</i> and <i>height</i> according to the given <i>aspectRatioMode</i> and <i>transformMode</i>.</p>
<p>If either the <i>width</i> or the <i>height</i> is zero or negative, this function returns a null image.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QImage scaledToHeight(int h__0, com.trolltech.qt.core.Qt.TransformationMode mode__1)" doc="/**
<p>Returns a scaled copy of the image. The returned image is scaled to the given <i>height</i> using the specified transformation <i>mode</i>.</p>
<p>This function automatically calculates the width of the image so that the ratio of the image is preserved.</p>
<p>If the given <i>height</i> is 0 or negative, a null image is returned.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QImage scaledToWidth(int w__0, com.trolltech.qt.core.Qt.TransformationMode mode__1)" doc="/**
<p>Returns a scaled copy of the image. The returned image is scaled to the given <i>width</i> using the specified transformation <i>mode</i>.</p>
<p>This function automatically calculates the height of the image so that its aspect ratio is preserved.</p>
<p>If the given <i>width</i> is 0 or negative, a null image is returned.</p>

*/"/>
    <method name="public final com.trolltech.qt.QNativePointer scanLine(int arg__0)"/>
    <method name="public final int serialNumber()" doc="/**
<p>Returns a number that identifies the contents of this QImage object. Distinct QImage objects can only have the same serial number if they refer to the same contents (but they don't have to). Also, the serial number of a QImage may change during the lifetime of the object.</p>
<p>A null image has always a serial number of 0.</p>
<p>Serial numbers are moslty useful in conjunction with cacheing.</p>

*/"/>
    <method name="public final void setAlphaChannel(com.trolltech.qt.gui.QImage alphaChannel__0)" doc="/**
<p>Sets the alpha channel of this image to the given <i>alphaChannel</i>.</p>
<p>If <i>alphaChannel</i> is an 8 bit grayscale image, the intensity values are written into this buffer directly. Otherwise, <i>alphaChannel</i> is converted to 32 bit and the intensity of the RGB pixel values is used.</p>
<p>Note that the image will be converted to the Format_ARGB32_Premultiplied format if the function succeeds.</p>

*/"/>
    <method name="public final void setColor(int i__0, int c__1)" doc="/**
<p>Sets the color at the given <i>index</i> in the color table, to the given to <i>colorValue</i>.</p>
<p>The color value is an ARGB quadruplet.</p>

*/"/>
    <method name="public final void setColorTable(java.util.List&lt;java.lang.Integer&gt; colors__0)" doc="/**
<p>Sets the color table used to translate color indexes to QRgb values, to the specified <i>colors</i>.</p>

*/"/>
    <method name="public final void setDotsPerMeterX(int arg__0)" doc="/**
<p>Sets the number of pixels that fit horizontally in a physical meter, to <i>x</i>.</p>
<p>Together with dotsPerMeterY(), this number defines the intended scale and aspect ratio of the image.</p>

*/"/>
    <method name="public final void setDotsPerMeterY(int arg__0)" doc="/**
<p>Sets the number of pixels that fit vertically in a physical meter, to <i>y</i>.</p>
<p>Together with dotsPerMeterX(), this number defines the intended scale and aspect ratio of the image.</p>

*/"/>
    <method name="public final void setNumColors(int arg__0)" doc="/**
<p>Resizes the color table to contain <i>numColors</i> entries.</p>
<p>If the color table is expanded, all the extra colors will be set to transparent (i.e qRgba(0, 0, 0, 0)).</p>

*/"/>
    <method name="public final void setOffset(com.trolltech.qt.core.QPoint arg__0)" doc="/**
<p>Sets the the number of pixels by which the image is intended to be offset by when positioning relative to other images, to <i>offset</i>.</p>

*/"/>
    <method name="public final void setPixel(int x__0, int y__1, int index_or_rgb__2)" doc="/**
<p>Sets the pixel index or color at (<i>x</i>, <i>y</i>) to <i>index_or_rgb</i>.</p>

*/"/>
    <method name="public final void setPixel(com.trolltech.qt.core.QPoint pt__0, int index_or_rgb__1)" doc="/**
<p>Sets the pixel index or color at the given <i>position</i> to <i>index_or_rgb</i>.</p>
<p>If the image's format is either monochrome or 8-bit, the given <i>index_or_rgb</i> value must be an index in the image's color table, otherwise the parameter must be a QRgb value.</p>
<p>If <i>position</i> is not a valid coordinate pair in the image, or if <i>index_or_rgb</i> &gt;= numColors() in the case of monochrome and 8-bit images, the result is undefined.</p>

*/"/>
    <method name="public final void setText(com.trolltech.qt.QNativePointer key__0, com.trolltech.qt.QNativePointer lang__1, java.lang.String arg__2)" doc="/**
<p>Sets the image text to the given <i>text</i> and associate it with the given <i>key</i>. The text is recorded in the specified <i>language</i>, or in a default language if <i>language</i> is 0.</p>
<p>Use setText() instead.</p>
<p>The language the text is recorded in is no longer relevant since the text is always set using QString and UTF-8 representation.</p>

*/"/>
    <method name="public final void setText(java.lang.String key__0, java.lang.String value__1)" doc="/**
<p>Sets the image text to the given <i>text</i> and associate it with the given <i>key</i>.</p>
<p>If you just want to store a single text block (i.e., a &quot;comment&quot; or just a description), you can either pass an empty key, or use a generic key like &quot;Description&quot;.</p>
<p>The image text is embedded into the image data when you call save() or QImageWriter::write().</p>

*/"/>
    <method name="public final com.trolltech.qt.core.QSize size()" doc="/**
<p>Returns the size of the image, i.e. its width() and height().</p>

*/"/>
    <method name="public final java.lang.String text(com.trolltech.qt.QNativePointer key__0, com.trolltech.qt.QNativePointer lang__1)" doc="/**
<p>Returns the text recorded for the given <i>key</i> in the given <i>language</i>, or in a default language if <i>language</i> is 0.</p>
<p>Use text() instead.</p>
<p>The language the text is recorded in is no longer relevant since the text is always set using QString and UTF-8 representation.</p>

*/"/>
    <method name="public final java.lang.String text(java.lang.String key__0)" doc="/**
<p>Returns the image text associated with the given <i>key</i>. If the specified <i>key</i> is an empty string, the whole image text is returned, with each key-text pair separated by a newline.</p>

*/"/>
    <method name="public final java.util.List&lt;java.lang.String&gt; textKeys()" doc="/**
<p>Returns the text keys for this image.</p>
<p>You can use these keys with text() to list the image text for a certain key.</p>

*/"/>
    <method name="public final java.util.List&lt;java.lang.String&gt; textLanguages()" doc="/**
<p>Returns the language identifiers for which some texts are recorded. Note that if you want to iterate over the list, you should iterate over a copy.</p>
<p>The language the text is recorded in is no longer relevant since the text is always set using QString and UTF-8 representation.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QImage transformed(com.trolltech.qt.gui.QMatrix matrix__0, com.trolltech.qt.core.Qt.TransformationMode mode__1)" doc="/**
<p>Returns a copy of the image that is transformed using the given transformation <i>matrix</i> and transformation <i>mode</i>.</p>
<p>The transformation <i>matrix</i> is internally adjusted to compensate for unwanted translation; i.e. the image produced is the smallest image that contains all the transformed points of the original image. Use the trueMatrix() function to retrieve the actual matrix used for transforming an image</p>
<p>For smooth scaling down, this function uses code based on pnmscale.c by Jef Poskanzer.</p>
<p>pnmscale.c - read a portable anymap and scale it</p>
<div style=&quote;padding: 0.5em; background: #e0e0e0; color: black&quote;><p>Copyright (C) 1989, 1991 by Jef Poskanzer.</p>
<p>Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation. This software is provided &quot;as is&quot; without express or implied warranty.</p>
</div>
*/"/>
    <method name="public final boolean valid(int x__0, int y__1)" doc="/**
<p>Returns true if QPoint(<i>x</i>, <i>y</i>) is a valid coordinate pair within the image; otherwise returns false.</p>

*/"/>
    <method name="public final boolean valid(com.trolltech.qt.core.QPoint pt__0)" doc="/**
<p>Returns true if <i>pos</i> is a valid coordinate pair within the image; otherwise returns false.</p>

*/"/>
    <method name="public int depth()" doc="/**
<p>Returns the depth of the image.</p>
<p>The image depth is the number of bits used to encode a single pixel, also called bits per pixel (bpp) or bit planes of an image.</p>
<p>The supported depths are 1, 8 and 32.</p>

*/"/>
    <method name="public int devType()"/>
    <method name="public int height()" doc="/**
<p>Returns the height of the image.</p>

*/"/>
    <method name="public int metric(com.trolltech.qt.gui.QPaintDevice.PaintDeviceMetric metric__0)" doc="/**
<p>Returns the metric information for the given paint device <i>metric</i>.</p>

*/"/>
    <method name="public int numColors()" doc="/**
<p>Returns the size of the color table for the image.</p>
<p>Notice that numColors() returns 0 for 32-bpp images because these images do not use color tables, but instead encode pixel values as ARGB quadruplets.</p>

*/"/>
    <method name="public com.trolltech.qt.gui.QPaintEngine paintEngine()" doc="/**
<p>Used by QPainter to retreive a paint engine for the image.</p>

*/"/>
    <method name="public boolean paintingActive()"/>
    <method name="public int width()" doc="/**
<p>Returns the width of the image.</p>

*/"/>
    <method name="public final static com.trolltech.qt.gui.QImage fromData(com.trolltech.qt.core.QByteArray data__0, com.trolltech.qt.QNativePointer format__1)" doc="/**
<p>Loads an image from the given QByteArray <i>data</i>.</p>

*/"/>
    <method name="public native static com.trolltech.qt.gui.QImage fromData(com.trolltech.qt.QNativePointer data__0, int size__1, com.trolltech.qt.QNativePointer format__2)" doc="/**
<p>Constructs a QImage from the first <i>size</i> bytes of the given binary <i>data</i>. the loader attempts to read the image using the specified <i>format</i>. If the <i>format</i> is not specified (which is the default), the loader probes the file for a header to guess the file format.</p>
<p>If the loading of the image failed, this object is a null image.</p>

*/"/>
    <method name="public final static com.trolltech.qt.gui.QMatrix trueMatrix(com.trolltech.qt.gui.QMatrix arg__0, int w__1, int h__2)" doc="/**
<p>Returns the actual matrix used for transforming an image with the given <i>width</i>, <i>height</i> and <i>matrix</i>.</p>
<p>When transforming an image using the transformed() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. transformed() returns the smallest image containing all transformed points of the original image. This function returns the modified matrix, which maps points correctly from the original image into the new image.</p>

*/"/>
    <enum name="InvertMode" doc="/**
<p>This enum type is used to describe how pixel values should be inverted in the invertPixels() function.</p>
<p><table border=&quote;1&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; width=&quote;100%&quote;>
<tr><th width=&quote;25%&quote;>Constant</th><th width=&quote;15%&quote;>Value</th><th width=&quote;60%&quote;>Description</th></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>Invert only the RGB values and leave the alpha channel unchanged.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>Invert all channels, including the alpha channel.</td></tr>
</table></p>

*/"/>
    <enum name="Format" doc="/**
<p>The following image formats are available in all versions of Qt:</p>
<p><table border=&quote;1&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; width=&quote;100%&quote;>
<tr><th width=&quote;25%&quote;>Constant</th><th width=&quote;15%&quote;>Value</th><th width=&quote;60%&quote;>Description</th></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The image is invalid.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The image is stored using 1-bit per pixel. Bytes are packed with the most significant bit (MSB) first.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The image is stored using 1-bit per pixel. Bytes are packed with the less significant bit (LSB) first.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The image is stored using 8-bit indexes into a colormap.</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The image is stored using a 32-bit RGB format (0xffRRGGBB).</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The image is stored using a 32-bit ARGB format (0xAARRGGBB).</td></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The image is stored using a premultiplied 32-bit ARGB format (0xAARRGGBB), i.e. the red, green, and blue channels are multiplied by the alpha component divided by 255. (If RR, GG, or BB has a higher value than the alpha channel, the results are undefined.) Certain operations (such as image composition using alpha blending) are faster using premultiplied ARGB32 than with plain ARGB32.</td></tr>
</table></p>
<p>The following image format is specific to Qtopia Core:</p>
<p><table border=&quote;1&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; width=&quote;100%&quote;>
<tr><th width=&quote;25%&quote;>Constant</th><th width=&quote;15%&quote;>Value</th><th width=&quote;60%&quote;>Description</th></tr>
<tr><td valign=&quote;top&quote;><tt></tt></td><td align=&quote;center&quote; valign=&quote;top&quote;>&nbsp;</td><td valign=&quote;top&quote;>The image is stored using a 16-bit RGB format (5-6-5).</td></tr>
</table></p>

*/"/>
</class>
