<class name="QScrollArea" doc="/**
<p>The QScrollArea class provides a scrolling view onto another widget.</p>
<p>A scroll area is used to display the contents of a child widget within a frame. If the widget exceeds the size of the frame, the view can provide scroll bars so that the entire area of the child widget can be viewed. The child widget must be specified with setWidget(). For example:</p>
<pre>    QLabel *imageLabel = new QLabel;
    QImage image(&quot;happyguy.png&quot;);
    imageLabel-&gt;setPixmap(QPixmap::fromImage(image));

    scrollArea = new QScrollArea;
    scrollArea-&gt;setBackgroundRole(QPalette::Dark);
    scrollArea-&gt;setWidget(imageLabel);</pre>
<p>The code above creates a scroll area (shown in the images below) containing an image label. When scaling the image, the scroll area can provide the necessary scroll bars:</p>
<p><table align=&quote;center&quote; cellpadding=&quote;2&quote; cellspacing=&quote;1&quote; border=&quote;0&quote;>
<tr valign=&quote;top&quote; class=&quote;odd&quote;><td><font color=&quote;red&quote;>[Missing image qscrollarea-noscrollbars.png]</font></td><td><font color=&quote;red&quote;>[Missing image qscrollarea-onescrollbar.png]</font></td><td><font color=&quote;red&quote;>[Missing image qscrollarea-twoscrollbars.png]</font></td></tr>
</table></p>
<p>The scroll bars appearance depends on the currently set scroll bar policies. You can control the appearance of the scroll bars using the inherited functionality from QAbstractScrollArea.</p>
<p>For example, you can set the QAbstractScrollArea::horizontalScrollBarPolicy and QAbstractScrollArea::verticalScrollBarPolicy properties. Or if you want the scroll bars to adjust dynamically when the contents of the scroll area changes, you can use the horizontalScrollBar() and verticalScrollBar() functions (which enable you to access the scroll bars) and set the scroll bars' values whenever the scroll area's contents change, using the QScrollBar::setValue() function.</p>
<p>You can retrieve the child widget using the widget() function. The view can be made to be resizable with the setWidgetResizable() function. The alignment of the widget can be specified with setAlignment().</p>
<p>When using a scroll area to display the contents of a custom widget, it is important to ensure that the size hint of the child widget is set to a suitable value. If a standard QWidget is used for the child widget, it may be necessary to call QWidget::setMinimumSize() to ensure that the contents of the widget are shown correctly within the scroll area.</p>
<p>Two convenience functions ensureVisible() and ensureWidgetVisible() ensure a certain region of the contents is visible inside the viewport, by scrolling the contents if necessary.</p>
<p>For a complete example using the QScrollArea class, see the Image Viewer example. The example shows how to combine QLabel and QScrollArea to display an image.</p>

*/">
    <method name="public QScrollArea(com.trolltech.qt.gui.QWidget parent__0)" doc="/**
<p>Constructs an empty scroll area with the given <i>parent</i>.</p>

*/"/>
    <method name="public final com.trolltech.qt.core.Qt.Alignment alignment()"/>
    <method name="public final void ensureVisible(int x__0, int y__1, int xmargin__2, int ymargin__3)" doc="/**
<p>Scrolls the contents of the scroll area so that the point (<i>x</i>, <i>y</i>) is visible inside the region of the viewport with margins specified in pixels by <i>xmargin</i> and <i>ymargin</i>. If the specified point cannot be reached, the contents are scrolled to the nearest valid position. The default value for both margins is 50 pixels.</p>

*/"/>
    <method name="public final void ensureWidgetVisible(com.trolltech.qt.gui.QWidget childWidget__0, int xmargin__1, int ymargin__2)" doc="/**
<p>Scrolls the contents of the scroll area so that the <i>childWidget</i> of the scroll area's widget() is visible inside the region of the viewport with margins specified in pixels by <i>xmargin</i> and <i>ymargin</i>. If the specified point cannot be reached, the contents are scrolled to the nearest valid position. The default value for both margins is 50 pixels.</p>

*/"/>
    <method name="public final void setAlignment(com.trolltech.qt.core.Qt.Alignment arg__0)"/>
    <method name="public final void setWidget(com.trolltech.qt.gui.QWidget widget__0)" doc="/**
<p>Sets the scroll area's <i>widget</i>.</p>
<p>The <i>widget</i> becomes a child of the scroll area, and will be destroyed when the scroll area is deleted or when a new widget is set.</p>

*/"/>
    <method name="public final void setWidgetResizable(boolean resizable__0)"/>
    <method name="public final com.trolltech.qt.gui.QWidget takeWidget()" doc="/**
<p>Removes the scroll area's widget, and passes ownership of the widget to the caller.</p>

*/"/>
    <method name="public final com.trolltech.qt.gui.QWidget widget()" doc="/**
<p>Returns the scroll area's widget, or 0 if there is none.</p>

*/"/>
    <method name="public final boolean widgetResizable()"/>
    <method name="public boolean event(com.trolltech.qt.core.QEvent arg__0)"/>
    <method name="public boolean eventFilter(com.trolltech.qt.core.QObject arg__0, com.trolltech.qt.core.QEvent arg__1)"/>
    <method name="protected boolean focusNextPrevChild(boolean next__0)"/>
    <method name="protected void resizeEvent(com.trolltech.qt.gui.QResizeEvent arg__0)"/>
    <method name="protected void scrollContentsBy(int dx__0, int dy__1)"/>
    <method name="public com.trolltech.qt.core.QSize sizeHint()"/>
</class>
