<class name="QPixmapCache" doc="/**
<p>The QPixmapCache class provides an application-wide cache for pixmaps.</p>
<p>This class is a tool for optimized drawing with QPixmap. You can use it to store temporary pixmaps that are expensive to generate without using more storage space than cacheLimit(). Use insert() to insert pixmaps, find() to find them, and clear() to empty the cache.</p>
<p>QPixmapCache contains no member data, only static functions to access the global pixmap cache. It creates an internal QCache object for caching the pixmaps.</p>
<p>The cache associates a pixmap with a string (key). If two pixmaps are inserted into the cache using equal keys, then the last pixmap will hide the first pixmap. The QHash and QCache classes do exactly the same.</p>
<p>The cache becomes full when the total size of all pixmaps in the cache exceeds cacheLimit(). The initial cache limit is 1024 KB (1 MB); it is changed with setCacheLimit(). A pixmap takes roughly (<i>width</i> * <i>height</i> * <i>depth</i>)/8 bytes of memory.</p>
<p>The <i>Qt Quarterly</i> article <a href=&quote;http://doc.trolltech.com/qq/qq12-qpixmapcache.html&quote;>Optimizing with QPixmapCache</a> explains how to use QPixmapCache to speed up applications by caching the results of painting.</p>

*/">
    <method name="public native static int cacheLimit()" doc="/**
<p>Returns the cache limit (in kilobytes).</p>
<p>The default setting is 1024 kilobytes.</p>

*/"/>
    <method name="public native static void clear()" doc="/**
<p>Removes all pixmaps from the cache.</p>

*/"/>
    <method name="public native static com.trolltech.qt.QNativePointer find(java.lang.String key__0)" doc="/**
<p>Returns the pixmap associated with the <i>key</i> in the cache, or null if there is no such pixmap.</p>
<p><b>Warning:</b> If valid, you should copy the pixmap immediately (this is fast). Subsequent insertions into the cache could cause the pointer to become invalid. For this reason, we recommend you use find(const QString&amp;, QPixmap&amp;) instead.</p>
<p>Example:</p>
<pre>    QPixmap* pp;
    QPixmap p;
    if ((pp=QPixmapCache::find(&quot;my_big_image&quot;, pm))) {
        p = *pp;
    } else {
        p.load(&quot;bigimage.png&quot;);
        QPixmapCache::insert(&quot;my_big_image&quot;, new QPixmap(p));
    }
    painter-&gt;drawPixmap(0, 0, p);</pre>

*/"/>
    <method name="public native static boolean find(java.lang.String key__0, com.trolltech.qt.QNativePointer arg__1)" doc="/**
<p>Looks for a cached pixmap associated with the <i>key</i> in the cache. If the pixmap is found, the function sets <i>pm</i> to that pixmap and returns true; otherwise it leaves <i>pm</i> alone and returns false.</p>
<p>Example:</p>
<pre>    QPixmap pm;
    if (!QPixmapCache::find(&quot;my_big_image&quot;, pm)) {
        pm.load(&quot;bigimage.png&quot;);
        QPixmapCache::insert(&quot;my_big_image&quot;, pm);
    }
    painter-&gt;drawPixmap(0, 0, pm);</pre>

*/"/>
    <method name="public final static boolean insert(java.lang.String key__0, com.trolltech.qt.gui.QPixmap arg__1)" doc="/**
<p>Inserts a copy of the pixmap <i>pm</i> associated with the <i>key</i> into the cache.</p>
<p>All pixmaps inserted by the Qt library have a key starting with &quot;$qt&quot;, so your own pixmap keys should never begin &quot;$qt&quot;.</p>
<p>When a pixmap is inserted and the cache is about to exceed its limit, it removes pixmaps until there is enough room for the pixmap to be inserted.</p>
<p>The oldest pixmaps (least recently accessed in the cache) are deleted when more space is needed.</p>
<p>The function returns true if the object was inserted into the cache; otherwise it returns false.</p>

*/"/>
    <method name="public native static void remove(java.lang.String key__0)" doc="/**
<p>Removes the pixmap associated with <i>key</i> from the cache.</p>

*/"/>
    <method name="public native static void setCacheLimit(int arg__0)" doc="/**
<p>Sets the cache limit to <i>n</i> kilobytes.</p>
<p>The default setting is 1024 kilobytes.</p>

*/"/>
</class>
